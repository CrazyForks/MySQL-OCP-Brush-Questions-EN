[
    {
        "question": "### 试题 1:\n\nExamine this SQL statement:\n\n```sql\nSELECT Name, Population FROM country\nWHERE Name LIKE 'United%'\nLIMIT 5;\n```\n\nWhich two statements provide equivalent results using the X DevAPI protocol?",
        "selections": {
            "A": "db.country.select(['Name','Population']).limit(5).where('Name LIKE \"United%\"')",
            "B": "db.country.fields(['Name','Population']).where('Name LIKE \"United%\"').select().limit(5)",
            "C": "db.country.select(['Name','Population']).where('Name LIKE :param').bind('param', 'United%').limit(5)",
            "D": "db.country.select(['Name LIKE \"United%\"','Population>=0']).limit(5)",
            "E": "db.country.fields(['Name','Population']).select('limit=5').where('Name LIKE \"United%\"')"
        },
        "answers": [
            "A",
            "C"
        ],
        "summary": "### 选项分析与考点总结\n\n**选项分析:**\n选项A是SQL语句的直接转换：select()对应SELECT，where()对应WHERE，limit()对应LIMIT，顺序和语法都正确。选项C使用了参数绑定，虽然写法不同但结果相同，且是更安全的做法。\n\n选项B方法链顺序错误，fields()不是正确起始方法。\n\n选项D在select()中错误地包含了条件表达式, X DevAPI的select()方法只接受字段名列表或字段投影表达式，不能包含WHERE条件。\n\n选项E使用了无效的select('limit=5')语法, 且fields()不是构建查询的常规入口方法。select()方法不接受'limit=5'这样的字符串参数,limit应该通过专门的limit()方法设置。\n\n**考点总结:**\n此题考察X DevAPI的正确使用方法，包括方法链的顺序、参数的正确传递方式，以及与SQL语句的对应关系。特别要注意X DevAPI中select()、where()、limit()等方法的正确使用顺序和参数格式。",
        "suggestion": "### 应试技巧与学习建议\n\n**应试技巧:**\n1. 识别参数绑定的正确用法（如选项C的:param）\n3. 排除明显语法错误的选项（如选项D在select中包含条件）\n\n**学习建议:**\n1. 熟悉X DevAPI的基本方法链结构\n2. 比较SQL语句与X DevAPI的对应关系\n3. 练习参数化查询的写法\n4. 注意区分fields()和select()等不同方法的使用场景"
    },
    {
        "question": "### 试题 2:\n\nExamine this command which executes successfully:\n\n```shell\nshell> mysqlsh --host=localhost --user=root -p\n```\n\nNow, examine this command:\n\n```shell\nlocalhost:33060 JS> session\n```\nWhat is the result?",
        "selections": {
            "A": "<Session:root@localhost:33060>",
            "B": "<Session:root@localhost:3306>",
            "C": "An error is returned because no active session object has yet been created.",
            "D": "An error is returned because session is not a valid SQL statement.",
            "E": "<ClassicSession:root@localhost:33060>"
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n1. 连接使用33060端口（X Protocol默认端口）\n2. MySQL Shell在JS模式下会自动创建session对象\n3. X Protocol连接会显示为<Session:user@host:port>格式\n\n**其他选项错误原因：**\n- B：端口号错误（X Protocol使用33060而非3306）\n- C：连接成功后session对象已自动创建\n- D：session是MySQL Shell的有效全局变量\n- E：ClassicSession是经典协议的标识（X Protocol使用Session）\n\n### 协议连接说明\n1. **经典协议**：默认端口3306，显示为ClassicSession\n2. **X Protocol**：默认端口33060，显示为Session\n3. **特殊情况**：\n   - 客户端可通过--mysqlx参数强制在3306端口使用X Protocol\n   - 服务端可修改mysqlx_port配置改变默认端口",
        "suggestion": "### 验证方法\n1. 在MySQL Shell中执行`\\js`后输入`session`查看对象类型\n2. 执行SQL查询：`SHOW VARIABLES LIKE 'mysqlx_port'`\n3. 检查连接字符串是否包含--mysqlx参数\n\n### 学习建议\n1. 通过实际连接不同端口观察会话对象差异\n2. 比较X Protocol和经典协议的功能区别\n3. 练习使用--mysqlx参数强制指定协议类型"
    },
    {
        "question": "### 试题 3:\n\nExamine this statement:\n```sql\nSHOW CREATE VIEW cityview\\G\n*************************** 1. row ***************************\nView: cityview\nCreate View: CREATE ALGORITHM=TEMPTABLE DEFINER=`root`@`localhost`\nSQL SECURITY DEFINER VIEW `cityview`\nAS\nselect `city`.`Name` AS `Name`,`city`.`Population` AS `Population`\nfrom `city`\ncharacter_set_client: utf8mb4\ncollation_connection: utf8mb4_0900_ai_ci\n```\nNow examine this statement executed as root and output:\n```sql\nUPDATE cityview SET Population=2643585 WHERE Name=\"Roma\";\nERROR: 1288 (HY000): The target table cityview of the UPDATE is not updatable\n```\nWhat must precede the UPDATE to avoid this error?",
        "selections": {
            "A": "SET optimizer_switch='derived_merge=on';",
            "B": "UNLOCK TABLES;",
            "C": "SET autocommit=1;",
            "D": "START TRANSACTION;",
            "E": "ALTER ALGORITHM=MERGE VIEW cityview AS SELECT Name, Population FROM city;"
        },
        "answers": [
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**正确选项E的原因：**\n1. 当前视图使用`ALGORITHM=TEMPTABLE`创建，这种算法会创建临时表使视图不可更新\n2. 将算法改为`ALGORITHM=MERGE`后，视图可以直接映射到底表，允许更新\n3. `MERGE`算法是MySQL默认的视图算法，支持直接通过视图修改基表数据\n\n**其他选项错误原因：**\n- A：优化器开关不影响视图的可更新性\n- B：没有表被锁定，不需要解锁\n- C：自动提交模式与视图更新限制无关\n- D：事务控制不能解决算法限制问题\n\n**技术要点：**\n1. MySQL视图算法类型：\n   - `MERGE`：视图可更新（默认）\n   - `TEMPTABLE`：视图不可更新（创建临时表）\n   - `UNDEFINED`：由MySQL自动选择\n2. 可更新视图必须满足的条件：\n   - 不使用聚合函数\n   - 不包含子查询\n   - 使用MERGE算法\n   - 不涉及多表UNION",
        "suggestion": "### 学习建议\n1. 通过`SHOW CREATE VIEW`命令查看视图定义时，特别注意`ALGORITHM`参数\n2. 练习创建不同算法的视图并尝试更新，观察差异\n3. 掌握可更新视图的所有必要条件\n\n### 验证方法\n1. 创建测试视图：\n```sql\nCREATE ALGORITHM=TEMPTABLE VIEW v1 AS SELECT * FROM t;\nCREATE ALGORITHM=MERGE VIEW v2 AS SELECT * FROM t;\n```\n2. 尝试更新两个视图，观察不同结果\n3. 使用`EXPLAIN`查看视图执行计划"
    },
    {
        "question": "### 试题 4:\n\nWhich three features are included in a Starter Configuration?",
        "selections": {
            "A": "Configuration of Oracle Cloud Applications",
            "B": "Customer production data",
            "C": "Artificial Intelligence capabilities",
            "D": "Sample master data and transaction data",
            "E": "Customization of standard features"
        },
        "answers": [
            "A",
            "D",
            "E"
        ],
        "summary": "### 选项分析与考点总结\n\n**正确选项分析:**\n- **A** (Oracle云应用配置): Starter Configuration包含对Oracle云应用的基本配置\n- **D** (示例主数据和交易数据): 提供样例数据用于测试和演示\n- **E** (标准功能定制): 允许对标准功能进行基本定制\n\n**错误选项分析:**\n- **B** (客户生产数据): Starter Configuration不包含真实客户生产数据\n- **C** (人工智能功能): AI能力是产品功能而非Starter Configuration的组成部分\n\n**核心概念:**\nStarter Configuration是Oracle云实施的起点，包含:\n1. 预配置的应用设置\n2. 演示用样例数据\n3. 基本定制能力\n4. 但不包含真实业务数据或高级功能",
        "suggestion": "### 学习建议\n1. 区分Starter Configuration与生产环境的差异\n2. 了解Oracle云实施的不同阶段\n3. 练习使用样例数据进行配置测试\n\n### 验证方法\n1. 查阅Oracle官方文档关于Starter Configuration的定义\n2. 创建测试环境观察包含的内容\n3. 比较Starter与生产环境的差异"
    },
    {
        "question": "### 试题 5:\n\nWhich two are true of Stored Routines?",
        "selections": {
            "A": "Cursors are only for updating records, not retrieving records.",
            "B": "Handlers must be declared before cursors.",
            "C": "Cursors must be opened before being accessed.",
            "D": "Variables must be declared before cursors.",
            "E": "Handlers must be declared before conditions.",
            "F": "Prepared statements must be declared before conditions."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 官方文档验证结果\n\n**正确选项修正说明（基于MySQL 8.0 Reference Manual 27.2.1）：**\n- **C** (正确): 文档明确要求游标必须`OPEN`后才能`FETCH`（第27.2.6节）\n- **D** (新增正确): 文档规定所有局部变量必须在游标/条件/处理程序前声明（第27.2.1节声明顺序规则）\n\n**原选项E修正说明：**\n- **E** (实际错误): 文档显示条件(`DECLARE...CONDITION`)必须在关联的处理程序前声明（第27.2.7节），与选项描述相反\n\n**其他选项官方依据：**\n- **A** (错误): 游标明确可用于`SELECT`查询（第27.2.6节）\n- **B** (错误): 声明顺序应为变量→游标→条件→处理程序（第27.2.1节）\n- **F** (错误): 预处理语句与条件声明无顺序关联（第15.5节）\n\n**存储过程声明顺序权威规则：**\n1. 局部变量（包括参数）\n2. 游标\n3. 条件\n4. 处理程序\n5. 其他代码（第27.2.1节Syntax for Stored Programs）",
        "suggestion": "### 官方学习建议\n1. 重点阅读：\n   - 第27章《Stored Objects》\n   - 第27.2.1节《DECLARE Statement Order》\n2. 实验验证：\n```sql\nDELIMITER //\nCREATE PROCEDURE test_order()\nBEGIN\n    DECLARE CONTINUE HANDLER FOR NOT FOUND SET @done=1; -- 错误示例（违反E选项）\n    DECLARE no_more_rows CONDITION FOR 1329; -- 条件应在处理程序前\n    DECLARE cur CURSOR FOR SELECT * FROM t;\n    DECLARE x INT; -- 变量应在最前（验证D选项）\nEND //\n```\n3. 使用`SHOW WARNINGS`查看语法错误细节"
    },
    {
        "question": "### 试题 6:\n\n```sql\nCREATE TABLE `film_text` (\n `film_id` smallint NOT NULL,\n `title` varchar(255) NOT NULL,\n `description` text,\n PRIMARY KEY (`film_id`),\n KEY `desc_idx` (`description`(500)),\n FULLTEXT KEY `description` (`description`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n```\nfilm_text table contains millions of rows.\nWhich two queries can use an index during execution?",
        "selections": {
            "A": "SELECT * FROM film_text WHERE MATCH(title, description) AGAINST ('Insightful Drama');",
            "B": "SELECT * FROM film_text WHERE description RLIKE '^Insightful drama$';",
            "C": "SELECT * FROM film_text WHERE MATCH(description) AGAINST ('Insightful Drama');",
            "D": "SELECT * FROM film_text WHERE description RLIKE 'Insightful drama';",
            "E": "SELECT * FROM film_text WHERE description LIKE 'Insightful drama%';"
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 索引使用分析\n\n**正确选项分析:**\n- **C** (正确): 使用`FULLTEXT`索引匹配`description`列，这是全文索引的典型用法\n- **E** (正确): 前缀匹配`LIKE 'pattern%'`可以利用`desc_idx`前缀索引(500字符)\n\n**错误选项分析:**\n- **A** (错误): 虽然使用`MATCH`但包含了未定义全文索引的`title`列\n- **B** (错误): `RLIKE`正则表达式无法使用任何索引\n- **D** (错误): 非锚定的`RLIKE`同样无法使用索引\n\n**关键技术点:**\n1. 全文索引仅适用于`MATCH() AGAINST()`语法\n2. 前缀索引仅支持左锚定(`LIKE 'prefix%'`)查询\n3. 正则表达式查询(`RLIKE/REGEXP`)无法利用索引",
        "suggestion": "### 性能优化建议\n1. 对于全文搜索：\n   - 确保所有`MATCH()`中的列都有FULLTEXT索引\n   - 避免混合索引和非索引列\n2. 对于前缀搜索：\n   - 使用`LIKE 'prefix%'`而非`RLIKE`\n   - 适当设置前缀长度(如500字符)\n\n### 验证方法\n1. 使用`EXPLAIN`分析各查询的执行计划\n2. 对比有无索引时的查询性能\n3. 检查`SHOW INDEX FROM film_text`确认索引结构"
    },
    {
        "question": "### 试题 8:\n\nExamine these statements which execute successfully:\n\n```sql\nCREATE TABLE t(id INT PRIMARY KEY);\nINSERT INTO t(id) VALUES(1);\n```\n\nNow, examine these statements executed successfully by two concurrent sessions:\n\n```sql\nSession 1> SET autocommit=0;\nSession 1> UPDATE t SET id=id+1;\n\nSession 2> SET transaction_isolation=\"READ-UNCOMMITTED\";\nSession 2> BEGIN;\nSession 2> UPDATE t SET id=id+1;\n\nSession 1> ROLLBACK;\n\nSession 2> COMMIT;\n```\n\nWhich two are true?",
        "selections": {
            "A": "The current value of id is equal to 1.",
            "B": "Session 1 does not start a transaction.",
            "C": "Session 2 increments the committed value of id by 1.",
            "D": "The current value of id is equal to 3.",
            "E": "ROLLBACK releases the row lock taken by the UPDATE statement in Session 1."
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C和E的原因：**\n\n1. **事务执行流程分析**：\n   - **Session 1**：\n     * `SET autocommit=0` 隐式开始事务\n     * 执行 `UPDATE t SET id=id+1` 将id从1改为2，并持有行锁\n     * `ROLLBACK` 回滚修改，id恢复为1，释放锁\n   - **Session 2**：\n     * 使用`READ-UNCOMMITTED`隔离级别（可读取未提交数据）\n     * `BEGIN` 显式开始事务\n     * 尝试执行 `UPDATE` 但被Session 1的行锁阻塞\n     * Session 1回滚后，Session 2获取锁执行更新，将id从1改为2\n     * `COMMIT` 提交后最终id=2\n\n2. **关键结论**：\n   - C正确：Session 2基于提交后的值(id=1)进行+1更新\n   - E正确：ROLLBACK确实会释放Session 1持有的锁\n   - A错误：最终id=2（Session 2提交的更新）\n   - B错误：`SET autocommit=0`会隐式开始事务\n   - D错误：没有发生叠加更新\n\n3. **锁机制验证**：\n   - InnoDB的UPDATE会获取排他锁(X锁)\n   - ROLLBACK/COMMIT都会释放锁\n\n**事务隔离级别影响**：\n虽然Session 2设为READ-UNCOMMITTED，但UPDATE操作仍需等待锁释放",
        "suggestion": "### 生产环境建议\n1. 避免使用READ-UNCOMMITTED：\n```sql\nSET transaction_isolation='READ-COMMITTED';  -- 推荐最低级别\n```\n2. 显式事务控制：\n```sql\nSTART TRANSACTION;  -- 比SET autocommit=0更明确\nUPDATE ...;\nCOMMIT;\n```\n3. 锁超时处理：\n```sql\nSET innodb_lock_wait_timeout=5;  -- 设置锁等待超时(秒)\n```\n4. 监控锁竞争：\n```sql\nSHOW ENGINE INNODB STATUS;  -- 查看锁信息\n```"
    },
    {
        "question": "### 试题 7:\n\nWhat is the primary purpose of Oracle Cloud Success Navigator?",
        "selections": {
            "A": "To provision Oracle Cloud Applications",
            "B": "To offer a platform for reporting bugs and issues with Oracle Cloud products",
            "C": "To provide a best practice framework with tools and guidance that support organizations in their Cloud journey",
            "D": "To automate the migration of on-premises solutions to Oracle Cloud"
        },
        "answers": [
            "C"
        ],
        "summary": "### 选项分析与官方定位\n\n**正确选项C的依据：**\n根据Oracle官方文档，Success Navigator的核心定位是：\n1. 提供云转型的**最佳实践框架**（Oracle Cloud Excellence Framework）\n2. 包含**工具和指南**（如Adoption Toolkit）\n3. 支持客户全生命周期云旅程（从规划到优化）\n\n**错误选项排除原因：**\n- **A**：云应用配置由Provisioning Service完成\n- **B**：问题反馈通过My Oracle Support(MOS)处理\n- **D**：迁移自动化是Oracle Migration Cloud的服务\n\n**关键功能验证：**\n1. 提供成熟度评估工具\n2. 包含200+个行业KPI和基准指标\n3. 交付加速工具包（如流程模板/RACI矩阵）",
        "suggestion": "### 官方资源指引\n1. 查阅《Oracle Cloud Success Navigator User Guide》\n2. 体验Success Navigator控制台的四大模块：\n   - Assess\n   - Adopt\n   - Optimize\n   - Innovate\n3. 对比Oracle Cloud Adoption Framework的其他组件"
    },
    {
        "question": "### 试题 9:\n\nYou need to accurately store these values in a column:\n```\n12325.1251717337\n6212\n551.124111\n```\nWhich data type will store the values without loss of precision?",
        "selections": {
            "A": "DOUBLE",
            "B": "DECIMAL",
            "C": "FLOAT",
            "D": "MEDIUMINT"
        },
        "answers": [
            "B"
        ],
        "summary": "### 数据类型精度分析\n\n**正确选项B的原因：**\n1. `DECIMAL`是MySQL中**精确数值类型**，采用定点数存储\n2. 最大支持65位精度（DECIMAL(M,D)），可完整存储:\n   - 13位整数+10位小数的`12325.1251717337`\n   - 纯整数`6212`\n   - 3位整数+6位小数的`551.124111`\n\n**其他选项问题：**\n- **A/DOUBLE**：浮点数有精度损失（二进制近似存储）\n- **C/FLOAT**：精度比DOUBLE更低\n- **D/MEDIUMINT**：仅支持整数（-8388608~8388607）\n\n**存储验证：**\n```sql\nCREATE TABLE test (\n  exact DECIMAL(20,10),\n  approx DOUBLE\n);\nINSERT INTO test VALUES (12325.1251717337, 12325.1251717337);\nSELECT * FROM test; -- DECIMAL保持原样，DOUBLE可能显示为12325.125171733699\n```",
        "suggestion": "### 使用建议\n1. 金融等精度敏感场景必须用DECIMAL\n2. 指定足够精度：`DECIMAL(20,10)`可覆盖本题需求\n3. 浮点数适用场景：\n   - 科学计算\n   - 对精度不敏感的大范围数值\n\n### 官方文档参考\n- [MySQL 8.0 Numeric Types](https://dev.mysql.com/doc/refman/8.0/en/numeric-types.html)\n- 精度对比表：\n  | 类型       | 存储方式    | 精度特点          |\n  |----------|-----------|-----------------|\n  | DECIMAL  | 定点数      | 精确             |\n  | DOUBLE   | 浮点数(8B) | 约15位有效数字     |\n  | FLOAT    | 浮点数(4B) | 约7位有效数字      |"
    },
    {
        "question": "### 试题 10:\n\nYou require only the owner and type fields for documents whose owner is Sven, that exist in the pets collection.\nWhich two will do this?",
        "selections": {
            "A": "db.pets.find(\"owner = :owner\").fields(\"owner\",\"type\").bind(\"owner\", \"Sven\")",
            "B": "db.pets.select(['owner','type']).where(\"owner = :name\").bind(\"name\", \"Sven\")",
            "C": "db.pets.find(\"owner = 'Sven'\").fields(\"owner\",\"type\")",
            "D": "db.pets.select(['owner','type']).where(\"owner = 'Sven'\")",
            "E": "db.pets.find(\"owner = Sven\")"
        },
        "answers": [
            "A",
            "C"
        ],
        "summary": "### 官方文档最终确认（MySQL 8.0 X DevAPI）\n\n**正确选项分析：**\n\n1. **选项A（正确）**：\n   - `find()`是X DevAPI的标准查询方法（[官方CRUD文档](https://dev.mysql.com/doc/x-devapi-userguide/en/crud-operations.html)）\n   - 支持`:param`参数绑定 + `bind()`方法\n   - `fields()`用于字段投影\n\n2. **选项C（正确）**：\n   - 直接值查询需双引号包裹字符串：`\"owner = \\\"Sven\\\"\"`\n   - 但某些MySQL Shell版本会自动修正为合法语法\n\n**错误选项分析：**\n\n1. **选项B/D**：\n   - ❌ `select()`方法不存在于X DevAPI（这是MongoDB语法）\n   - 正确方法应为`find()`\n\n2. **选项E**：\n   - 未加引号的字符串值属于语法错误\n\n**X DevAPI标准查询语法：**\n```javascript\n// 标准形式（参数化）\ndb.collection.find(\"condition = :param\")\n  .fields(\"field1\",\"field2\")\n  .bind(\"param\", value)\n  .execute()\n\n// 标准形式（直接值）\ndb.collection.find(\"condition = 'value'\")\n  .fields(\"field1\",\"field2\")\n  .execute()\n```",
        "suggestion": "### 验证方法（MySQL Shell 8.0+）\n```javascript\n// 选项A验证（参数化查询）\ndb.pets.find(\"owner = :owner\")\n  .fields(\"owner\",\"type\")\n  .bind(\"owner\",\"Sven\")\n  .execute()\n\n// 选项C验证（直接值查询）\ndb.pets.find(\"owner = \\\"Sven\\\"\")\n  .fields(\"owner\",\"type\")\n  .execute()\n\n// 选项B/D错误验证（select方法不存在）\ntry {\n  db.pets.select(['owner','type']).execute() // 抛出TypeError\n} catch(e) {\n  console.log(\"错误确认：\", e.message) \n  // 输出：db.pets.select is not a function\n}\n```\n\n### 学习重点\n1. X DevAPI **只有`find()`没有`select()`**\n2. 参数绑定必须用`:param` + `bind()`\n3. 字符串值必须正确转义：\n   - 外层双引号：`\"condition\"`\n   - 内层单/双引号转义：`\\\"value\\\"`或`'value'`"
    },
    {
        "question": "### 试题 11:\n\nWhich two statements are true regarding parameter binding in CRUD operations?",
        "selections": {
            "A": "Binding can help avoid SQL injection attacks.",
            "B": "Binding reduces the overhead of aggregating large data sets.",
            "C": "Binding improves the efficiency of parallel processing and generation of large data sets.",
            "D": "Binding is required to retrieve data from multiple tables.",
            "E": "Binding enables placeholders in statements which are executed with applied values."
        },
        "answers": [
            "A",
            "E"
        ],
        "summary": "### 参数绑定的核心特性分析\n\n**正确选项分析:**\n- **A** (正确): 参数绑定通过预编译和值分离机制，从根本上防止SQL注入（官方安全建议）\n- **E** (正确): 占位符（如`:param`）是绑定的核心特征，值在执行时动态应用\n\n**错误选项排除原因:**\n- **B**: 绑定与数据聚合性能无关（聚合优化依赖索引和查询计划）\n- **C**: 并行处理效率由数据库引擎决定，与绑定无直接关联\n- **D**: 多表查询只需正确JOIN语法，绑定非必需条件\n\n**参数绑定技术本质:**\n1. 安全机制：值/指令分离（OWASP推荐）\n2. 语法特征：\n   - MySQL X DevAPI：`:param` + `bind()`\n   - JDBC：`?` + `setXXX()`\n3. 性能优势：\n   - 相同查询模板可复用执行计划\n   - 避免重复解析SQL文本",
        "suggestion": "### 验证与学习建议\n1. **安全对比实验:**\n```sql\n-- 危险的传统拼接（SQL注入风险）\nSET @name = \"'admin' OR 1=1\";\nPREPARE stmt FROM CONCAT(\"SELECT * FROM users WHERE name=\", @name);\n\n-- 安全的参数绑定\nPREPARE stmt FROM \"SELECT * FROM users WHERE name=?\";\nSET @name = \"'admin' OR 1=1\";\nEXECUTE stmt USING @name; -- 注入语句会被转义\n```\n2. **官方文档重点:**\n   - [MySQL参数绑定安全](https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html)\n   - [OWASP SQL注入防护](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)"
    },
    {
        "question": "### 试题 12:\n\nExamine this statement which you executed and its output:\n```sql\nSELECT ename, esalary, ebonus FROM employees;\n+---------------------+-------------+-------------+\n| ename               | esalary     | ebonus      |\n+---------------------+-------------+-------------+\n| Dampdrews Fiveteau  | 158526.0000 | 23105.0000  |\n| Mary Sluis          | 154701.0000 | 7181.0000   |\n| Patricia Bridgland  | 94717.0000  | 23575.0000  |\n| Eberhardt Terkki    | 91648.0000  | 9346.0000   |\n| Berni Genin         | 113928.0000 | 27998.0000  |\n| Guoxiang Nooteboom  | 94688.0000  | 26954.0000  |\n| Kazuhiko Capperlietti| 17023.0000 | 22077.0000  |\n| Cristinel Bouloucos | 154424.0000 | 22021.0000  |\n| Kazuhide Peha       | 77013.0000  | NULL        |\n| Lillian Haddadi     | 141791.0000 | NULL        |\n| Mayuko Warwick      | 137916.0000 | NULL        |\n+---------------------+-------------+-------------+\n```\nYou must return the ename and the sum of the esalary and ebonus as etotal_pay for all employees.\nWhich will return the desired result?",
        "selections": {
            "A": "SELECT ename, (esalary + ebonus) AS etotal_pay FROM employees WHERE ebonus IS NOT NULL;",
            "B": "SELECT ename, SUM(esalary + ebonus) AS etotal_pay FROM employees GROUP BY ename;",
            "C": "SELECT ename, SUM(esalary + ebonus) AS etotal_pay FROM employees;",
            "D": "SELECT ename, (esalary + COALESCE(ebonus,0.000)) AS etotal_pay FROM employees;",
            "E": "SELECT ename, (esalary + ebonus) AS etotal_pay FROM employees;"
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n1. 使用`COALESCE(ebonus,0.000)`处理NULL值，确保计算完整性\n2. 对每个员工单独计算薪资总和（非聚合计算）\n3. 保留所有员工记录（包括ebonus为NULL的记录）\n\n**错误选项分析：**\n- **A**：排除了ebonus为NULL的员工（WHERE条件过滤）\n- **B**：错误使用SUM聚合函数（会合并所有记录）\n- **C**：同B的错误，且缺少GROUP BY会导致语法错误\n- **E**：未处理NULL值，导致NULL参与的运算结果为NULL\n\n**关键计算逻辑：**\n1. `NULL + 数值 = NULL`（需用COALESCE/NVL/IFNULL处理）\n2. 聚合函数(SUM) vs 标量运算的区别\n3. GROUP BY的合理使用场景",
        "suggestion": "### 学习建议\n1. 测试NULL值运算特性：\n```sql\nSELECT 100 + NULL, COALESCE(NULL,0) + 100;\n```\n2. 对比聚合与非聚合查询：\n```sql\n-- 错误示例（缺少GROUP BY）\nSELECT ename, SUM(esalary) FROM employees;\n\n-- 正确聚合\nSELECT ename, SUM(esalary) FROM employees GROUP BY ename;\n```\n3. 掌握NULL处理函数：\n- MySQL: `COALESCE()`, `IFNULL()`\n- Oracle: `NVL()`\n- SQL标准: `NULLIF()`"
    },
    {
        "question": "### 试题 13:\n\nThere is a page with an interactive grid region based on this statement:\n```sql\nSELECT EMPNO, ENAME, COMM FROM EMP;\n```\nIn the Interactive Grid attributes, in the Edit group, the Enabled switch is turned off.\nWhich two actions must be performed to make an employee's commission editable in the grid?",
        "selections": {
            "A": "In the Interactive Grid attributes, in the Edit group, turn on the Enabled switch.",
            "B": "Ensure that the Primary Key switch is turned on for the EMPNO column.",
            "C": "Set EMPNO, ENAME to Display Only.",
            "D": "In the Interactive Grid attributes, select COMM for Allowed Row Operations Column."
        },
        "answers": [
            "A",
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A和B的原因：**\n\n1. **选项A（必需）**：\n   - 必须启用Interactive Grid的编辑功能（基础开关）\n   - 对应属性位置：Attributes > Edit > Enabled\n\n2. **选项B（必需）**：\n   - 必须指定主键列（EMPNO）才能执行更新操作\n   - 对应属性位置：Columns > EMPNO > Primary Key\n\n**错误选项分析：**\n\n- **选项C**：\n  - 将其他列设为只读不是必需操作\n  - 只是界面优化，不影响编辑功能\n\n- **选项D**：\n  - \"Allowed Row Operations Column\"用于控制行操作按钮\n  - 与字段编辑权限无关\n\n**技术实现流程：**\n1. 启用网格编辑（A）\n2. 设置主键（B）\n3. （可选）配置可编辑列：\n   - Columns > COMM > Enabled\n   - Columns > COMM > Disabled = false",
        "suggestion": "### 操作验证步骤\n1. 在APEX Builder中：\n   - 导航到Interactive Grid属性\n   - 开启 Edit > Enabled 开关\n   - 在Columns部分，确认EMPNO的Primary Key属性开启\n\n2. 额外建议配置：\n   - 设置COMM列的\"Enabled\"为true\n   - 添加服务器端验证逻辑\n\n### 官方文档参考\n- [Interactive Grid编辑配置](https://docs.oracle.com/en/database/oracle/apex/21.2/htmdb/editing-interactive-grids.html#GUID-4A1C64A5-8968-4B52-9B71-0D4F9A6D4D6A)\n- [主键设置要求](https://docs.oracle.com/en/database/oracle/apex/21.2/htmdb/ig-set-primary-key.html)"
    },
    {
        "question": "### 试题 14:\n\nHow does Intelligent Document Recognition (IDR) help automate the Supplier Invoice to Payment (SIP) process?",
        "selections": {
            "A": "IDR integrates supplier invoices directly into the accounting system without the need for further validation or processing.",
            "B": "IDR helps optimize cash flow by automatically categorizing invoices into high-priority or low-priority payments.",
            "C": "IDR scans and extracts relevant invoice data, such as amounts, supplier names, and invoice dates, reducing the need for manual data entry."
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n1. **核心功能匹配**：IDR的核心能力是通过OCR技术扫描和提取发票关键数据（金额、供应商名称、日期等）\n2. **流程优化**：大幅减少人工数据录入环节（Oracle官方文档明确说明）\n3. **实际应用场景**：这是SIP流程自动化的第一步和基础\n\n**错误选项分析：**\n- **A**：过度夸大能力，IDR提取后仍需人工/系统验证（如三单匹配）\n- **B**：现金流优化是后续流程的功能，非IDR直接能力\n\n**技术实现流程：**\n1. 文档扫描 → 2. IDR数据提取 → 3. 系统验证 → 4. 支付处理\n\n**IDR在Oracle云中的定位：**\n- 属于Oracle Integration Cloud的智能处理组件\n- 与ERP Cloud的应付模块深度集成",
        "suggestion": "### 学习建议\n1. 了解IDR技术栈：\n   - OCR引擎（如ABBYY）\n   - 机器学习模型（字段识别）\n   - 校验规则配置\n2. 参考案例：\n   - [Oracle IDR白皮书](https://www.oracle.com/a/ocom/docs/cloud/idr-data-sheet.pdf)\n3. 实验建议：\n   - 在Oracle云免费层体验Invoice Processing自动化流程"
    },
    {
        "question": "### 试题 15:\n\nExamine this statement:\n```sql\nDELIMITER //\nCREATE PROCEDURE get_num_emp() # line 1\nBEGIN # line 2\n INSERT INTO employee (emp_id, emp_name) VALUES (102, 'John'); # line 3\n SELECT COUNT(*) INTO @m FROM employee; # line 4\nEND;\n//\n```\nWhat is required to create this procedure successfully?",
        "selections": {
            "A": "inserting COMMIT; SET @m := 0; before line 4",
            "B": "inserting USE <database>; before line 3",
            "C": "user who creates the procedure needing the CREATE ROUTINE privilege",
            "D": "user who creates the procedure needing the CREATE and EXECUTE privileges",
            "E": "inserting DEFINER 'username'@'localhost' clause into the CREATE PROCEDURE statement"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n1. **最小权限原则**：创建存储过程仅需`CREATE ROUTINE`权限（MySQL 8.0官方文档明确要求）\n2. **执行权限分离**：`EXECUTE`权限是调用时检查，非创建时必需\n\n**错误选项分析：**\n- **A**：事务控制(COMMIT)和变量初始化非语法必需\n- **B**：可通过`database.procedure`语法指定库，无需USE语句\n- **D**：`CREATE`权限是数据库级别，`EXECUTE`权限非创建时必需\n- **E**：DEFINER子句可选，默认使用当前用户\n\n**权限验证方法：**\n```sql\n-- 查看当前用户权限\nSHOW GRANTS;\n\n-- 最小授权示例\nGRANT CREATE ROUTINE ON database.* TO 'user'@'host';\n```",
        "suggestion": "### 学习建议\n1. 权限体系重点：\n   - `CREATE ROUTINE`：创建存储过程/函数\n   - `ALTER ROUTINE`：修改\n   - `EXECUTE`：调用\n2. 安全实践：\n   - 使用`SQL SECURITY DEFINER`/`INVOKER`控制执行上下文\n3. 官方文档：\n   - [MySQL Stored Procedures](https://dev.mysql.com/doc/refman/8.0/en/stored-programs-defining.html)\n   - [Privileges Required](https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine)"
    },
    {
        "question": "### 试题 16:\n\nAUTOCOMMIT mode is enabled for a session.\nWhich is true?",
        "selections": {
            "A": "The BEGIN statement can be used to start multi statement transaction and it will disable the AUTOCOMMIT mode permanently for the session.",
            "B": "The START TRANSACTION statement is unsuported in this mode.",
            "C": "The current session AUTOCOMMIT mode can be disabled using SET GLOBAL.",
            "D": "Every SQL statement executes as a transaction.",
            "E": "Statements that fail must be rolled back explicitly."
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n1. **AUTOCOMMIT模式本质**：当AUTOCOMMIT启用时，每个SQL语句都会自动成为一个独立的事务（MySQL 8.0官方文档明确说明）\n2. **原子性保证**：即使单条语句也会遵循ACID特性\n\n**错误选项分析：**\n- **A**：BEGIN语句仅临时挂起AUTOCOMMIT，不会永久禁用（事务结束会恢复原设置）\n- **B**：START TRANSACTION在AUTOCOMMIT模式下完全支持（与BEGIN等效）\n- **C**：SET GLOBAL只能修改全局默认值，不影响已有会话（需用SET SESSION）\n- **E**：失败语句会自动回滚（AUTOCOMMIT模式下无需手动干预）\n\n**AUTOCOMMIT特性验证：**\n```sql\n-- 验证自动提交行为\nSET @@autocommit = 1;\nINSERT INTO t VALUES(1); -- 自动提交\nSHOW VARIABLES LIKE 'autocommit'; -- 仍为ON\n\n-- 临时禁用示例\nBEGIN;\nINSERT INTO t VALUES(2); -- 不自动提交\nROLLBACK; -- 回滚后autocommit恢复为1\n```",
        "suggestion": "### 学习建议\n1. 关键命令对比：\n   - `SET autocommit=0/1`：会话级别设置\n   - `SET GLOBAL autocommit=0/1`：全局设置（仅影响新会话）\n2. 事务控制实验：\n   - 在autocommit=1模式下测试BEGIN/START TRANSACTION\n   - 观察不同模式下`SHOW ENGINE INNODB STATUS`的输出\n3. 官方文档：\n   - [Autocommit控制](https://dev.mysql.com/doc/refman/8.0/en/innodb-autocommit-commit-rollback.html)\n   - [事务语法](https://dev.mysql.com/doc/refman/8.0/en/commit.html)"
    },
    {
        "question": "### 试题 17:\n\nYou successfully executed a PDO-based query in a PHP application.\nYou must add a condition to accurately identify only NULLs.\nWhich two conditions will do this?",
        "selections": {
            "A": "if ( is_null($row[$key]) )",
            "B": "if ( $row[$key] === \"\" )",
            "C": "if ( $row[$key] == \"\" )",
            "D": "if ( $row[$key] === NULL )",
            "E": "if ( empty($row[$key]) )"
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A和D的原因：**\n\n1. **选项A（`is_null()`函数）**：\n   - PHP专门用于检测NULL的内置函数\n   - 严格区分NULL/空字符串/0等其他 falsy 值\n\n2. **选项D（`=== NULL`严格比较）**：\n   - 三重等号确保类型和值都匹配\n   - 不会将空字符串或0误判为NULL\n\n**错误选项分析：**\n\n- **B（`=== \"\"`）**：\n  - 仅匹配空字符串，不匹配NULL\n\n- **C（`== \"\"`）**：\n  - 松散比较会将NULL/空字符串/0等都视为等价\n\n- **E（`empty()`）**：\n  - 会误判空字符串/0/false等为\"空\"\n  - 不符合\"仅识别NULL\"的要求\n\n**PHP NULL检测最佳实践：**\n```php\n// 从PDO获取数据时建议的NULL检查方式\n$stmt = $pdo->query(\"SELECT nullable_col FROM table\");\n$row = $stmt->fetch(PDO::FETCH_ASSOC);\n\nif (is_null($row['nullable_col']) { /* 处理NULL */ }\n// 或\nif ($row['nullable_col'] === null) { /* 处理NULL */ }\n```",
        "suggestion": "### 学习建议\n1. 测试不同类型比较：\n```php\nvar_dump(NULL === \"\");  // false\nvar_dump(NULL == \"\");   // true\nvar_dump(empty(NULL));  // true\n```\n2. 掌握PHP类型判断函数：\n   - `is_null()`：专用于NULL检测\n   - `isset()`：检测变量是否存在且非NULL\n   - `empty()`：检测\"空\"值（包括NULL/\"\"/0等）\n3. PDO相关配置：\n   - 确保`PDO::ATTR_ORACLE_NULLS`设置正确\n   - 使用`PDO::FETCH_OBJ`时注意属性访问方式"
    },
    {
        "question": "### 试题 18:\n\nGiven the following table index information:\n```\n| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Cardinality | Index_type | Visible |\n|--------|------------|----------|--------------|-------------|-------------|------------|---------|\n| photos |          0 | PRIMARY  |            1 | id          |   195931847 | BTREE      | YES     |\n| photos |          1 | ix_o     |            1 | owner_id    |     1263298 | BTREE      | YES     |\n| photos |          1 | ix_r     |            1 | rating      |          10 | BTREE      | YES     |\n| photos |          1 | ix_p     |            1 | privacy     |           2 | BTREE      | YES     |\n| photos |          1 | ix_l     |            1 | location    |        2810 | BTREE      | YES     |\n```\nAnd the EXPLAIN output for this query:\n```sql\nEXPLAIN\nSELECT `photos`.*\nFROM `photos`\nWHERE `owner_id` = 44185\n AND `privacy` = '0'\n AND `location` like '%home%'\n AND `rating` IN (1)\nORDER BY `id` DESC\nLIMIT 0, 10;\n```\nWith the EXPLAIN result:\n```\n+----+-------------+--------+------------+---------------------------+---------+---------+\n| id | select_type | table  | type       | possible_keys             | key     | key_len |\n+----+-------------+--------+------------+---------------------------+---------+---------+\n|  1 | SIMPLE      | photos | index      | PRIMARY,ix_o,ix_r,ix_p,ix_l| PRIMARY | 4       |\n+----+-------------+--------+------------+---------------------------+---------+---------+\n```\nWhich index hint will improve query execution?",
        "selections": {
            "A": "USE INDEX(ix_o)",
            "B": "USE INDEX(ix_p)",
            "C": "USE INDEX(ix_r)"
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n1. **查询条件分析**：\n   - `owner_id = 44185`（高选择性，基数1,263,298）\n   - `privacy = '0'`（低选择性，基数2）\n   - `location LIKE '%home%'`（无法使用索引）\n   - `rating IN (1)`（低选择性，基数10）\n\n2. **当前执行计划问题**：\n   - 错误地使用了PRIMARY索引（type=index全索引扫描）\n   - 未利用`owner_id`的高选择性索引\n\n3. **优化方案**：\n   - `USE INDEX(ix_o)`强制使用`owner_id`索引\n   - 可过滤掉99.9%的数据（195,931,847 → ~155行）\n\n**其他选项不足：**\n- **B(ix_p)**：`privacy`基数太低（仅2个值），过滤效果差\n- **C(ix_r)**：`rating`基数较低（10个值），且IN条件效率不如等值查询\n\n**优化后执行计划预测：**\n```\n+----+-------------+--------+------+---------------+-------+---------+-------+\n| id | select_type | table  | type | possible_keys | key   | key_len | rows  |\n+----+-------------+--------+------+---------------+-------+---------+-------+\n| 1  | SIMPLE      | photos | ref  | ix_o          | ix_o  | 5       | 155   |\n+----+-------------+--------+------+---------------+-------+---------+-------+\n```",
        "suggestion": "### 优化实施建议\n1. 修改SQL语句：\n```sql\nSELECT `photos`.* \nFROM `photos` USE INDEX(ix_o)\nWHERE `owner_id` = 44185\n  AND `privacy` = '0' \n  AND `location` LIKE '%home%'\n  AND `rating` IN (1)\nORDER BY `id` DESC \nLIMIT 0, 10;\n```\n\n2. 进一步优化方案：\n   - 创建复合索引`(owner_id, privacy, rating)`\n   - 考虑使用FULLTEXT索引优化`location`的LIKE查询\n\n3. 监控工具：\n   - 使用`SHOW PROFILE`分析优化前后性能差异\n   - 监控`Handler_read%`状态变量"
    },
    {
        "question": "### 试题 19:\n\nExamine the layout of the employees table:\n```sql\nCREATE TABLE `employees` (\n `emp_no` int NOT NULL,\n `birth_date` date NOT NULL,\n `first_name` varchar(14) NOT NULL,\n `last_name` varchar(16) NOT NULL,\n `network_name` varchar(15) NOT NULL,\n `gender` enum('M','F') NOT NULL,\n `hire_date` date NOT NULL,\n PRIMARY KEY (`emp_no`),\n UNIQUE KEY `network_name` (`network_name`),\n KEY `hire_date` (`hire_date`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci\n```\nWhich column in the employees table represents the table's clustered index?",
        "selections": {
            "A": "emp_no",
            "B": "hire_date",
            "C": "gender",
            "D": "network_name"
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n1. **InnoDB引擎特性**：InnoDB的聚簇索引总是主键（PRIMARY KEY）\n2. **表结构证明**：`emp_no`是显式定义的PRIMARY KEY\n3. **物理存储顺序**：所有数据行按`emp_no`的值排序存储\n\n**其他选项分析：**\n- **B(hire_date)**：普通二级索引（KEY定义）\n- **D(network_name)**：唯一索引（UNIQUE KEY），非聚簇\n- **C(gender)**：未建立任何索引\n\n**聚簇索引关键特性：**\n1. 决定数据文件的物理排序\n2. 包含完整的行数据（非叶子节点存储索引，叶子节点存储数据）\n3. 每个InnoDB表有且只有一个聚簇索引",
        "suggestion": "### 学习建议\n1. 验证方法：\n```sql\n-- 查看索引类型\nSHOW INDEX FROM employees;\n\n-- 确认存储引擎\nSHOW TABLE STATUS LIKE 'employees';\n```\n2. 对比实验：\n   - 创建无主键表观察隐式聚簇索引\n   - 比较主键查询 vs 二级索引查询的性能差异\n3. 官方文档：\n   - [InnoDB聚簇索引](https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html)\n   - [主键最佳实践](https://dev.mysql.com/doc/refman/8.0/en/innodb-primary-key.html)"
    },
    {
        "question": "### 试题 20:\n\nExamine the appointments table definition which contains one million rows:\n```sql\nCREATE TABLE `appointments` (\n `id` int(11) NOT NULL AUTO_INCREMENT,\n `attendant_id` int(11) NOT NULL,\n `attendant_session_id` int(11) NOT NULL,\n `start` datetime NOT NULL,\n `end` datetime NOT NULL,\n `date` date NOT NULL,\n `created_by` varchar(20) NOT NULL,\n `created_at` datetime DEFAULT CURRENT_TIMESTAMP,\n `payment` int(11) NOT NULL DEFAULT '0',\n `credit` int(11) NOT NULL DEFAULT '0',\n PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\n```\nNow, examine this statement which executes successfully:\n```sql\nSELECT attendant_id, payment, credit\nFROM appointments\nWHERE attendant_session_id = 510\nAND created_by = 'jsmith'\n```\nWhich statement will improve query performance?",
        "selections": {
            "A": "ALTER TABLE appointments add index IX_1(credit,payment)",
            "B": "ALTER TABLE appointments add index IX_4(attendant_id, payment, credit)",
            "C": "ALTER TABLE appointments add index IX_3(attendant_id, created_by)",
            "D": "ALTER TABLE appointments add index IX_2(attendant_session_id, created_by)"
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n1. **查询条件匹配**：\n   - 完美覆盖WHERE子句的两个条件列（`attendant_session_id`和`created_by`）\n   - 符合最左前缀原则\n2. **执行计划优化**：\n   - 可使查询从全表扫描变为ref访问\n   - 预估扫描行数从1,000,000降至少量匹配行\n3. **索引效率**：\n   - 整型+短字符串组合索引效率高\n   - 索引大小适中（int(11)+varchar(20)）\n\n**错误选项分析：**\n- **A**：索引列与查询条件无关\n- **B**：缺少查询条件中的关键列（`created_by`）\n- **C**：`attendant_id`未出现在WHERE条件中\n\n**索引设计原则验证：**\n1. 索引应覆盖所有WHERE条件列（ESR规则：Equal-Sort-Range）\n2. 选择性高的列应放在前面（`attendant_session_id`基数高于`created_by`）\n3. 不需要包含SELECT中的列（因不满足覆盖索引条件）",
        "suggestion": "### 优化实施建议\n1. 创建索引：\n```sql\nALTER TABLE appointments \nADD INDEX IX_coverage(attendant_session_id, created_by);\n```\n2. 验证效果：\n```sql\nEXPLAIN \nSELECT attendant_id, payment, credit\nFROM appointments USE INDEX(IX_coverage)\nWHERE attendant_session_id = 510\nAND created_by = 'jsmith';\n```\n3. 高级优化：\n   - 考虑将`created_by`改为ENUM减少索引大小\n   - 定期分析表更新统计信息\n\n### 官方文档参考\n- [MySQL索引优化](https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html)\n- [EXPLAIN输出解读](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)"
    },
    {
        "question": "### 试题 21:\n\nA MySQL server has been provided self signed certificates by your corporate Certificate Authority. The server is only accessible from your private network and all name resolution is provided by a private DNS service.\nWhich two statements are true?",
        "selections": {
            "A": "Public trusted CA certificates and those signed by the corporate CA provide the same level of trust in the destination host.",
            "B": "Public trusted CA certificates are more technically secure than those signed by the corporate CA.",
            "C": "Self signed certificates provide more trust than those signed by a trusted CA.",
            "D": "Public trusted CA certificates are more trustworthy than those signed by the corporate CA.",
            "E": "Public trusted CA certificates and those signed by the corporate CA can provide the same level of technical security."
        },
        "answers": [
            "D",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D和E的原因：**\n\n1. **选项D（正确）**：\n   - 公共CA证书被全球操作系统和浏览器默认信任，具有更广泛的信任基础\n   - 企业CA证书仅在组织内部受信任，需要额外部署根证书\n   - 符合PKI信任层级规范\n\n2. **选项E（正确）**：\n   - 技术安全性取决于证书的加密算法和密钥长度\n   - 相同配置下（如RSA 2048/SHA-256），公共CA和企业CA证书的加密强度相同\n\n**错误选项分析：**\n\n- **A**：仅在严格控制的内部网络可能成立，不具普遍性\n- **B**：技术安全性与CA类型无关，取决于证书配置\n- **C**：完全错误，自签名证书信任度最低\n\n**关键区别：**\n1. 信任范围：公共CA（全球）vs 企业CA（内部）\n2. 技术实现：相同的加密算法可达到相同安全级别",
        "suggestion": "### 学习建议\n1. 理解PKI体系：\n   - 公共CA的信任链构建\n   - 企业CA的部署要求\n2. MySQL配置：\n   - 公共CA证书无需额外配置\n   - 企业CA需要指定ssl_ca参数\n3. 安全实践：\n   - 定期轮换证书\n   - 监控加密算法强度"
    },
    {
        "question": "### 试题 22:\n\nA suite of applications has been migrated to a MySQL 8 production instance. These applications must use the default authentication plugin. A legacy application yet to be migrated, does not support the default authentication plugin. Examine this statement which executed successfully:\n```sql\nCREATE USER `app`@`localhost` IDENTIFIED BY 'password';\n```\nWhich would allow the legacy application to connect while enabling other applications to adhere to the requirements?",
        "selections": {
            "A": "CREATE USER `legacyapp`@`localhost` IDENTIFIED WITH mysql_native_password BY 'password';",
            "B": "ALTER USER `app`@`localhost` IDENTIFIED WITH mysql_native_password BY 'password';",
            "C": "SET GLOBAL default_authentication_plugin=mysql_native_password;",
            "D": "SET PERSIST default_authentication_plugin=mysql_native_password;",
            "E": "CREATE USER `legacyapp`@`localhost` IDENTIFIED WITH caching_sha2_password BY 'password';"
        },
        "answers": [
            "A"
        ],
        "summary": "### 唯一正确答案解析\n\n**正确选项A的原因：**\n1. **最小化影响**：\n   - 创建独立账户`legacyapp`专供旧应用使用\n   - 完全不影响其他应用继续使用默认认证插件（caching_sha2_password）\n\n2. **精准兼容**：\n   - 显式指定`mysql_native_password`插件解决兼容性问题\n   - 符合题目\"不修改默认插件\"的核心要求\n\n3. **安全隔离**：\n   - 新旧应用账户分离，便于后续独立管理\n\n**排除其他选项的理由：**\n- **B**：修改现有`app`账户会影响已迁移应用\n- **C/D**：改变全局默认插件违反题目要求\n- **E**：使用不兼容的caching_sha2_password插件\n\n**MySQL认证插件管理规范：**\n1. 默认插件：caching_sha2_password（MySQL 8.0+强制安全标准）\n2. 混合模式：通过`IDENTIFIED WITH`实现新旧共存\n3. 用户级配置优先于全局设置",
        "suggestion": "### 生产环境实施步骤\n1. 创建专用兼容账户：\n```sql\nCREATE USER `legacy_${appname}`@`%` \n  IDENTIFIED WITH mysql_native_password \n  BY 'complex_password';\n```\n2. 权限隔离：\n```sql\nGRANT SELECT ON legacy_db.* TO `legacy_${appname}`@`%`;\n```\n3. 连接验证：\n```bash\nmysql -u legacy_${appname} -p --ssl-mode=REQUIRED\n```\n\n### 官方文档参考\n- [Authentication Plugins](https://dev.mysql.com/doc/refman/8.0/en/pluggable-authentication.html)\n- [Upgrading from MySQL 5.7](https://dev.mysql.com/doc/refman/8.0/en/upgrading-from-previous-series.html)"
    },
    {
        "question": "### 试题 23:\n\nA table has these attributes:\n1). It has more than 1 million rows.\n2). It has a `date_of_birth` column defined with the `DATETIME` data type.\n3). The `date_of_birth` column is indexed.\nWhich is the most efficient WHERE clause that returns all customers born in the year 2000?",
        "selections": {
            "A": "WHERE date_of_birth BETWEEN '2000-01-01' AND '2000-12-31'",
            "B": "WHERE date_of_birth >= '2000-01-01' AND date_of_birth < '2001-01-01'",
            "C": "WHERE YEAR(date_of_birth) = 2000",
            "D": "WHERE date_of_birth LIKE '2000%'",
            "E": "WHERE date_of_birth BETWEEN '2000-01-01' AND '2001-01-01'"
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B的原因：**\n1. **索引利用**：\n   - 使用直接列比较（不使用函数），确保索引生效\n   - 范围查询完美匹配B-Tree索引结构\n2. **边界精确**：\n   - `>= '2000-01-01'` 包含2000年第一天\n   - `< '2001-01-01'` 精确排除2001年数据\n3. **性能对比**：\n   - 比A/E选项少扫描1天的数据（E包含2001-01-01）\n   - 比C/D避免全表扫描\n\n**错误选项分析：**\n- **A**：漏掉2000-12-31 23:59:59的数据\n- **C**：`YEAR()`函数导致索引失效\n- **D**：`LIKE`操作符无法利用DATETIME索引\n- **E**：包含2001-01-01 00:00:00的非必要数据\n\n**执行计划验证：**\n```sql\nEXPLAIN \nSELECT * FROM customers \nWHERE date_of_birth >= '2000-01-01' \n  AND date_of_birth < '2001-01-01';\n-- 输出将显示使用date_of_birth索引\n```",
        "suggestion": "### 优化建议\n1. 索引使用原则：\n   - 避免对索引列使用函数（如YEAR/MONTH）\n   - 字符串匹配避免前导通配符（如LIKE '%2000'）\n2. 时间范围最佳实践：\n```sql\n-- 推荐写法（左闭右开）\nWHERE date_column >= start AND date_column < end\n```\n3. 性能测试：\n```sql\n-- 创建测试索引\nALTER TABLE customers ADD INDEX idx_dob (date_of_birth);\n\n-- 对比执行时间\nSELECT BENCHMARK(1000000, \n  (SELECT COUNT(*) FROM customers WHERE date_of_birth >= '2000-01-01' AND date_of_birth < '2001-01-01'));\n```"
    },
    {
        "question": "### 试题 24:\n\nWhich three evaluate to a temporal value?",
        "selections": {
            "A": "SYSDATE()",
            "B": "'2020-05-01' - INTERVAL 1 DAY",
            "C": "MONTH('01-05-2020')",
            "D": "'2020-05-01'",
            "E": "TO_DAYS('2020-05-01')",
            "F": "SYSDATE() - 1"
        },
        "answers": [
            "A",
            "B",
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A、B、D的原因：**\n\n1. **选项A（SYSDATE()）**：\n   - 返回当前服务器日期时间的DATETIME值\n   - 显式的时间类型输出\n\n2. **选项B（'2020-05-01' - INTERVAL 1 DAY）**：\n   - 日期运算产生新的DATE值\n   - 结果为'2020-04-30'（DATE类型）\n\n3. **选项D（'2020-05-01'）**：\n   - MySQL自动将标准日期格式字符串识别为DATE类型\n   - 在时间上下文环境中作为合法时间值\n\n**错误选项分析：**\n\n- **C**：MONTH()函数返回整数月份（1-12）\n- **E**：TO_DAYS()返回从公元0年开始的天数（整数）\n- **F**：SYSDATE()-1返回整数时间戳（需显式转换才成为时间值）\n\n**时间类型验证方法：**\n```sql\nSELECT \n  CAST(SYSDATE() AS DATE) AS A,\n  CAST('2020-05-01' - INTERVAL 1 DAY AS DATE) AS B,\n  CAST('2020-05-01' AS DATE) AS D;\n```",
        "suggestion": "### 学习建议\n1. 时间值识别特征：\n   - 可参与DATE_ADD/DATEDIFF等时间运算\n   - 能被STR_TO_DATE()函数解析\n2. 重要区别：\n   | 表达式 | 返回值类型 | 是否时间值 |\n   |--------|------------|------------|\n   | SYSDATE() | DATETIME | ✔️ |\n   | '2020-05-01' | DATE | ✔️ |\n   | MONTH() | INT | ❌ |\n3. 类型转换练习：\n```sql\nSELECT \n  CONVERT('2020-05-01', DATE),\n  CAST(20200501 AS DATE);\n```\n4. 官方文档：\n   - [Date and Time Types](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-types.html)"
    },
    {
        "question": "### 试题 25:\n\nExamine this statement which has executed successfully:\n```sql\nCREATE TABLE `film_text` (\n `film_id` smallint NOT NULL,\n `title` varchar(255) NOT NULL,\n `description` text,\n PRIMARY KEY (`film_id`),\n FULLTEXT KEY `description_idx` (`description`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n```\nfilm_text contains millions of rows.\nNow, examine this statement:\n```sql\nSELECT title\nFROM film_text\nWHERE description RLIKE \"Scientist%\";\n```\nWhich statement is true?",
        "selections": {
            "A": "The statement takes advantage of index description_idx.",
            "B": "Execution performance can be improved by using a composite index with column description as the leftmost prefix.",
            "C": "Execution performance can be improved by adding an index on column description.",
            "D": "Execution performance can be improved by using LIKE instead of RLIKE.",
            "E": "No index will improve statement performance."
        },
        "answers": [
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项E的原因：**\n1. **RLIKE限制**：\n   - RLIKE/REGEXP操作无法利用任何类型的索引（包括FULLTEXT和B-Tree）\n   - 必须执行全表扫描逐行匹配正则表达式\n\n2. **索引类型分析**：\n   - FULLTEXT索引仅适用于MATCH() AGAINST()语法\n   - 普通B-Tree索引不支持LIKE前缀通配符（\"%\"开头）\n\n3. **性能本质**：\n   - 正则表达式匹配需要完整扫描description列\n   - 任何索引都无法加速此过程\n\n**错误选项分析：**\n- **A**：FULLTEXT索引不适用于RLIKE\n- **B/C**：text列无法创建普通B-Tree索引（最大支持768字节）\n- **D**：LIKE \"Scientist%\"同样无法利用现有索引\n\n**优化替代方案：**\n```sql\n-- 使用FULLTEXT索引的正确语法\nSELECT title FROM film_text \nWHERE MATCH(description) AGAINST('+Scientist*' IN BOOLEAN MODE);\n\n-- 使用前缀索引（需截断text列）\nALTER TABLE film_text \nADD INDEX desc_prefix_idx (description(255));\n```",
        "suggestion": "### 学习建议\n1. 正则查询优化：\n   - 考虑使用应用层预处理（如提取关键词到新列）\n   - 对固定模式使用STORED GENERATED COLUMN\n2. 索引限制测试：\n```sql\n-- 测试不同查询模式的索引使用情况\nEXPLAIN SELECT title FROM film_text WHERE description LIKE 'Scientist%';\nEXPLAIN SELECT title FROM film_text WHERE description RLIKE '^Scientist';\n```\n3. 官方文档：\n   - [FULLTEXT限制](https://dev.mysql.com/doc/refman/8.0/en/fulltext-restrictions.html)\n   - [正则表达式性能](https://dev.mysql.com/doc/refman/8.0/en/regexp.html#regexp-performance)"
    },
    {
        "question": "### 试题 26:\n\nExamine this statement which executes successfully:\n```sql\nDELIMITER //\nCREATE PROCEDURE test_cursor(OUT city_name VARCHAR(100))\nBEGIN\n DECLARE count INT DEFAULT 0;\n DECLARE cur CURSOR FOR SELECT name FROM city;\n DECLARE EXIT HANDLER FOR NOT FOUND SELECT count;\n OPEN cur;\n LOOP\n FETCH cur INTO city_name;\n SET count = count+1;\n END LOOP;\nEND //\nDELIMITER ;\n```\nYou execute this statement:\n```sql\nCALL test_cursor(@city);\n```\nWhich two are true about the execution?",
        "selections": {
            "A": "The procedure displays the number of rows in the city table.",
            "B": "The memory allocated to the cursor is not released.",
            "C": "The loop runs infinitely.",
            "D": "@city contains the last city name fetched from the cursor.",
            "E": "The procedure exits if the city table is not found."
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A和D的原因：**\n\n1. **选项A（正确）**：\n   - 当游标遍历完所有数据时，NOT FOUND处理器会触发\n   - `SELECT count`语句显示city表的行数\n\n2. **选项D（正确）**：\n   - 每次FETCH都会覆盖`city_name`输出参数\n   - 最终保留最后一条记录的值\n\n**错误选项分析：**\n\n- **B**：存储过程结束时游标会自动关闭（MySQL文档明确说明）\n- **C**：EXIT HANDLER会正常终止循环\n- **E**：\"table not found\"属于不同错误类型（需SQLSTATE 42S02）\n\n**执行流程验证：**\n1. 游标打开后遍历所有行\n2. 每次FETCH：\n   - 成功：count递增，city_name被更新\n   - 失败：触发NOT FOUND处理器\n3. 处理器执行后退出存储过程\n\n**内存管理说明：**\n```sql\n-- 可显式关闭游标（但非必需）\nDECLARE CONTINUE HANDLER FOR NOT FOUND BEGIN\n CLOSE cur;\n SELECT count;\nEND;",
        "suggestion": "### 学习建议\n1. 游标最佳实践：\n```sql\nCREATE PROCEDURE improved_cursor(OUT result VARCHAR(100))\nBEGIN\n DECLARE done INT DEFAULT FALSE;\n DECLARE cur CURSOR FOR SELECT name FROM city;\n DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n \n OPEN cur;\n read_loop: LOOP\n FETCH cur INTO result;\n IF done THEN\n LEAVE read_loop;\n END IF;\n -- 处理逻辑\n END LOOP;\n CLOSE cur; -- 显式关闭\nEND\n```\n2. 错误处理测试：\n   - 模拟空表场景观察NOT FOUND行为\n   - 测试无效表名查看不同错误类型\n3. 官方文档：\n   - [游标处理](https://dev.mysql.com/doc/refman/8.0/en/cursors.html)\n   - [处理器语法](https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html)"
    },
    {
        "question": "### 试题 27:\n\nWhich two of these benefit from having a connection pool?",
        "selections": {
            "A": "where authentication information needs to be cached over a long period of time",
            "B": "websites that require a high number of short-lived connections to the MySQL server",
            "C": "middleware modules that maintain multiple connections to multiple MySQL servers and require connection to be readily available",
            "D": "applications running long complex transactions",
            "E": "software services with multiple processes using one network interface to a variety of servers"
        },
        "answers": [
            "B",
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B和C的原因：**\n\n1. **选项B（正确）**：\n   - 连接池主要解决频繁建立/断开连接的开销问题\n   - 高并发短连接场景（如Web应用）是典型使用场景\n   - 可减少TCP三次握手和MySQL连接认证开销\n\n2. **选项C（正确）**：\n   - 中间件需要管理多服务器连接\n   - 连接池保持热连接随时可用，避免延迟\n   - 特别适合微服务架构\n\n**错误选项分析：**\n\n- **A**：认证缓存与连接池无关（由认证系统实现）\n- **D**：长事务占用连接会降低连接池利用率\n- **E**：多进程共享网络接口与连接池无直接关系\n\n**连接池核心价值：**\n1. 连接复用：避免重复建立连接的开销\n2. 流量控制：限制最大连接数保护数据库\n3. 健康检查：自动剔除失效连接\n\n**性能对比数据：**\n| 场景 | 无连接池 | 有连接池 |\n|------|----------|----------|\n| 1000次短查询 | ~3000ms | ~500ms |\n| 连接建立耗时 | 50-100ms/次 | 0ms（复用） |",
        "suggestion": "### 实施建议\n1. 主流连接池配置：\n```java\n// HikariCP示例\nHikariConfig config = new HikariConfig();\nconfig.setMaximumPoolSize(20);\nconfig.setConnectionTimeout(30000);\n\n// MySQL连接参数\nconfig.setJdbcUrl(\"jdbc:mysql://host/db\");\nconfig.setUsername(\"user\");\nconfig.setPassword(\"pass\");\n```\n2. 监控指标：\n   - 活跃连接数\n   - 等待获取连接的线程数\n   - 连接平均存活时间\n3. 官方推荐：\n   - [MySQL Connector/J连接池](https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-usagenotes-j2ee-concepts-connection-pooling.html)\n   - [连接池比较](https://github.com/brettwooldridge/HikariCP/wiki/Pool-Comparison)"
    },
    {
        "question": "### 试题 28:\n\nExamine these statements executed successfully in one session:\n```sql\nsession 1> START TRANSACTION;\nsession 1> UPDATE world.city SET Population=3643581\n WHERE Name='Roma' AND CountryCode='ITA';\n```\nNow, examine this statement and output from a second session:\n```sql\nsession 2> SELECT INDEX_NAME, LOCK_TYPE, LOCK_MODE, COUNT(*)\n FROM performance_schema.data_locks\n WHERE OBJECT_SCHEMA='world'\n AND OBJECT_NAME='city'\n GROUP BY INDEX_NAME, LOCK_TYPE, LOCK_MODE;\n+-----------------+------------+--------------+----------+\n| INDEX_NAME      | LOCK_TYPE  | LOCK_MODE    | COUNT(*) |\n+-----------------+------------+--------------+----------+\n| NULL            | TABLE      | IX           |        1 |\n| CountryCode     | RECORD     | X,REC_NOT_GAP|        1 |\n| PRIMARY         | RECORD     | X,REC_NOT_GAP|        1 |\n+-----------------+------------+--------------+----------+\n```\nThere is no index on column `Name` but there is one on column `CountryCode`.\nWhat are the possible values for transaction_isolation given the output in Session 1?",
        "selections": {
            "A": "REPEATABLE-READ or SERIALIZABLE",
            "B": "REPEATABLE-READ or READ-UNCOMMITTED",
            "C": "READ-COMMITTED or READ-UNCOMMITTED",
            "D": "READ-COMMITTED or SERIALIZABLE"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n1. **锁模式关键证据**：\n   - `X,REC_NOT_GAP`锁明确排除了间隙锁的存在\n   - 这与READ-COMMITTED隔离级别的锁特性完全匹配\n\n2. **排除法分析**：\n   - READ-UNCOMMITTED理论上不获取行锁（但实际可能显示为弱锁）\n   - REPEATABLE-READ/SERIALIZABLE会产生间隙锁（未观察到）\n\n3. **索引验证**：\n   - 仅CountryCode索引和主键被锁定\n   - 符合READ-COMMITTED的精确锁定策略\n\n**技术深度说明：**\n1. `REC_NOT_GAP`在READ-COMMITTED下的表现：\n   - 仅锁定现有记录\n   - 允许其他事务插入间隙数据\n2. 虽然READ-UNCOMMITTED理论上不应用锁，但某些实现可能显示为弱锁\n\n**错误选项排除依据：**\n- A/B/D：都包含会产生间隙锁的隔离级别\n- READ-UNCOMMITTED作为理论边界情况保留",
        "suggestion": "### 验证实验\n1. 复现锁场景：\n```sql\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED;\nBEGIN;\nUPDATE city SET Population=100 WHERE CountryCode='ITA';\n-- 另开会话观察data_locks\n```\n2. 对比测试：\n```sql\nSET TRANSACTION ISOLATION LEVEL REPEATABLE READ;\nBEGIN;\nUPDATE city SET Population=100 WHERE CountryCode='ITA';\n-- 观察间隙锁出现\n```\n3. 官方文档重点：\n   - [InnoDB锁模式](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)\n   - [隔离级别差异](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)"
    },
    {
        "question": "### 试题 29:\n\nExamine these statements which execute successfully:\n```sql\nsession 1> START TRANSACTION;\nsession 1> SELECT * FROM test.t;\n```\nNow, examine this statement executed in the second session.\n```sql\nsession 2> OPTIMIZE TABLE test.t;\n```\nWhat is true about the execution of the OPTIMIZE TABLE statement?",
        "selections": {
            "A": "The statement in Session 2 will wait for a table metadata lock to be granted.",
            "B": "The statement in Session 2 is not blocked by Session 1.",
            "C": "The statement in Session 2 will return an error.",
            "D": "The transaction in Session 1 will be ROLLED BACK."
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n1. **元数据锁机制**：\n   - SELECT语句会获取共享元数据锁（MDL）\n   - OPTIMIZE TABLE需要排他元数据锁\n   - 排他锁需等待所有共享锁释放\n\n2. **阻塞验证**：\n   - 可通过`SHOW PROCESSLIST`查看`Waiting for table metadata lock`状态\n   - 直到Session 1提交或回滚才会继续\n\n**错误选项分析：**\n- **B**：OPTIMIZE TABLE会被活跃事务阻塞\n- **C**：不会报错，只会等待\n- **D**：只读事务不会因DDL操作回滚\n\n**元数据锁关键特性：**\n1. 锁获取顺序：\n   - 读操作：获取SHARED_READ锁\n   - DDL操作：需获取EXCLUSIVE锁\n2. 锁冲突矩阵：\n   | 已持有锁类型 | 请求EXCLUSIVE锁 |\n   |--------------|-----------------|\n   | SHARED_READ  | 等待            |",
        "suggestion": "### 问题排查方法\n1. 监控元数据锁：\n```sql\nSELECT * FROM performance_schema.metadata_locks \nWHERE OBJECT_SCHEMA='test' AND OBJECT_NAME='t';\n```\n2. 避免长时间事务：\n   - 设置`lock_wait_timeout`参数\n3. 替代方案：\n```sql\n-- 使用pt-online-schema-change工具\n-- 或在低峰期执行OPTIMIZE\n```\n4. 官方文档：\n   - [元数据锁说明](https://dev.mysql.com/doc/refman/8.0/en/metadata-locking.html)\n   - [OPTIMIZE TABLE行为](https://dev.mysql.com/doc/refman/8.0/en/optimize-table.html)"
    },
    {
        "question": "### 试题 30:\n\nYou require a MySQL connector to ease migration of a PHP application from other Relational Database Management Systems with minimal code change.\nWhich connector will do this?",
        "selections": {
            "A": "PDO connector",
            "B": "mysql1 connector",
            "C": "mysql1 connector with XDev API",
            "D": "mysql connector"
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A（PDO connector）的原因：**\n1. **数据库抽象层特性**：\n   - PDO（PHP Data Objects）是PHP官方推荐的数据库抽象层\n   - 支持统一API操作多种数据库（MySQL/PostgreSQL/Oracle等）:cite[1]:cite[3]\n\n2. **迁移优势**：\n   - 只需修改DSN（数据源名称）即可切换数据库类型\n   - 相同的方法（如query()/execute()）跨数据库通用:cite[3]\n\n3. **生产环境验证**：\n   - 企业级应用广泛使用PDO实现多数据库支持\n   - 符合PSR标准，长期维护保障:cite[1]\n\n**其他选项分析：**\n- **B/C**：mysql1是虚构名称（实际应为mysql/mysqli）\n- **D**：原生mysql扩展已弃用且不支持多数据库\n\n**代码示例对比：**\n```php\n// PDO跨数据库示例\n$db = new PDO('mysql:host=localhost;dbname=test', 'user', 'pass'); \n// 仅需修改DSN即可切换为PostgreSQL\n// $db = new PDO('pgsql:host=localhost;dbname=test', 'user', 'pass');\n\n// 原生mysql扩展（已淘汰）\n$conn = mysql_connect('localhost', 'user', 'pass'); // 仅限MySQL\n```",
        "suggestion": "### 实施建议\n1. **迁移步骤**：\n   - 替换所有数据库调用为PDO接口\n   - 使用预处理语句防止SQL注入\n   - 封装通用数据库操作类\n\n2. **兼容性处理**：\n```php\nclass Database {\n    private $pdo;\n    \n    public function __construct($type, $host, $db, $user, $pass) {\n        $dsn = \"{$type}:host={$host};dbname={$db}\";\n        $this->pdo = new PDO($dsn, $user, $pass);\n    }\n    \n    public function query($sql, $params = []) {\n        $stmt = $this->pdo->prepare($sql);\n        $stmt->execute($params);\n        return $stmt;\n    }\n}\n```\n3. **官方文档**：\n   - [PHP PDO手册](https://www.php.net/manual/en/book.pdo.php)\n   - [数据库迁移最佳实践](https://www.php.net/manual/en/pdo.drivers.php)"
    },
    {
        "question": "### 试题 31:\n\nYou created a custom theme for an application.\n\nExamine these requirements:\n\n1). The theme must be utilized by another application in the same workspace.\n\n2). The master theme may still require changes.\n\nWhich solution guarantees that any changes to the master theme are reflected in the copied theme?",
        "selections": {
            "A": "Subscribing the copied theme to the master theme and refreshing the theme",
            "B": "Refreshing the templates",
            "C": "Verifying the theme subscription",
            "D": "Copying the changes made in the master theme to the copied theme"
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **订阅机制**：\n\n   - 通过订阅(subscribing)建立主主题和复制主题之间的动态链接\n\n   - 确保主主题的修改能自动传播到所有订阅主题\n\n2. **刷新操作**：\n\n   - 刷新(refreshing)是应用变更的必要步骤\n\n   - 使修改在实际使用中生效\n\n3. **满足需求**：\n\n   - 完美符合\"跨应用共享\"和\"主主题可能变更\"两个核心要求\n\n\n\n**错误选项分析**：\n\n- **B**：模板刷新不处理主题继承关系\n\n- **C**：仅验证订阅状态不执行实际同步\n\n- **D**：手动复制无法保证实时同步且容易遗漏",
        "suggestion": "### 最佳实践建议\n\n1. **版本控制**：\n\n   - 主主题修改后增加版本号标记\n\n2. **变更通知**：\n\n   - 建立工作空间通知机制\n\n   - 主主题修改后提醒订阅方刷新\n\n3. **测试流程**：\n\n   - 先在开发环境验证主题变更\n\n   - 确认无误后再部署到生产环境"
    },
    {
        "question": "### 试题 32:\n\nYou are using mysqli in a PHP script.\n\nWhich value may appear in connect_errno after attempting a connection?",
        "selections": {
            "A": "a zero on success",
            "B": "the time the last error occurred",
            "C": "the number of connection errors for the session",
            "D": "a connection number for the session"
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **connect_errno属性**：\n\n   - mysqli连接对象的属性\n\n   - 连接成功时返回0\n\n   - 连接失败时返回错误代码\n\n2. **官方文档说明**：\n\n   - 根据PHP官方文档，成功连接时connect_errno为0\n\n   - 错误时返回MySQL错误编号\n\n3. **实际验证**：\n\n```php\n$mysqli = new mysqli('localhost', 'user', 'password', 'database');\necho $mysqli->connect_errno; // 成功时输出0\n```\n\n\n\n**错误选项分析**：\n\n- **B**：时间信息存储在connect_error属性\n\n- **C**：不统计会话错误次数\n\n- **D**：连接编号存储在thread_id属性",
        "suggestion": "### 开发建议\n\n1. **连接检查**：\n\n```php\nif ($mysqli->connect_errno) {\n    die(\"连接失败: \".$mysqli->connect_error);\n}\n```\n\n2. **错误代码参考**：\n\n   - 常见错误代码：\n\n     - 1045: 访问被拒绝\n\n     - 2002: 连接超时\n\n3. **调试技巧**：\n\n   - 开发环境开启错误报告\n\n   - 记录连接错误日志"
    },
    {
        "question": "### 试题 33:\n\nExamine this sequence of statements issued by two concurrent sessions within three seconds of each other:\n\n```sql\nSession 1> SELECT GET_LOCK('mylock1',70);\nSession 2> SELECT GET_LOCK('mylock2',70);\nSession 2> SELECT GET_LOCK('mylock1',70);\nSession 1> SELECT GET_LOCK('mylock2',70);\n```\n\nWhat will happen in Session 1 after the last statement is executed?",
        "selections": {
            "A": "The lock will be immediately granted.",
            "B": "A timeout will be returned after the wait_timeout interval has expired.",
            "C": "An error will be returned after 70 seconds.",
            "D": "A deadlock error is returned."
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **死锁场景分析**：\n   - ```Session 1```持有`mylock1`，请求`mylock2`\n   - ```Session 2```持有`mylock2`，请求`mylock1`\n   - 形成典型的循环等待死锁\n\n2. **MySQL处理机制**：\n   - 检测到死锁会立即返回错误(ER_LOCK_DEADLOCK)\n   - 错误代码：1213\n   - 不需要等待超时(70秒)\n\n**错误选项分析**：\n- `A`：不可能立即获得，因为被```Session 2```持有\n- `B`：不会等到wait_timeout，死锁优先处理\n- `C`：不会等待完整70秒，死锁会立即中断\n\n**验证方法**：\n```sql\n-- 在MySQL中执行以下命令查看死锁信息\nSHOW ENGINE INNODB STATUS\\G\n```",
        "suggestion": "### 开发建议\n\n1. **避免死锁的最佳实践**：\n   - 按照固定顺序获取多个锁\n   - 设置合理的锁超时时间\n\n2. **错误处理示例**：\n```php\ntry {\n    $lock1 = $mysqli->query(\"SELECT GET_LOCK('mylock1',10)\");\n    $lock2 = $mysqli->query(\"SELECT GET_LOCK('mylock2',10)\");\n} catch (mysqli_sql_exception $e) {\n    if ($e->getCode() == 1213) {\n        // 处理死锁情况\n    }\n}\n```\n\n3. **监控建议**：\n   - 启用`innodb_print_all_deadlocks`记录所有死锁\n   - 定期检查MySQL错误日志"
    },
    {
        "question": "### 试题 34:\n\nWhich command displays timing information for a query?",
        "selections": {
            "A": "EXPLAIN",
            "B": "EXPLAIN FORMAT=TREE",
            "C": "EXPLAIN FORMAT=JSON",
            "D": "EXPLAIN ANALYZE"
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **EXPLAIN ANALYZE特性**：\n   - 是唯一会实际执行查询并显示执行时间的EXPLAIN变体\n   - 提供详细的执行统计信息（实际耗时、返回行数等）\n\n2. **与其他选项对比**：\n   ```sql\n   -- 常规EXPLAIN（选项A/B/C）只显示执行计划\n   -- EXPLAIN ANALYZE（选项D）额外显示:\n   --   - Actual time\n   --   - Rows\n   --   - Loops\n   ```\n\n3. **实际输出示例**：\n```sql\nEXPLAIN ANALYZE SELECT * FROM large_table;\n-- 输出包含：\n-- Planning Time: 0.1 ms\n-- Execution Time: 125.3 ms\n```\n\n**错误选项分析**：\n- `A`/`B`/`C`：仅显示预估执行计划，不含实际耗时数据",
        "suggestion": "### 性能优化建议\n\n1. **使用场景建议**：\n   - 开发环境：用`EXPLAIN ANALYZE`定位性能瓶颈\n   - 生产环境：谨慎使用（会实际执行查询）\n\n2. **典型分析流程**：\n```sql\n-- 1. 先用常规EXPLAIN查看执行计划\nEXPLAIN SELECT * FROM orders WHERE user_id=100;\n\n-- 2. 确认无风险后使用ANALYZE获取实际数据\nEXPLAIN ANALYZE SELECT * FROM orders WHERE user_id=100;\n```\n\n3. **高级技巧**：\n   - 结合`BUFFERS`选项分析内存使用：\n```sql\nEXPLAIN (ANALYZE, BUFFERS) SELECT * FROM large_table;\n```"
    },
    {
        "question": "### 试题 35:\n\nExamine this statement which executes successfully:\n\n```sql\nmysql> SET GLOBAL sql_mode = ANSI_QUOTES;\n```\n\nWhich sessions utilize the ANSI_QUOTES SQL mode?",
        "selections": {
            "A": "all existing sessions at the next transaction",
            "B": "all existing sessions",
            "C": "new sessions only",
            "D": "existing sessions that execute FLUSH TABLES",
            "E": "new sessions and the current session"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **GLOBAL变量特性**：\n   - `SET GLOBAL`只影响之后新建的会话\n   - 当前已存在的会话保持原配置\n\n2. **验证方法**：\n```sql\n-- 会话1（已存在）\nSELECT @@SESSION.sql_mode; -- 不包含ANSI_QUOTES\n\n-- 管理员执行\nSET GLOBAL sql_mode = 'ANSI_QUOTES';\n\n-- 新会话2\nSELECT @@SESSION.sql_mode; -- 包含ANSI_QUOTES\n```\n\n3. **官方文档说明**：\n   - GLOBAL系统变量变更不会影响已连接的会话\n   - 需要重新连接才能生效\n\n**错误选项分析**：\n- `A`/`B`：GLOBAL变更不会影响现有会话\n- `D`：FLUSH TABLES不影响sql_mode\n- `E`：当前会话需显式执行`SET SESSION`才会生效",
        "suggestion": "### 配置管理建议\n\n1. **配置生效范围**：\n   ```sql\n   -- 影响所有会话（需重启服务）\n   SET GLOBAL sql_mode = 'ANSI_QUOTES';\n   \n   -- 立即影响当前会话\n   SET SESSION sql_mode = 'ANSI_QUOTES';\n   ```\n\n2. **持久化配置**：\n   - 修改`my.cnf`配置文件：\n   ```ini\n   [mysqld]\n   sql_mode=ANSI_QUOTES\n   ```\n\n3. **最佳实践**：\n   - 重要变更先在测试环境验证\n   - 使用`SELECT @@GLOBAL.sql_mode`确认全局设置\n   - 应用连接池配置重启策略"
    },
    {
        "question": "### 试题 36:\n\nWhich statement is true?",
        "selections": {
            "A": "SHOW COUNT(*) WARNINGS and SELECT @@warning_count display the same result",
            "B": "SHOW WARNINGS displays the same result as an EXPLAIN command",
            "C": "SHOW WARNINGS displays warnings from DDL statements only",
            "D": "SHOW COUNT(*) WARNINGS displays the number of warnings only",
            "E": "SHOW WARNINGS displays errors, warnings, and notes"
        },
        "answers": [
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项E的原因：**\n\n1. **SHOW WARNINGS功能**：\n   - 显示上一条语句产生的所有消息\n   - 包括：Errors（错误）、Warnings（警告）、Notes（提示）\n\n2. **验证示例**：\n```sql\n-- 产生不同类型的消息\nSELECT 1/0; -- 产生warning\nSELECT 'a'+1; -- 产生warning\n/*!50001 CREATE VIEW */ -- 产生note\n\nSHOW WARNINGS; -- 显示所有上述消息\n```\n\n3. **官方文档说明**：\n   - `SHOW WARNINGS`显示错误、警告、提示\n   - 最大显示数量受`max_error_count`限制\n\n**错误选项分析**：\n- `A`：`SHOW COUNT(*) WARNINGS`返回行数，`@@warning_count`返回数值\n- `B`：EXPLAIN显示执行计划，与警告无关\n- `C`：适用于所有语句类型，不限于DDL\n- `D`：显示的是消息总数（含errors/notes）",
        "suggestion": "### 开发调试建议\n\n1. **消息级别控制**：\n```sql\n-- 只显示错误\nSHOW ERRORS;\n\n-- 显示全部消息\nSHOW WARNINGS\\G\n```\n\n2. **消息数量限制**：\n```sql\n-- 查看/设置最大保留消息数\nSELECT @@max_error_count;\nSET SESSION max_error_count = 1000;\n```\n\n3. **自动化处理**：\n```php\n// PHP示例代码\n$warnings = $mysqli->query('SHOW WARNINGS')->fetch_all();\nif (count($warnings) > 0 {\n    // 处理警告信息\n}\n```"
    },
    {
        "question": "### 试题 37:\n\nWhich two commands display information to troubleshoot a SQL statement that does not execute as expected?",
        "selections": {
            "A": "SELECT * FROM INFORMATION_SCHEMA.EVENTS;",
            "B": "GET DIAGNOSTICS CONDITION 1 @p1 = RETURNED_SOLSTATE, @p2 = MESSAGE_TEXT;",
            "C": "SHOW WARNINGS;",
            "D": "SELECT * FROM sys.user_summary;",
            "E": "SHOW MASTER STATUS;"
        },
        "answers": [
            "B",
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B和C的原因：**\n\n1. **GET DIAGNOSTICS (选项B)**：\n   - 提供详细的SQL执行状态信息\n   - 可以获取错误代码和错误消息\n   - 示例用法：\n```sql\n-- 执行问题SQL后\nGET DIAGNOSTICS CONDITION 1\n  @errno = MYSQL_ERRNO,\n  @msg = MESSAGE_TEXT;\n```\n\n2. **SHOW WARNINGS (选项C)**：\n   - 显示SQL执行产生的所有警告和错误\n   - 包含详细的错误位置和原因\n   - 示例输出：\n```\nLevel | Code | Message\n------|------|--------\nWarning | 1366 | Incorrect integer value\n```\n\n**错误选项分析**：\n- `A`：显示事件信息，与SQL调试无关\n- `D`：显示用户摘要统计信息\n- `E`：显示主从复制状态信息\n\n**实用调试技巧**：\n```sql\n-- 组合使用B和C选项\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n    GET DIAGNOSTICS CONDITION 1\n      @sqlstate = RETURNED_SQLSTATE,\n      @errno = MYSQL_ERRNO,\n      @text = MESSAGE_TEXT;\n    SELECT @errno, @text;\n  END;\n  \n  -- 执行问题SQL\n  SELECT * FROM invalid_table;\n  \n  -- 显示所有警告\n  SHOW WARNINGS;\nEND;```",
        "suggestion": "### SQL调试最佳实践\n\n1. **错误处理流程**：\n   - 先使用`SHOW WARNINGS`快速查看问题\n   - 再用`GET DIAGNOSTICS`获取详细信息\n\n2. **日志记录建议**：\n```sql\n-- 创建错误日志表\nCREATE TABLE IF NOT EXISTS sql_error_log (\n  id INT AUTO_INCREMENT PRIMARY KEY,\n  errno INT,\n  sqlstate VARCHAR(5),\n  message TEXT,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- 存储错误信息\nINSERT INTO sql_error_log (errno, sqlstate, message)\nSELECT MYSQL_ERRNO, RETURNED_SQLSTATE, MESSAGE_TEXT\nFROM (GET DIAGNOSTICS CONDITION 1);\n```\n\n3. **开发环境配置**：\n   - 设置`sql_mode=STRICT_ALL_TABLES`暴露更多潜在问题\n   - 启用`log_warnings=2`记录警告日志"
    },
    {
        "question": "### 试题 38:\n\nYou must suppress warning messages but display error messages.\n\nWhich command will do this?",
        "selections": {
            "A": "SET SQL_WARNINGS=1;",
            "B": "SET @SQL_WARNINGS=0;",
            "C": "SET @SQL_WARNINGS=1;",
            "D": "SET @SQL_WARNINGS=3;",
            "E": "SET SQL_WARNINGS=3;",
            "F": "SET SQL_WARNINGS=0;"
        },
        "answers": [
            "F"
        ],
        "summary": "### 正确答案解析\n\n**正确选项F的原因：**\n\n1. **SQL_WARNINGS系统变量**：\n   - 控制警告消息的显示行为\n   - `SET SQL_WARNINGS=0`：抑制警告消息（但错误仍会显示）\n   - `SET SQL_WARNINGS=1`：显示警告和错误（默认值）\n\n2. **验证方法**：\n```sql\n-- 启用警告显示（默认）\nSET SQL_WARNINGS=1;\nSELECT 'abc'+1; -- 显示警告\n\n-- 抑制警告\nSET SQL_WARNINGS=0;\nSELECT 'abc'+1; -- 不显示警告\n\n-- 故意制造错误（仍会显示）\nSELECT * FROM non_existent_table; -- 错误仍会显示\n```\n\n3. **与其他选项区别**：\n   - 带`@`的是用户变量，不是系统变量\n   - `SQL_WARNINGS`只能是0或1，没有3这个取值\n\n**错误选项分析**：\n- `A`：会显示警告（与需求相反）\n- `B`/`C`/`D`：修改的是用户变量，不影响系统行为\n- `E`：无效值（只能是0或1）",
        "suggestion": "### 开发建议\n\n1. **临时屏蔽警告**：\n```sql\n-- 当前会话屏蔽警告\nSET @old_warnings = @@SESSION.SQL_WARNINGS;\nSET SESSION SQL_WARNINGS=0;\n\n-- 执行可能产生警告的操作\nSELECT 1/0; -- 不显示警告\n\n-- 恢复原设置\nSET SESSION SQL_WARNINGS=@old_warnings;\n```\n\n2. **永久配置**：\n   - 在my.cnf中添加：\n   ```ini\n   [mysql]\n   SQL_WARNINGS=0\n   ```\n\n3. **替代方案**：\n   - 使用`IGNORE`关键字忽略特定警告：\n```sql\nINSERT IGNORE INTO table VALUES (...);\n```"
    },
    {
        "question": "### 试题 39:\n\nYou must add a column to the exam table to track the number of times a candidate has taken any exam. You must use the data type with the most efficient storage for the value. The maximum number of retakes per exam is 10.\n\nWhich data type do you choose?",
        "selections": {
            "A": "SMALLINT",
            "B": "TINYINT",
            "C": "INT",
            "D": "BIGINT",
            "E": "MEDIUMINT"
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B的原因：**\n\n1. **存储需求分析**：\n   - 最大重考次数=10\n   - `TINYINT`范围：-128~127（完全满足需求）\n   - 存储空间：仅1字节（最节省）\n\n2. **与其他类型对比**：\n```sql\n-- 各整数类型存储空间\nTINYINT    : 1 byte  (最大值127)\nSMALLINT   : 2 bytes (最大值32767)\nMEDIUMINT  : 3 bytes (最大值8388607)\nINT        : 4 bytes (最大值2147483647)\nBIGINT     : 8 bytes (最大值9223372036854775807)\n```\n\n3. **无符号优化**：\n   - 如果确认不会有负值，可用`TINYINT UNSIGNED`（范围0~255）\n   - 仍保持1字节存储\n\n**错误选项分析**：\n- `A`/`C`/`D`/`E`：存储空间过大，不符合\"most efficient storage\"要求",
        "suggestion": "### 数据库设计建议\n\n1. **最优数据类型选择**：\n```sql\nALTER TABLE exam \nADD COLUMN retake_count TINYINT UNSIGNED DEFAULT 0 \nCOMMENT '考试重试次数（0-10）';\n```\n\n2. **数据完整性保护**：\n```sql\n-- 添加检查约束（MySQL 8.0+）\nALTER TABLE exam \nADD CONSTRAINT chk_retake_count \nCHECK (retake_count BETWEEN 0 AND 10);\n```\n\n3. **性能考量**：\n   - 1字节字段对索引性能最优\n   - 适合作为复合索引的前导列\n\n4. **扩展性考虑**：\n   - 如果未来可能超过10次，可提前使用`SMALLINT`\n   - 平衡存储效率与未来需求"
    },
    {
        "question": "### 试题 40:\n\nExamine these statements which execute successfully:\n\n```sql\nCREATE TABLE table1 (var1 TINYINT, var2 INT);\nSET sql_mode=STRICT_ALL_TABLES;\n```\n\nNow, examine this statement:\n\n```sql\nINSERT INTO table1 (var1) VALUES(1000);\n```\n\nWhich is true about the execution of the INSERT statement?",
        "selections": {
            "A": "It inserts the value 127.",
            "B": "It fails with an error.",
            "C": "It inserts the value 1000.",
            "D": "It inserts the row with a warning.",
            "E": "It inserts a valid value nearest to 1000."
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B的原因：**\n\n1. **严格模式(STRICT_ALL_TABLES)的作用**：\n   - 在严格模式下，超出范围的值会导致错误而非截断\n   - `TINYINT`范围：-128 ~ 127\n   - 值1000明显超出范围\n\n2. **错误验证**：\n```sql\n-- 执行结果示例\nERROR 1264 (22003): Out of range value for column 'var1' at row 1\n```\n\n3. **与非严格模式对比**：\n   - 非严格模式会：\n     - 插入127（有符号TINYINT最大值）\n     - 产生警告\n   - 严格模式直接报错\n\n**错误选项分析**：\n- `A`：是非严格模式的行为\n- `C`：不可能插入超出范围的值\n- `D`：严格模式下不会仅警告\n- `E`：严格模式不允许隐式截断",
        "suggestion": "### 开发建议\n\n1. **严格模式最佳实践**：\n```sql\n-- 推荐生产环境设置\nSET sql_mode='STRICT_ALL_TABLES,NO_ENGINE_SUBSTITUTION';\n```\n\n2. **安全插入数据的方法**：\n```sql\n-- 方法1：先验证范围\nINSERT INTO table1 (var1) \nSELECT LEAST(1000, 127);\n\n-- 方法2：使用预处理语句\nPREPARE stmt FROM 'INSERT INTO table1 (var1) VALUES(?)';\nSET @val = 1000;\nEXECUTE stmt USING @val; -- 同样会报错\n```\n\n3. **错误处理**：\n```php\n// PHP示例错误处理\ntry {\n    $pdo->exec(\"INSERT INTO table1 (var1) VALUES(1000)\");\n} catch (PDOException $e) {\n    if ($e->errorInfo[1] == 1264) {\n        // 处理超出范围错误\n    }\n}\n```"
    },
    {
        "question": "### 试题 41:\n\nWhich two statements are true about aggregate functions?",
        "selections": {
            "A": "COUNT (DISTINCT) returns a count of the number of rows with different values including NULL.",
            "B": "SUM() returns 0 if there are no rows to aggregate.",
            "C": "MAX() returns NULL if there are no rows to aggregate.",
            "D": "AVG() does not allow use of the DISTINCT option.",
            "E": "MIN() cannot use DISTINCT when it executes as a Windows function."
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C和E的原因：**\n\n1. **MAX()行为（选项C）**：\n   - 当没有聚合行时返回NULL\n   - 验证示例：\n```sql\nSELECT MAX(salary) FROM employees WHERE 1=0; -- 返回NULL\n```\n\n2. **窗口函数限制（选项E）**：\n   - 窗口函数中的MIN()不支持DISTINCT\n   - 示例错误：\n```sql\n-- 会报语法错误\nSELECT MIN(DISTINCT salary) OVER() FROM employees;\n```\n\n**错误选项分析**：\n- `A`：COUNT(DISTINCT)不包含NULL值\n- `B`：SUM()在无行时返回NULL（不是0）\n- `D`：AVG()支持DISTINCT选项\n\n**聚合函数特性总结**：\n```sql\n-- 无数据时的返回值\nSELECT \n  COUNT(*) AS cnt,       -- 0\n  SUM(col) AS sum_val,   -- NULL\n  AVG(col) AS avg_val,   -- NULL\n  MAX(col) AS max_val,   -- NULL\n  MIN(col) AS min_val    -- NULL\nFROM table WHERE 1=0;\n```",
        "suggestion": "### 开发建议\n\n1. **处理NULL结果**：\n```sql\n-- 使用IFNULL或COALESCE处理聚合结果\nSELECT \n  COALESCE(MAX(salary), 0) AS max_sal\nFROM employees\nWHERE department = 'nonexistent';\n```\n\n2. **窗口函数替代方案**：\n```sql\n-- 实现DISTINCT效果的窗口计算\nWITH distinct_salaries AS (\n  SELECT DISTINCT salary FROM employees\n)\nSELECT \n  MIN(salary) OVER() AS min_distinct_sal\nFROM distinct_salaries;\n```\n\n3. **性能注意事项**：\n   - COUNT(DISTINCT)在大数据集上性能较差\n   - 考虑使用近似计数：\n```sql\nSELECT COUNT_APPROX_DISTINCT(user_id) FROM large_table;\n```"
    },
    {
        "question": "### 试题 42:\n\nExamine the table's contents:\n\n```sql\nmysql> SELECT id,last_login FROM login_history LIMIT 5;\n+---+--------------+\n| id | last_login  |\n+---+---+\n| 1 | 2019-05-02  |\n| 2 | NULL        |\n| 3 | NULL        |\n| 4 | 2019-05-06  |\n| 5 | 2020-09-02  |\n+---+--------------+\n5 rows in set (0.00 sec)\n```\n\nYou must determine the number of non-null dates in the last_login column.\n\nWhich function call will satisfy this requirement?",
        "selections": {
            "A": "ROW_COUNT()",
            "B": "SUM(last_login)",
            "C": "FOUND_ROWS()",
            "D": "DISTINCT(last_login)",
            "E": "COUNT(*)",
            "F": "COUNT(last_login)"
        },
        "answers": [
            "F"
        ],
        "summary": "### 正确答案解析\n\n**正确选项F的原因：**\n\n1. **COUNT(column)特性**：\n   - `COUNT(last_login)`只统计非NULL值\n   - 示例结果：3（对应id 1,4,5）\n\n2. **验证方法**：\n```sql\nSELECT COUNT(last_login) FROM login_history;\n-- 返回3（忽略NULL值）\n```\n\n3. **与其他函数对比**：\n```sql\n-- 错误选项分析\nCOUNT(*)        -- 统计所有行（返回5）\nSUM(last_login) -- 对日期求和（无效操作）\nROW_COUNT()     -- 返回上条语句影响行数\nFOUND_ROWS()    -- 返回上条SELECT匹配行数\nDISTINCT不是函数\n```\n\n**统计方法总结**：\n```sql\n-- 各种COUNT用法对比\nSELECT \n  COUNT(*) AS total_rows,        -- 5\n  COUNT(last_login) AS non_null, -- 3\n  COUNT(1) AS total_rows_alt,    -- 5\n  COUNT(DISTINCT last_login) AS unique_dates -- 3（当前数据）\nFROM login_history;\n```",
        "suggestion": "### 开发建议\n\n1. **NULL值处理技巧**：\n```sql\n-- 统计NULL值数量\nSELECT COUNT(*) - COUNT(last_login) AS null_count FROM login_history;\n\n-- 使用SUM统计条件计数\nSELECT SUM(last_login IS NULL) AS null_count FROM login_history;\n```\n\n2. **性能优化**：\n   - 对需要频繁统计的列建立索引\n   - 大数据集考虑近似统计：\n```sql\nSELECT TABLE_ROWS \nFROM INFORMATION_SCHEMA.TABLES \nWHERE TABLE_NAME = 'login_history';\n```\n\n3. **业务逻辑实现**：\n```sql\n-- 计算非NULL比例\nSELECT \n  COUNT(last_login)/COUNT(*) AS not_null_ratio \nFROM login_history;\n```"
    },
    {
        "question": "### 试题 43:\n\nWhich two are true about PREPARE statements?",
        "selections": {
            "A": "They are accessible in other active sessions.",
            "B": "They retain their resources even if the connection to the database is lost.",
            "C": "They can be nested.",
            "D": "They can be created and executed within a stored routine.",
            "E": "They can be created with the same name as an existing prepared statement in the same session."
        },
        "answers": [
            "D",
            "E"
        ],
        "summary": "### 正确答案解析（修正版）\n\n**正确选项D和E的原因：**\n\n1. **存储例程支持（选项D）**：\n   - 官方文档明确说明PREPARE语句可以在存储过程中使用\n   - 示例验证：\n```sql\nDELIMITER //\nCREATE PROCEDURE test_prepare()\nBEGIN\n  PREPARE stmt FROM 'SELECT 1';\n  EXECUTE stmt;\n  DEALLOCATE PREPARE stmt;\nEND //\nDELIMITER ;\n```\n\n2. **同名覆盖（选项E）**：\n   - 同会话中创建同名预处理语句会覆盖前一个\n   - 这是MySQL的预期行为\n\n**关于选项C的澄清**：\n- 官方文档明确指出预处理语句语法不能嵌套使用\n- 之前示例中的嵌套执行实际是先后执行，不是真正的语法嵌套\n\n**错误选项确认**：\n- `A`：预处理语句始终是会话级对象\n- `B`：连接断开后资源必定释放\n\n**关键文档引用**：\n- [MySQL 8.0 Prepared Statements](https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html)\n- 存储例程中支持PREPARE但有限制条件",
        "suggestion": "### 学习建议\n\n1. **文档重点标注**：\n   - 存储过程支持PREPARE但函数/触发器不支持\n   - 预处理语句有会话作用域和生命周期限制\n\n2. **实验验证方法**：\n```sql\n-- 测试同名覆盖\nPREPARE stmt FROM 'SELECT 1';\nPREPARE stmt FROM 'SELECT 2'; -- 成功覆盖\n\n-- 测试存储过程\nCREATE PROCEDURE sp()\nBEGIN\n  PREPARE stmt FROM 'SELECT CURRENT_USER()';\n  EXECUTE stmt;\nEND;\n```\n\n3. **避坑指南**：\n   - 避免在函数/触发器中使用PREPARE\n   - 及时DEALLOCATE释放资源\n   - 使用唯一名称防止意外覆盖"
    },
    {
        "question": "### 试题 44:\n\nWhich is a use characteristic of NoSQL JSON document store databases?",
        "selections": {
            "A": "ACID transactions",
            "B": "ad-hoc data format",
            "C": "complex queries with JOINs",
            "D": "well defined schemas"
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B的原因：**\n\n1. **NoSQL文档数据库核心特性**：\n   - 支持动态/非结构化数据格式（ad-hoc）\n   - 每个文档可以有完全不同的字段结构\n   - 示例（MongoDB文档）：\n```json\n{\"name\":\"John\", \"age\":30}\n{\"product\":\"phone\", \"price\":699}\n```\n\n2. **与其他选项对比**：\n   - `A`：多数文档数据库不原生支持跨文档ACID\n   - `C`：JOIN操作不是文档数据库的强项\n   - `D`：Schema-less正是文档库的特点\n\n**典型文档数据库特点**：\n```\n1. 灵活的数据模型\n2. 水平可扩展性\n3. 高性能读写\n4. 弱化模式约束\n```",
        "suggestion": "### 技术选型建议\n\n1. **适用场景**：\n   - 快速迭代的原型开发\n   - 半结构化日志数据\n   - 内容管理系统\n\n2. **开发技巧**：\n```javascript\n// MongoDB示例-插入不同结构的文档\ndb.items.insertMany([\n  {type:\"book\", title:\"NoSQL指南\"},\n  {type:\"food\", price:9.99, expiry:\"2023-12-31\"}\n]);\n```\n\n3. **注意事项**：\n   - 后期需要数据规范时考虑添加应用层校验\n   - 重要业务数据建议采用混合架构（文档+关系型）"
    },
    {
        "question": "### 试题 45:\n\nExamine these statements which execute successfully:\n\n```sql\nCREATE TABLE `inventory_items` (\n `inventory_item_id` INT NOT NULL AUTO_INCREMENT,\n `inventory_item_name` VARCHAR(50) NOT NULL,\n `inventory_item_count` INT UNSIGNED DEFAULT NULL,\n PRIMARY KEY (`inventory_item_id`)\n) ENGINE=InnoDB;\n\nSET sql_mode = '';\n```\n\nNow, examine this query:\n\n```sql\nINSERT INTO inventory_items (inventory_item_name, inventory_item_count)\nVALUES ('calculators', -1);\n```\n\nWhat is the result?",
        "selections": {
            "A": "It inserts a row with a warning.",
            "B": "It inserts a row with no error or warning.",
            "C": "It inserts a row with an error.",
            "D": "It fails with an error.",
            "E": "It fails with a warning."
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **无sql_mode情况下的MySQL行为**：\n   - 当`sql_mode`为空时，MySQL处于非严格模式\n   - 对超出范围的值会进行隐式转换而非报错\n   - `INT UNSIGNED`字段接受-1会转换为最大值4294967295\n\n2. **验证方法**：\n```sql\n-- 查看实际插入的值\nSELECT * FROM inventory_items \nWHERE inventory_item_name = 'calculators';\n-- 显示：4294967295\n\n-- 查看警告内容\nSHOW WARNINGS;\n-- 显示：\n-- Level: Warning\n-- Code: 1264\n-- Message: Out of range value for column 'inventory_item_count' at row 1\n```\n\n3. **与其他模式对比**：\n   - 如果设置`sql_mode='STRICT_ALL_TABLES'`则会直接报错\n\n**错误选项分析**：\n- `B`：会产生警告\n- `C`/`D`：非严格模式下不会报错\n- `E`：会插入数据而非失败",
        "suggestion": "### 开发建议\n\n1. **生产环境配置**：\n```sql\n-- 推荐设置严格模式\nSET GLOBAL sql_mode='STRICT_ALL_TABLES,NO_ZERO_IN_DATE';\n```\n\n2. **数据完整性检查**：\n```sql\n-- 添加检查约束(MySQL 8.0+)\nALTER TABLE inventory_items \nADD CONSTRAINT chk_count \nCHECK (inventory_item_count IS NULL OR inventory_item_count >= 0);\n```\n\n3. **错误处理示例**：\n```php\n// PHP示例代码\ntry {\n    $pdo->exec(\"INSERT INTO inventory_items...\");\n    if ($pdo->warningCount() > 0) {\n        $warnings = $pdo->getWarnings();\n        // 处理警告\n    }\n} catch (PDOException $e) {\n    // 处理错误\n}\n```"
    },
    {
        "question": "### 试题 46:\n\n```sql\nSELECT * FROM exam_result;\n+-----+---------+\n| sid | score   |\n+-----+---------+\n| 1   | 75.235  |\n| 2   | 75.234  |\n| 3   | 75.2533 |\n| 4   | 75.2573 |\n+-----+---------+\n```\n\nDesired output:\n```sql\n+-----+-------+\n| sid | score |\n+-----+-------+\n| 1   | 75.2  |\n| 2   | 75.2  |\n| 3   | 75.3  |\n| 4   | 75.3  |\n+-----+-------+\n```\n\nWhich statement updates the table data as required?",
        "selections": {
            "A": "UPDATE exam_result SET score=TRUNCATE(CEIL(score),1);",
            "B": "UPDATE exam_result SET score=ROUND(CEIL(score),1);",
            "C": "UPDATE exam_result SET score=ROUND(score,1);",
            "D": "UPDATE exam_result SET score=TRUNCATE(score,1);",
            "E": "UPDATE exam_result SET score=CEIL(TRUNCATE(score,1));",
            "F": "UPDATE exam_result SET score=CEIL(ROUND(score,1));"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **ROUND函数特性**：\n   - `ROUND(score,1)`实现标准的四舍五入到1位小数\n   - 示例验证：\n```sql\nSELECT \n  score,\n  ROUND(score,1) AS rounded\nFROM exam_result;\n/* 输出：\n75.235 → 75.2\n75.234 → 75.2\n75.2533 → 75.3\n75.2573 → 75.3\n*/\n```\n\n2. **与其他函数对比**：\n   - `TRUNCATE`：直接截断不四舍五入（不符合需求）\n   - `CEIL`：向上取整（会得到76等整数）\n   - 组合函数会产生错误结果\n\n**函数行为演示**：\n```sql\n-- 各选项效果对比\nSELECT \n  score,\n  ROUND(score,1) AS C,      -- 正确\n  TRUNCATE(score,1) AS D,   -- 错误（75.2573→75.2）\n  CEIL(score) AS raw_ceil   -- 错误（76）\nFROM exam_result;\n```",
        "suggestion": "### 开发建议\n\n1. **数值处理最佳实践**：\n```sql\n-- 精确计算建议使用DECIMAL类型\nALTER TABLE exam_result MODIFY score DECIMAL(5,2);\n\n-- 银行舍入(四舍六入五成双)\nSET @x = 75.25;\nSELECT ROUND(@x*2)/2; -- 75.0\n```\n\n2. **格式化显示方案**：\n```sql\n-- 不修改数据只改变显示\nSELECT sid, FORMAT(score,1) AS score_display FROM exam_result;\n```\n\n3. **注意事项**：\n   - 浮点数比较应使用范围而非等号\n   - 重要计算应考虑使用定点数类型"
    },
    {
        "question": "### 试题 47:\n\nExamine the structure of the city table:\n\n```sql\n+-------------+----------+------+-----+---------+----------------+\n| Field       | Type     | Null | Key | Default | Extra          |\n+-------------+----------+------+-----+---------+----------------+\n| ID          | int      | NO   | PRI | NULL    | auto_increment |\n| Name        | char(35) | NO   |     |         |                |\n| CountryCode | char(3)  | NO   |     |         |                |\n| District    | char(20) | NO   |     |         |                |\n| Population  | int      | NO   | MUL | 0       |                |\n+-------------+----------+------+-----+---------+----------------+\n```\n\nNow examine this statement and output with a placeholder <keylength>:\n\n```sql\nEXPLAIN SELECT Name, Population FROM City WHERE Population=100231\\G\n\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: city\n   partitions: NULL\n         type: ref\npossible_keys: pop_idx\n          key: pop_idx\n      key_len: <keylength>\n          ref: const\n         rows: 1\n     filtered: 100\n        Extra: NULL\n```\n\nWhat is the value of keylength?",
        "selections": {
            "A": "1",
            "B": "6",
            "C": "2",
            "D": "100231",
            "E": "4",
            "F": "5"
        },
        "answers": [
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项E的原因：**\n\n1. **key_len计算规则**：\n   - `Population`字段类型为`int`，占用4字节\n   - 表结构中显示`Population`列为`NOT NULL`，无需额外字节存储NULL标记\n   - 计算公式：4 bytes (int) = 4\n\n2. **验证方法**：\n```sql\n-- 查看索引详情\nSHOW INDEX FROM city WHERE Key_name='pop_idx';\n-- 确认Population字段类型\n\n-- 计算key_len\nSELECT 4 AS key_length; -- int类型固定4字节\n```\n\n3. **与其他选项对比**：\n   - `A`/`C`：小于实际字节数\n   - `B`/`F`：超出int类型存储需求\n   - `D`：混淆了查询值和索引长度\n\n**索引长度计算要点**：\n```\n1. NULL标记：可为NULL的列需要+1字节\n2. 字符串类型：需要考虑字符集和前缀索引\n3. 整数类型：固定长度（int=4, smallint=2等）\n```",
        "suggestion": "### 性能优化建议\n\n1. **索引设计检查**：\n```sql\n-- 查看索引统计信息\nANALYZE TABLE city;\n\n-- 检查索引选择性\nSELECT COUNT(DISTINCT Population)/COUNT(*) FROM city;\n```\n\n2. **复合索引优化**：\n```sql\n-- 如果常按Population+CountryCode查询\nALTER TABLE city ADD INDEX pop_country_idx(Population,CountryCode);\n-- 此时key_len=4+3*3=13（假设utf8字符集）\n```\n\n3. **执行计划分析技巧**：\n```sql\n-- 强制使用索引验证\nEXPLAIN SELECT Name FROM city USE INDEX(pop_idx) \nWHERE Population=100231;\n```"
    },
    {
        "question": "### 试题 48:\n\nExamine these commands and output:\n\n```sql\nmysql> DESC hr.emp;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| id    | int(11)     | NO   | PRI | NULL    |       |\n| name  | varchar(25) | YES  |     | NULL    |       |\n| salary| int(11)     | YES  |     | NULL    |       |\n| email | varchar(25) | YES  |     | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n4 rows in set (0.00 sec)\n\nmysql> CREATE VIEW hr.emp_vu1\n -> AS\n -> SELECT name, salary\n -> FROM hr.emp;\nQuery OK, 0 rows affected (0.02 sec)\n\nmysql> DROP TABLE hr.emp;\nQuery OK, 0 rows affected (0.02 sec)\n\nmysql> CREATE TABLE hr.emp (id INT PRIMARY KEY, name VARCHAR(25), salary int,\nemail VARCHAR(25) NOT NULL);\nQuery OK, 0 rows affected (0.04 sec)\n```\n\nNow, examine this command:\n\n```sql\nmysql> CREATE VIEW hr.emp_vu1\n -> AS\n -> SELECT name, salary\n -> FROM hr.emp;\n```\n\nWhich is true?",
        "selections": {
            "A": "Existing emp_vu1 is dropped and a new emp_vu1 is created with the new definition.",
            "B": "It returns an error because the CREATE TABLE statement automatically recreated the view.",
            "C": "It returns an error because the DROP TABLE statement did not drop the view.",
            "D": "A new view is created because the previous was dropped on execution of the DROP TABLE statement."
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **视图与基表的独立性**：\n   - 删除表(emp)不会自动删除依赖的视图(emp_vu1)\n   - 视图在数据字典中独立存在\n\n2. **视图创建冲突**：\n   - 当尝试重新创建同名视图时，原视图仍然存在\n   - 导致报错：`ERROR 1050 (42S01): Table 'hr.emp_vu1' already exists`\n\n3. **验证方法**：\n```sql\n-- 查看视图状态\nSHOW FULL TABLES IN hr WHERE TABLE_TYPE LIKE 'VIEW';\n-- 确认emp_vu1视图仍然存在\n```\n\n**错误选项分析**：\n- `A`：MySQL不会自动替换已有视图\n- `B`：创建表不会影响视图\n- `D`：DROP TABLE不会级联删除视图",
        "suggestion": "### 开发建议\n\n1. **安全删除流程**：\n```sql\n-- 先检查视图是否存在\nDROP VIEW IF EXISTS hr.emp_vu1;\n-- 再重新创建\nCREATE VIEW hr.emp_vu1 AS SELECT ...;\n```\n\n2. **查看视图定义**：\n```sql\nSHOW CREATE VIEW hr.emp_vu1;\n```\n\n3. **依赖关系检查**：\n```sql\n-- 查看依赖该表的视图\nSELECT TABLE_NAME \nFROM INFORMATION_SCHEMA.VIEWS \nWHERE TABLE_SCHEMA='hr' \nAND DEFINER LIKE '%emp%';\n```\n\n4. **批量处理脚本**：\n```sql\n-- 重建所有依赖视图\nSET @sql = NULL;\nSELECT GROUP_CONCAT('DROP VIEW IF EXISTS ', TABLE_SCHEMA, '.', TABLE_NAME, ';')\nINTO @sql\nFROM INFORMATION_SCHEMA.VIEWS\nWHERE TABLE_SCHEMA='hr';\nPREPARE stmt FROM @sql;\nEXECUTE stmt;```"
    },
    {
        "question": "### 试题 49:\n\nExamine these commands and output:\n\n```sql\nmysql> DESC employees;\n+-----------+--------------+------+-----+---------+-------+\n| Field     | Type         | Null | Key | Default | Extra |\n+-----------+--------------+------+-----+---------+-------+\n| id        | int(11)      | NO   | PRI | NULL    |       |\n| lastname  | varchar(255) | NO   |     | NULL    |       |\n| salary    | int(11)      | YES  |     | NULL    |       |\n| email     | varchar(255) | NO   |     | NULL    |       |\n+-----------+--------------+------+-----+---------+-------+\n4 rows in set (0.00 sec)\n\nmysql> CREATE VIEW emp_vu\n -> AS\n -> SELECT id, salary\n -> FROM employees;\nQuery OK, 0 rows affected (0.00 sec)\n```\n\nNow, examine this statement:\n\n```sql\nmysql> INSERT INTO emp_vu\n -> VALUES (104, 17000);\n```\n\nWhich is true about the execution of the INSERT statement?",
        "selections": {
            "A": "It returns an error.",
            "B": "It inserts a row in the view and base table.",
            "C": "It inserts a new row in the base table only.",
            "D": "It inserts a new row in the view only."
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **视图插入限制**：\n   - 该视图只包含`id`和`salary`字段\n   - 基表`employees`有`NOT NULL`字段(`lastname`,`email`)未包含在视图中\n   - 尝试插入时会违反非空约束\n\n2. **错误验证**：\n```sql\nERROR 1423 (HY000): Field of view 'hr.emp_vu' underlying table doesn't have a default value\n```\n\n3. **可更新视图条件**：\n   - 必须包含基表所有`NOT NULL`且无默认值的字段\n   - 不满足条件的视图不可插入数据\n\n**错误选项分析**：\n- `B`/`C`/`D`：由于缺少必要字段，插入操作根本不会执行",
        "suggestion": "### 开发建议\n\n1. **创建可更新视图**：\n```sql\n-- 包含所有NOT NULL字段\nCREATE VIEW emp_vu_updatable AS\nSELECT id, lastname, salary, email\nFROM employees;\n```\n\n2. **使用INSTEAD OF触发器**：\n```sql\n-- MySQL不支持，但其他数据库如SQL Server可用\nCREATE TRIGGER emp_vu_insert\nINSTEAD OF INSERT ON emp_vu\nAS\nBEGIN\n    INSERT INTO employees(id, lastname, salary, email)\n    VALUES(NEW.id, 'DEFAULT', NEW.salary, 'unknown@email.com');\nEND;\n```\n\n3. **检查视图可更新性**：\n```sql\nSELECT TABLE_NAME, IS_UPDATABLE\nFROM INFORMATION_SCHEMA.VIEWS\nWHERE TABLE_SCHEMA='hr';\n```\n\n4. **替代方案**：\n```sql\n-- 使用存储过程处理复杂插入逻辑\nDELIMITER //\nCREATE PROCEDURE insert_emp_vu(IN p_id INT, IN p_salary INT)\nBEGIN\n    INSERT INTO employees(id, lastname, salary, email)\n    VALUES(p_id, 'default', p_salary, CONCAT(p_id,'@company.com'));\nEND //\nDELIMITER ;\n```"
    },
    {
        "question": "### 试题 50:\n\nA server hosts MySQL Server and Apache Webserver supporting a PHP/PDO based application.\n\nThe application must be migrated from PHP to their Java application server on another host.\nThe MySQL instance remains on the original host.\n\nExamine the PDO connection string used in the existing application:\n\n```\nmysql:host=localhost;dbname=sales;unix_socket=/var/run/mysql.sock\n```\n\nWhich two prevent Java from using the Unix socket?",
        "selections": {
            "A": "The socket is not implemented in Connector/J driver.",
            "B": "The X Dev API protocol must be enabled to use sockets in Connector/J driver.",
            "C": "Java treats the socket file as insecure.",
            "D": "The socket can only be accessed from the local host.",
            "E": "socket is a reserved word in Java."
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A和D的原因：**\n\n1. **Connector/J限制（选项A）**：\n   - MySQL的Java驱动(Connector/J)不支持Unix socket连接方式\n   - 必须使用TCP/IP连接（即使连接本地也默认用127.0.0.1）\n\n2. **本地访问限制（选项D）**：\n   - Unix socket文件只能由本机进程访问\n   - 迁移后Java应用在另一台主机，无法访问原机的socket文件\n\n**错误选项分析**：\n- `B`：X Dev API与socket连接无关\n- `C`：Java不因安全问题限制socket使用\n- `E`：socket不是Java保留字\n\n**连接方式对比**：\n```\nPHP PDO: 支持unix_socket参数\nJava JDBC: 仅支持jdbc:mysql://host:port/db格式\n```",
        "suggestion": "### 迁移方案建议\n\n1. **Java连接配置**：\n```java\n// 正确格式\nString url = \"jdbc:mysql://原服务器IP:3306/sales\";\n```\n\n2. **网络配置检查**：\n   - 确保新主机能访问MySQL服务器的3306端口\n   - 在MySQL中授权远程连接：\n```sql\nGRANT ALL ON sales.* TO 'appuser'@'新服务器IP' IDENTIFIED BY 'password';\n```\n\n3. **性能优化**：\n   - 使用连接池（如HikariCP）\n   - 考虑SSH隧道加密远程连接\n\n4. **替代方案**：\n   - 如需高性能本地连接，可考虑在Java服务器本地部署MySQL副本"
    },
    {
        "question": "### 试题 51:\n\nExamine this partial Python code which executes successfully:\n\n```python\nconn = mysql.connector.conn(**conn_params)\ncursor = conn.cursor(raw=True)\n```\n\nWhat is true about this code?",
        "selections": {
            "A": "The result is returned asynchronously.",
            "B": "It converts MySQL DATETIME to Python datetime values.",
            "C": "The result is returned as a raw BLOB.",
            "D": "It skips conversions from SQL to native formatted data types.",
            "E": "The result is returned in a simple tabular form."
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **raw参数作用**：\n   - `raw=True`会跳过MySQL到Python的类型转换\n   - 所有数据以原始字节串形式返回\n   - 官方文档说明：当需要直接处理原始数据时使用\n\n2. **验证示例**：\n```python\n# 获取DATETIME列时的差异\nwith raw=False（默认）: 返回datetime.datetime对象\nwith raw=True: 返回b'2023-01-01 12:00:00'字节串\n```\n\n3. **适用场景**：\n   - 需要最高性能时\n   - 自定义类型转换逻辑时\n   - 处理二进制数据时\n\n**错误选项分析**：\n- `A`：不影响异步/同步行为\n- `B`：raw模式会跳过类型转换\n- `C`：返回原始字节但不仅限BLOB\n- `E`：返回形式与raw参数无关",
        "suggestion": "### 开发建议\n\n1. **类型处理方案**：\n```python\n# 手动转换示例\ncursor = conn.cursor(raw=True)\ncursor.execute(\"SELECT created_at FROM orders\")\nfor (raw_bytes,) in cursor:\n    dt = datetime.strptime(raw_bytes.decode('utf-8'), '%Y-%m-%d %H:%M:%S')\n```\n\n2. **性能对比**：\n   - raw模式可减少15-20%的查询处理时间\n   - 适合批量数据处理场景\n\n3. **连接池配置**：\n```python\nimport mysql.connector.pooling\n\npool = mysql.connector.pooling.MySQLConnectionPool(\n    pool_name=\"mypool\",\n    pool_size=5,\n    raw=True,\n    **conn_params\n)\n```\n\n4. **注意事项**：\n   - 使用raw模式需自行处理编码问题\n   - 数值类型也需要手动转换"
    },
    {
        "question": "### 试题 52:\n\nExamine the output:\n\n```\n*************************** 1. row ***************************\nEXPLAIN: {\n \"query_block\": {\n \"select_id\": 1,\n \"cost_info\": {\n \"query_cost\": \"0.45\"\n },\n \"table\": {\n \"table_name\": \"country\",\n \"access_type\": \"ALL\",\n \"rows_examined_per_scan\": 2,\n \"rows_produced_per_join\": 2,\n \"filtered\": \"100.00\",\n \"cost_info\": {\n \"read_cost\": \"0.25\",\n \"eval_cost\": \"0.20\",\n \"prefix_cost\": \"0.45\",\n \"data_read_per_join\": \"224\"\n },\n \"used_columns\": [\n \"code\",\n \"Name\",\n \"Continent\",\n \"LanguageId\"\n ]\n }\n }\n}\n1 row in set, 1 warning (0.00 sec)\n```\n\nWhich EXPLAIN command will obtain the output?",
        "selections": {
            "A": "EXPLAIN PARTITIONS",
            "B": "EXPLAIN ANALYZE",
            "C": "EXPLAIN FORMAT=TRADITIONAL",
            "D": "EXPLAIN FORMAT=TREE",
            "E": "EXPLAIN FORMAT=JSON"
        },
        "answers": [
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项E的原因：**\n\n1. **JSON格式特征**：\n   - 输出以JSON结构呈现\n   - 包含嵌套的`query_block`、`cost_info`等JSON对象\n   - 示例中明显的`{ }`结构是JSON格式的标识\n\n2. **验证方法**：\n```sql\n-- 产生相同格式输出的命令\nEXPLAIN FORMAT=JSON SELECT * FROM country;\n```\n\n3. **与其他格式对比**：\n   - `TRADITIONAL`：表格形式输出\n   - `TREE`：层级缩进文本\n   - `ANALYZE`：包含实际执行统计\n   - `PARTITIONS`：显示分区信息\n\n**EXPLAIN格式总结**：\n```\nJSON        : 结构化机器可读格式（如题目所示）\nTRADITIONAL : 经典表格形式（默认）\nTREE        : 可视化执行路径\n```",
        "suggestion": "### 开发建议\n\n1. **JSON输出分析技巧**：\n```sql\n-- 提取特定信息\nSELECT JSON_EXTRACT(EXPLAIN_FORMAT, '$.query_block.cost_info.query_cost')\nFROM (EXPLAIN FORMAT=JSON SELECT * FROM country) AS t(EXPLAIN_FORMAT);\n```\n\n2. **自动化监控方案**：\n```python\n# Python解析EXPLAIN JSON\nimport json\n\nexplain_json = cursor.execute(\"EXPLAIN FORMAT=JSON SELECT ...\").fetchone()[0]\nplan = json.loads(explain_json)\nprint(f\"Query cost: {plan['query_block']['cost_info']['query_cost']}\")\n```\n\n3. **性能优化重点**：\n   - 关注`query_cost`和`rows_examined_per_scan`\n   - `access_type: ALL`表示全表扫描需优化\n\n4. **可视化工具推荐**：\n   - MySQL Workbench的Visual Explain功能\n   - Percona PMM的查询分析器"
    },
    {
        "question": "### 试题 53:\n\nExamine this statement which executes successfully:\n\n```sql\nSELECT CONCAT('Hello ', NULL, 'World!');\n```\n\nWhat is the output?",
        "selections": {
            "A": "HelloWorld!",
            "B": "Hello NULLWorld!",
            "C": "NULL",
            "D": "Hello World!"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **CONCAT函数特性**：\n   - 当任何参数为NULL时，CONCAT返回NULL\n   - 这是MySQL的标准行为\n   - 示例验证：\n```sql\nSELECT CONCAT('A', NULL, 'B'); -- 返回NULL\n```\n\n2. **与其他函数对比**：\n   - CONCAT_WS会忽略NULL值\n   - IFNULL可处理NULL值\n\n3. **NULL处理逻辑**：\n   - NULL在SQL中表示\"未知值\"\n   - 任何与NULL的运算结果通常都是NULL\n\n**错误选项分析**：\n- `A`：忽略了NULL的影响\n- `B`：不会将NULL转为字符串\n- `D`：没有正确处理NULL参数",
        "suggestion": "### 开发建议\n\n1. **处理NULL值的替代方案**：\n```sql\n-- 使用CONCAT_WS忽略NULL\nSELECT CONCAT_WS('', 'Hello ', NULL, 'World!'); -- 返回'Hello World!'\n\n-- 使用IFNULL替换NULL\nSELECT CONCAT('Hello ', IFNULL(NULL, ''), 'World!');\n```\n\n2. **NULL安全连接函数**：\n```sql\n-- MySQL 8.0+ 支持\nSELECT 'Hello ' || NULL || 'World!'; -- 返回NULL\n```\n\n3. **业务逻辑设计**：\n   - 重要字段应设置NOT NULL约束\n   - 应用层处理NULL的显示逻辑\n\n4. **调试技巧**：\n```sql\n-- 检查字符串中的NULL\nSELECT CONCAT('[' , col , ']') FROM table;\n-- 显示为[NULL]表示col是NULL\n```"
    },
    {
        "question": "### 试题 54:\n\nExamine these statements which execute successfully:\n\n```sql\nCREATE TABLE `band` (\n `song` varchar(50) NOT NULL,\n `year` int NOT NULL\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\nSELECT * FROM band;\n+-----------------------------+------+\n| song                        | year |\n+-----------------------------+------+\n| Come Together               | 1969 |\n| The Long and Winding Road   | 1970 |\n| The Fool on the Hill        | 1967 |\n| Hey Jude                   | 1968 |\n| Here Comes the Sun          | 1969 |\n| Love Me Do                 | 1963 |\n+-----------------------------+------+\n```\n\nNow, examine this desired output:\n\n```sql\n+-----------------------------+------+\n| song                        | year |\n+-----------------------------+------+\n| The Fool on the Hill        | 1967 |\n+-----------------------------+------+\n```\n\nWhich two queries will produce the output?",
        "selections": {
            "A": "SELECT * FROM band\n WHERE song RLIKE '^the'\n AND SUBSTRING(song, 4) RLIKE \"the\" COLLATE utf8mb4_0900_as_cs;",
            "B": "SELECT * FROM band\n WHERE song RLIKE 'the'\n AND song RLIKE '^the';",
            "C": "SELECT * FROM band\n WHERE song RLIKE 'the' COLLATE utf8mb4_0900_ai_ci\n AND song RLIKE '^the' COLLATE utf8mb4_0900_ai_ci;",
            "D": "SELECT * FROM band\n WHERE song RLIKE 'the' COLLATE latin1_general_cs\n AND song RLIKE '^the' COLLATE latin1_general_ci;",
            "E": "SELECT * FROM band\n WHERE song RLIKE 'the' COLLATE utf8mb4_0900_as_cs\n AND song RLIKE '^the' COLLATE utf8mb4_0900_as_cs;"
        },
        "answers": [
            "A",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A和E的原因：**\n\n1. **匹配条件分析**：\n   - 需要同时满足：\n     1) 以\"the\"开头（区分大小写）\n     2) 包含\"the\"（区分大小写）\n   - 只有\"The Fool on the Hill\"同时满足这两个条件\n\n2. **选项A解析**：\n   - `RLIKE '^the'`：匹配以\"the\"开头的行（不区分大小写）\n   - `SUBSTRING(song, 4) RLIKE \"the\" COLLATE utf8mb4_0900_as_cs`：\n     - 从第4字符开始查找\"the\"\n     - 使用区分大小写的排序规则\n\n3. **选项E解析**：\n   - 统一使用`utf8mb4_0900_as_cs`（区分大小写和重音的排序规则）\n   - 确保\"The\"和\"the\"被正确区分\n\n**错误选项分析**：\n- `B`：默认不区分大小写，会匹配到多行\n- `C`：使用不区分大小写的排序规则\n- `D`：混用了不同的排序规则\n\n**正则表达式要点**：\n```\n^the   : 以the开头\nthe    : 任意位置包含the\nCOLLATE: 指定字符比较规则\n```",
        "suggestion": "### 开发建议\n\n1. **精确匹配技巧**：\n```sql\n-- 更简洁的写法\nSELECT * FROM band \nWHERE song REGEXP '^[Tt]he' \nAND song REGEXP '\\\\bthe\\\\b';\n```\n\n2. **排序规则选择**：\n   - `_cs`：区分大小写(Case Sensitive)\n   - `_ai`：不区分重音(Accent Insensitive)\n   - `_as`：区分重音(Accent Sensitive)\n\n3. **性能优化**：\n   - 对频繁查询的列使用函数索引：\n```sql\nALTER TABLE band \nADD INDEX idx_song_lower ((LOWER(song)));\n```\n\n4. **测试不同排序规则**：\n```sql\n-- 查看不同排序规则的效果\nSELECT \n  song,\n  song COLLATE utf8mb4_0900_as_cs AS case_sensitive,\n  song COLLATE utf8mb4_0900_ai_ci AS case_insensitive\nFROM band;\n```"
    },
    {
        "question": "### 试题 55:\n\nWhat are three general advantages to prepared statements?",
        "selections": {
            "A": "They allow queries to run in parallel.",
            "B": "They take advantage of dynamic cursor declarations.",
            "C": "They cache data before sending it to the MySQL Server.",
            "D": "They allow for dynamic SQL in stored routines.",
            "E": "They cause the server to parse the statement each time it is executed.",
            "F": "They reduce CPU overhead.",
            "G": "They reduce network traffic between client and server."
        },
        "answers": [
            "D",
            "F",
            "G"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D、F、G的原因：**\n\n1. **动态SQL支持（选项D）**：\n   - 预处理语句允许在存储过程中构建和执行动态SQL\n   - 示例：\n```sql\nDELIMITER //\nCREATE PROCEDURE dynamic_query(IN table_name VARCHAR(64))\nBEGIN\n  SET @sql = CONCAT('SELECT * FROM ', table_name);\n  PREPARE stmt FROM @sql;\n  EXECUTE stmt;\n  DEALLOCATE PREPARE stmt;\nEND //\nDELIMITER ;\n```\n\n2. **降低CPU开销（选项F）**：\n   - 预处理语句只需解析一次\n   - 后续执行复用执行计划\n   - 性能提升显著（特别是复杂查询）\n\n3. **减少网络流量（选项G）**：\n   - 参数化查询只需传输参数值而非完整SQL\n   - 批量操作时效果更明显\n\n**错误选项分析**：\n- `A`：查询并行性与预处理无关\n- `B`：与游标声明无直接关系\n- `C`：数据缓存由客户端/驱动实现，非预处理特性\n- `E`：这是缺点而非优势\n\n**预处理语句工作流程**：\n```\n1. 准备阶段：解析SQL生成执行计划\n2. 执行阶段：绑定参数值执行\n3. 重复执行：复用已解析的计划\n```",
        "suggestion": "### 开发建议\n\n1. **批量操作优化**：\n```java\n// Java示例-批量插入\nPreparedStatement pstmt = conn.prepareStatement(\n  \"INSERT INTO users VALUES (?, ?)\");\n\nfor (User user : userList) {\n  pstmt.setInt(1, user.getId());\n  pstmt.setString(2, user.getName());\n  pstmt.addBatch();\n}\npstmt.executeBatch();\n```\n\n2. **连接池配置**：\n   - 启用预处理语句缓存（如HikariCP的`prepStmtCacheSize`）\n   - 监控缓存命中率\n\n3. **安全最佳实践**：\n   - 始终使用参数化查询防止SQL注入\n   - 避免拼接动态SQL\n\n4. **性能测试方法**：\n```sql\n-- 查看预处理语句性能\nSELECT * FROM performance_schema.prepared_statements_instances;\n\n-- 比较执行时间\nBENCHMARK(100000, EXECUTE stmt);\n```"
    },
    {
        "question": "### 试题 56:\n\nYou must schedule an event to execute a stored routine, which will run every day at 6 AM starting from June 30, 2020.\n\nWhich will do this?",
        "selections": {
            "A": "CREATE EVENT event_purge_logs\n ON SCHEDULE\n EVERY 1 DAY\n STARTS '2020-06-30 06:00:00'\n DO\n CALL purge_logs();",
            "B": "CREATE EVENT event_purge_logs\n ON SCHEDULE\n AT ('2020-06-30 06:00:00' + INTERVAL 1 DAY)\n DO\n CALL purge_logs();",
            "C": "CREATE EVENT event_purge_logs\n ON SCHEDULE\n EVERY 1 DAY\n STARTS '2020-06-30 06:00:00' ON COMPLETION PRESERVE ENABLE\n DO\n CALL purge_logs();",
            "D": "CREATE EVENT event_purge_logs\n ON SCHEDULE\n AT ('2020-06-30 06:00:00'+ INTERVAL 1 DAY) ON COMPLETION PRESERVE ENABLE\n DO\n CALL purge_logs();"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **完整事件定义**：\n   - `EVERY 1 DAY` 确保每日执行\n   - `STARTS '2020-06-30 06:00:00'` 设置准确起始时间\n   - `ON COMPLETION PRESERVE ENABLE` 保证事件持续有效\n\n2. **与其他选项对比**：\n   - 选项A缺少`ENABLE`可能导致事件未激活\n   - 选项B/D使用`AT`只执行一次\n   - 选项C是唯一同时满足每日执行和明确激活状态的方案\n\n3. **验证方法**：\n```sql\n-- 创建事件后检查状态\nSHOW EVENTS LIKE 'event_purge_logs'\\G\n-- 应显示：Status: ENABLED\n```\n\n**关键语法要素**：\n```\nEVERY + STARTS : 周期性执行基础\nON COMPLETION PRESERVE : 防止自动删除\nENABLE : 立即激活事件\n```",
        "suggestion": "### 最佳实践建议\n\n1. **生产环境配置**：\n```sql\n-- 确保事件调度器开启\nSET GLOBAL event_scheduler = ON;\n\n-- 添加完整注释\nCREATE EVENT ... COMMENT 'Daily maintenance at 6AM'\n```\n\n2. **监控方案**：\n```sql\n-- 创建执行日志表\nCREATE TABLE event_execution_log (\n  event_name VARCHAR(64),\n  exec_time DATETIME,\n  status ENUM('success','failed')\n);\n\n-- 在事件中添加日志记录\nDO\n  BEGIN\n    DECLARE EXIT HANDLER FOR SQLEXCEPTION\n      INSERT INTO event_execution_log VALUES('purge_logs', NOW(), 'failed');\n    CALL purge_logs();\n    INSERT INTO event_execution_log VALUES('purge_logs', NOW(), 'success');\n  END\n```\n\n3. **维护建议**：\n   - 定期检查`mysql.event`系统表\n   - 重要事件配置备份\n   - 考虑使用外部调度器（如cron）作为补充"
    },
    {
        "question": "### 试题 57:\n\nExamine this CRUD operation:\n\n```\nJS> col.find()\n{\n \"_id\": \"00005e8585eb000000000000000009\",\n \"name\": \"fred\"\n}\n1 document in set (0.003 sec)\n```\n\nWhich two SQL statements are valid?",
        "selections": {
            "A": "ALTER TABLE col ADD COLUMN result INT GENERATED ALWAYS as\n(doc->>\"$.result\") STORED NOT NULL;",
            "B": "ALTER TABLE col ADD COLUMN result INT GENERATED ALWAYS as\n(doc->>\"$.result\") STORED DEFAULT '0';",
            "C": "ALTER TABLE col ADD COLUMN result INT GENERATED ALWAYS as\n(doc->>\"$.result\") VIRTUAL NOT NULL;",
            "D": "ALTER TABLE col ADD COLUMN result INT GENERATED ALWAYS as\n(doc->>\"$.result\") VIRTUAL DEFAULT 0;",
            "E": "ALTER TABLE col ADD COLUMN result INT GENERATED ALWAYS as\n(doc->>\"$.result\") STORED;"
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C和E的原因：**\n\n1. **VIRTUAL列特性（选项C）**：\n   - 虽然VIRTUAL列技术上可以声明为NOT NULL，但实际执行时会忽略此约束\n   - MySQL允许语法但不会强制NOT NULL约束\n   - 示例验证：\n```sql\n-- 可以执行但不会真正约束NULL值\nALTER TABLE col ADD COLUMN result INT GENERATED ALWAYS AS (doc->>'$.result') VIRTUAL NOT NULL;\n```\n\n2. **STORED列特性（选项E）**：\n   - 纯STORED声明无附加约束是有效语法\n   - 最简形式保证执行成功\n\n**错误选项分析**：\n- `A`：STORED+NOT NULL组合会立即报错\n- `B`/`D`：生成列不允许使用DEFAULT\n\n**MySQL生成列要点**：\n```\n1. VIRTUAL列的NOT NULL声明会被静默忽略\n2. STORED列必须允许NULL（因依赖字段可能缺失）\n3. 生成列永远不能使用DEFAULT\n```",
        "suggestion": "### 开发建议\n\n1. **替代NOT NULL方案**：\n```sql\n-- 使用COALESCE提供默认值\nALTER TABLE col ADD COLUMN result INT \nGENERATED ALWAYS AS (COALESCE(doc->>'$.result',0)) VIRTUAL;\n```\n\n2. **约束验证方法**：\n```sql\n-- 测试NOT NULL约束是否生效\nINSERT INTO col (doc) VALUES('{\"other_field\":1}');\n-- 查询result列是否为NULL\n```\n\n3. **版本差异注意**：\n   - MySQL 8.0对生成列约束有更严格检查\n   - 5.7版本可能允许更多语法但实际不生效\n\n4. **最佳实践**：\n   - 避免在生成列上声明约束\n   - 通过应用层或触发器实现业务校验"
    },
    {
        "question": "### 试题 58:\n\nExamine this statement which executes successfully:\n\n```sql\nCREATE TABLE `fshop` (`product` JSON DEFAULT NULL ) ENGINE=InnoDB;\n```\n\nNow, examine a JSON value contained in the table:\n\n```json\n{\"name\" : \"orange\", \"varieties\" : [{\"VarietyName\":\"clementine\", \"Origin\" : [\"PA\",\"BU\"]},\n{\"VarietyName\": \"tangerine\", \"Origin\" : [\"CH\",\"JP\"]}]\n```\n\nWhich will cause documents to be indexed over the 'name' key?",
        "selections": {
            "A": "ALTER TABLE fshop ADD COLUMN name VARCHAR(100) AS\n(product->>'$.varieties') VIRTUAL, ADD KEY idx_name(name);",
            "B": "ALTER TABLE fshop ADD COLUMN name VARCHAR(20), ADD KEY\nidx_name(name);",
            "C": "ALTER TABLE fshop ADD COLUMN name VARCHAR(20) AS\n(product->>'$.varieties.VarietyName') VIRTUAL, ADD KEY idx_name(name);",
            "D": "ALTER TABLE fshop ADD COLUMN name VARCHAR(20) AS (product->>'$.name')\nVIRTUAL, ADD KEY idx_name(name);",
            "E": "ALTER TABLE fshop ADD name VARCHAR(20) AS\n(JSON_UNQUOTE(product->>'$.varieties.VarietyName')), ADD INDEX (name);"
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **JSON路径正确性**：\n   - `product->>'$.name'` 准确指向顶层的`name`字段（值为\"orange\"）\n   - 其他选项路径错误：\n     - A: 指向`varieties`数组\n     - C/E: 指向`varieties.VarietyName`（二级字段）\n     - B: 非生成列\n\n2. **语法有效性**：\n   - 使用`->>`运算符自动unquote JSON值\n   - 正确的VIRTUAL列+索引组合\n   - 验证示例：\n```sql\n-- 创建后查询验证\nSELECT name FROM fshop WHERE name = 'orange';\n-- 能正确使用idx_name索引\n```\n\n**错误选项分析**：\n- `A`：提取错误字段且VARCHAR长度过大\n- `B`：普通列不会自动填充JSON数据\n- `C`：索引的是variety名称而非产品名称\n- `E`：路径错误且语法冗余（无需显式JSON_UNQUOTE）\n\n**JSON索引最佳实践**：\n```sql\n-- 更完整的方案\nALTER TABLE fshop \nADD COLUMN name VARCHAR(20) \nGENERATED ALWAYS AS (JSON_UNQUOTE(JSON_EXTRACT(product,'$.name'))) STORED,\nADD INDEX idx_name(name);\n```",
        "suggestion": "### 开发建议\n\n1. **JSON查询优化**：\n```sql\n-- 创建多级索引\nALTER TABLE fshop\nADD COLUMN variety1 VARCHAR(50) AS (product->>'$.varieties[0].VarietyName') VIRTUAL,\nADD INDEX idx_variety1(variety1);\n```\n\n2. **路径验证技巧**：\n```sql\n-- 测试JSON路径\nSELECT \n  product->>'$.name' AS product_name,\n  product->>'$.varieties[0].VarietyName' AS first_variety\nFROM fshop;\n```\n\n3. **性能考量**：\n   - STORED列适合频繁查询的字段\n   - VIRTUAL列适合节省空间的场景\n   - 对长文本考虑前缀索引\n\n4. **错误处理**：\n```sql\n-- 处理可能不存在的路径\nALTER TABLE fshop\nADD COLUMN origin VARCHAR(10) AS \n  (COALESCE(product->>'$.varieties[0].Origin[0]', 'UNKNOWN')) STORED;\n```"
    },
    {
        "question": "### 试题 59:\n\nYou must write a statement that can insert the last name O'Hara into a column of the customers table.\n\nWhich two INSERT statements meet your requirement?",
        "selections": {
            "A": "INSERT INTO customers (last_name) VALUES (\"O\"\"Hara\");",
            "B": "INSERT INTO customers (last_name) VALUES ('O''Hara');",
            "C": "INSERT INTO customers (last_name) VALUES ('O%27Hara');",
            "D": "INSERT INTO customers (last_name) VALUES (\"O\"'Hara\");",
            "E": "INSERT INTO customers (last_name) VALUES ('O\\\\'Hara');"
        },
        "answers": [
            "B",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B和E的原因：**\n\n1. **SQL字符串转义规则**：\n   - 单引号字符串中的单引号需要双写（选项B）\n   - 或使用反斜杠转义（选项E）\n   - 两种方法都能正确插入`O'Hara`\n\n2. **验证方法**：\n```sql\n-- 选项B执行结果\nSELECT last_name FROM customers WHERE last_name LIKE \"O'Hara\";\n-- 返回: O'Hara\n\n-- 选项E执行结果\nSELECT last_name FROM customers WHERE last_name = 'O\\'Hara';\n-- 返回: O'Hara\n```\n\n**错误选项分析**：\n- `A`：双引号字符串中双写引号错误（实际插入`O\"Hara`）\n- `C`：直接插入URL编码值（实际插入`O%27Hara`字符串）\n- `D`：混合引号语法错误（导致语法解析错误）\n\n**SQL字符串处理要点**：\n```\n1. 单引号字符串：'O''Hara'（双写单引号）\n2. 转义字符串：'O\\'Hara'（需启用SQL模式）\n3. 双引号字符串：标准SQL不推荐\n```",
        "suggestion": "### 开发建议\n\n1. **安全插入方法**：\n```sql\n-- 使用参数化查询（推荐）\nPREPARE stmt FROM 'INSERT INTO customers (last_name) VALUES (?)';\nSET @name = \"O'Hara\";\nEXECUTE stmt USING @name;\n```\n\n2. **字符集配置**：\n```sql\n-- 确保字符集支持特殊字符\nALTER TABLE customers \nMODIFY last_name VARCHAR(50) CHARACTER SET utf8mb4;\n```\n\n3. **批量导入处理**：\n```sql\n-- 导入文件时指定转义符\nLOAD DATA INFILE 'data.txt' \nINTO TABLE customers \nFIELDS ESCAPED BY '\\\\';\n```\n\n4. **应用层处理**：\n```python\n# Python示例\nname = \"O'Hara\"\ncursor.execute(\"INSERT INTO customers VALUES (%s)\", (name,))\n```"
    },
    {
        "question": "### 试题 60:\n\nExamine this statement which produces one row:\n\n```sql\nmysql> SELECT JSON_PRETTY(product) FROM fshop;\n{\n \"name\" : \"orange\",\n \"varieties\" : \n [\n  {\"VarietyName\":\"clementine\",\n   \"Origin\" : [\"PA\",\"BU\"]},\n  {\"VarietyName\": \"tangerine\",\n   \"Origin\" : [\"CH\",\"JP\"]\n  }\n ]\n}\n```\n\nNow, examine this statement:\n\n```sql\nSELECT JSON_TYPE(product->\"$.varieties\") \nFROM fshop;\n```\n\nWhich output will be returned?",
        "selections": {
            "A": "ARRAY",
            "B": "OBJECT",
            "C": "BLOB",
            "D": "NULL",
            "E": "STRING"
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **JSON路径分析**：\n   - `product->\"$.varieties\"` 指向JSON中的数组结构\n   - 原始数据中`varieties`是包含两个对象的数组\n\n2. **JSON_TYPE函数行为**：\n   - 对数组返回`ARRAY`类型标识\n   - 验证示例：\n```sql\nSELECT JSON_TYPE(JSON_ARRAY(1,2,3)); -- 返回'ARRAY'\n```\n\n3. **与其他类型对比**：\n   - `OBJECT`：字典/对象结构（需用花括号`{}`）\n   - `STRING`：字符串值\n   - `BLOB`：二进制数据\n   - `NULL`：空值\n\n**JSON类型判断规则**：\n```\nARRAY   : [...]\nOBJECT  : {...} \nSTRING  : \"...\"\nNUMBER  : 123\nBOOLEAN : true/false\nNULL    : null\n```",
        "suggestion": "### 开发建议\n\n1. **JSON查询优化**：\n```sql\n-- 提取数组元素\nSELECT \n  product->'$.varieties[0]' AS first_variety,\n  JSON_TYPE(product->'$.varieties[0]') AS type\nFROM fshop;\n-- 返回第一个品种及类型(OBJECT)\n```\n\n2. **数组操作函数**：\n```sql\n-- 检查数组长度\nSELECT JSON_LENGTH(product->'$.varieties') FROM fshop;\n\n-- 展开数组查询\nSELECT \n  JSON_EXTRACT(variety, '$.VarietyName') AS name\nFROM fshop,\nJSON_TABLE(\n  product->'$.varieties',\n  '$[*]' COLUMNS (\n    variety JSON PATH '$'\n  )\n) AS varieties;\n```\n\n3. **类型安全验证**：\n```sql\n-- 创建生成列确保类型\nALTER TABLE fshop\nADD COLUMN variety_count INT \nGENERATED ALWAYS AS (JSON_LENGTH(product->'$.varieties')) STORED;\n```\n\n4. **错误处理**：\n```sql\n-- 处理可能不存在的路径\nSELECT \n  IFNULL(\n    JSON_TYPE(product->'$.nonexistent'),\n    'UNDEFINED'\n  ) AS type\nFROM fshop;\n```"
    },
    {
        "question": "### 试题 61:\n\nThe variables c and d are declared as integer types.\n\nExamine these initialization statements with placeholder value <p1>, which execute successfully:\n\nNow, examine this loop which executes successfully:\n\n```sql\nREPEAT\n SET d = d + 1;\n SET c = c + 1;\nUNTIL c > 3\nEND REPEAT;\n```\n\nWhich loop results in the same value of d for all valid values of <p1>?",
        "selections": {
            "A": "b: LOOP\n\n SET d = d + 1;\n\n SET c = c + 1;\n\n IF c > 3 THEN LEAVE b; END IF;\n\nEND LOOP b;",
            "B": "WHILE c <= 3 DO\n\n SET d = d + 1;\n\n SET c = c + 1;\n\nEND WHILE;",
            "C": "b: LOOP\n\n IF c > 3 THEN LEAVE b; END IF;\n\n SET d = d + 1;\n\n SET c = c + 1;\n\nEND LOOP b;",
            "D": "WHILE c < 3 DO\n\n SET d = d + 1;\n\n SET c = c + 1;\n\nEND WHILE;"
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **循环逻辑分析**：\n   - 原`REPEAT`循环特性：先执行后判断，至少执行一次\n   - 当`c`初始值>=3时：\n     - 原循环执行1次（`d`和`c`各+1）\n     - 选项A的`LOOP`也执行1次（因`IF`在操作后判断）\n   - 当`c`初始值<3时：\n     - 两者执行次数相同（直到`c>3`）\n\n2. **验证示例**：\n```sql\n-- 测试c初始值=3\nSET c=3, d=0;\nREPEAT...UNTIL c>3; -- d=1\n\nSET c=3, d=0;\n选项A的LOOP; -- d=1\n```\n\n**错误选项分析**：\n- `B`：`WHILE c<=3`在c初始值=4时不执行（原循环会执行1次）\n- `C`：判断前置，c初始值=4时不执行（原循环会执行1次）\n- `D`：`c<3`条件比原循环少1次迭代\n\n**循环类型对比**：\n```\nREPEAT-UNTIL : 先执行后判断（至少1次）\nLOOP        : 需显式LEAVE（选项A模仿REPEAT行为）\nWHILE       : 先判断后执行（可能0次）\n```",
        "suggestion": "### 开发建议\n\n1. **循环选择原则**：\n   - 需要至少执行1次 → 使用`REPEAT`或`LOOP`+后置判断\n   - 可能执行0次 → 使用`WHILE`\n\n2. **调试技巧**：\n```sql\n-- 添加调试输出\nDECLARE i INT DEFAULT 0;\nREPEAT\n SET i = i + 1;\n SET d = d + 1;\n SET c = c + 1;\n SELECT i, c, d; -- 每次迭代输出\nUNTIL c > 3\nEND REPEAT;\n```\n\n3. **边界测试用例**：\n```sql\n-- 测试c初始值边界情况\nSET c=2, d=0; -- 应执行2次\nSET c=3, d=0; -- 应执行1次\nSET c=4, d=0; -- 应执行1次\n```\n\n4. **存储过程模板**：\n```sql\nDELIMITER //\nCREATE PROCEDURE update_counter(INOUT p_c INT, INOUT p_d INT)\nBEGIN\n b: LOOP\n   SET p_d = p_d + 1;\n   SET p_c = p_c + 1;\n   IF p_c > 3 THEN LEAVE b; END IF;\n END LOOP b;\nEND//\nDELIMITER ;\n```"
    },
    {
        "question": "### 试题 62:\n\nExamine the appointments table definition which contains one million rows:\n\n```sql\nCREATE TABLE `appointments` (\n `id` int(11) NOT NULL AUTO_INCREMENT,\n `attendant_id` int(11) NOT NULL,\n `attendant_session_id` int(11) NOT NULL,\n `start` datetime NOT NULL,\n `end` datetime NOT NULL,\n `date` date NOT NULL,\n `created_by` varchar(20) NOT NULL,\n `created_at` datetime DEFAULT CURRENT_TIMESTAMP,\n `payment` int(11) NOT NULL DEFAULT '0',\n `credit` int(11) NOT NULL DEFAULT '0',\n PRIMARY KEY (`id`),\n) ENGINE=InnoDB DEFAULT CHARSET=latin1\n```\n\nNow, examine this statement which executes successfully:\n\n```sql\nSELECT attendant_id,\n payment,\n credit\nFROM appointments\nWHERE attendant_session_id = 510\nAND created_by = 'jsmith'\n```\n\nWhich statement will improve query performance?",
        "selections": {
            "A": "ALTER TABLE appointments add index IX_4(attendant_id, payment, credit)",
            "B": "ALTER TABLE appointments add index IX_1(credit,payment)",
            "C": "ALTER TABLE appointments add index IX_2(attendant_session_id, created_by)",
            "D": "ALTER TABLE appointments add index IX_3(attendant_id, created_by)"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **索引设计原则**：\n   - 最优索引应包含WHERE条件中的所有列\n   - 查询条件使用`attendant_session_id`和`created_by`\n   - 复合索引`IX_2(attendant_session_id, created_by)`完美匹配查询条件\n\n2. **验证方法**：\n```sql\n-- 创建索引后检查执行计划\nEXPLAIN SELECT attendant_id, payment, credit\nFROM appointments USE INDEX(IX_2)\nWHERE attendant_session_id = 510\nAND created_by = 'jsmith';\n-- 应显示使用IX_2索引\n```\n\n3. **性能对比**：\n   - 选项A/B/D的索引都不包含完整查询条件\n   - 只有选项C的索引能高效定位数据\n\n**错误选项分析**：\n- `A`：索引列与查询条件无关\n- `B`：只包含SELECT列不包含WHERE条件\n- `D`：包含错误的WHERE条件列(attendant_id)\n\n**复合索引最佳实践**：\n```\n1. 最左前缀原则：优先匹配WHERE条件\n2. 选择性高的列在前\n3. 避免冗余索引\n```",
        "suggestion": "### 优化建议\n\n1. **完整索引方案**：\n```sql\n-- 包含查询和返回列的覆盖索引\nALTER TABLE appointments \nADD INDEX IX_optimal(attendant_session_id, created_by, attendant_id, payment, credit);\n```\n\n2. **索引选择性检查**：\n```sql\n-- 评估字段选择性\nSELECT \n  COUNT(DISTINCT attendant_session_id)/COUNT(*) AS session_sel,\n  COUNT(DISTINCT created_by)/COUNT(*) AS creator_sel\nFROM appointments;\n-- 选择性高的列应放在索引前面\n```\n\n3. **监控索引使用**：\n```sql\n-- 检查索引使用情况\nSELECT * FROM sys.schema_index_statistics\nWHERE table_name = 'appointments';\n```\n\n4. **大表索引维护**：\n```sql\n-- 在线添加索引（MySQL 5.6+）\nALTER TABLE appointments \nADD INDEX IX_2(attendant_session_id, created_by) ALGORITHM=INPLACE, LOCK=NONE;\n```"
    },
    {
        "question": "### 试题 63:\n\nWhich two are true about MySQL Document Store?",
        "selections": {
            "A": "It helps to store data items in a schema-less key-value store.",
            "B": "It can store documents greater than 4 GB.",
            "C": "It depends heavily on strictly typed data.",
            "D": "It allows one to bypass the SQL layer of the server.",
            "E": "There is no access to relational tables."
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A和D的原因：**\n\n1. **无模式存储（选项A）**：\n   - MySQL Document Store基于JSON文档\n   - 每个文档可以有完全不同的结构\n   - 示例文档：\n```json\n{\"name\":\"John\", \"age\":30}\n{\"product\":\"phone\", \"price\":699}\n```\n\n2. **绕过SQL层（选项D）**：\n   - 通过X DevAPI直接操作文档\n   - 使用NoSQL协议与服务器通信\n   - 示例代码：\n```javascript\n// 直接使用JavaScript API\ncollection.find('name = :name').bind('name','John').execute();\n```\n\n**错误选项分析**：\n- `B`：单个JSON文档限制为4GB（实际最大1GB）\n- `C`：文档存储是弱类型的\n- `E`：可以同时访问文档和关系表\n\n**文档存储特性**：\n```\n1. 基于MySQL的JSON数据类型\n2. 支持CRUD操作\n3. 提供ACID事务\n4. 与关系数据共存\n```",
        "suggestion": "### 开发建议\n\n1. **混合模式应用**：\n```sql\n-- 在同一个事务中操作文档和关系数据\nSTART TRANSACTION;\nINSERT INTO orders VALUES(1, '2020-01-01');\nUPDATE my_col SET doc = JSON_SET(doc, '$.order_id', 1) WHERE id = 10;\nCOMMIT;\n```\n\n2. **文档验证**：\n```sql\n-- 添加JSON schema验证（MySQL 8.0+）\nALTER TABLE my_col \nADD CONSTRAINT validate_schema \nCHECK(JSON_SCHEMA_VALID('{\"type\":\"object\"}', doc));\n```\n\n3. **性能优化**：\n   - 对常用查询路径创建虚拟列索引\n   - 使用$.**语法优化JSON路径查询\n\n4. **迁移工具**：\n   - 使用MySQL Shell的JSON导入/导出功能\n   - 考虑MongoDB到MySQL的迁移工具"
    },
    {
        "question": "### 试题 64:\n\nExamine this statement:\n\n```sql\nDECLARE not_found CONDITION FOR SQLSTATE '02000';\n```\n\nIn which two statements can not_found be used?",
        "selections": {
            "A": "in a leave statement to exit a loop",
            "B": "in an if statement",
            "C": "in a while loop",
            "D": "in a handler declaration",
            "E": "in a signal statement"
        },
        "answers": [
            "D",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D和E的原因：**\n\n1. **处理器声明（选项D）**：\n   - 自定义条件主要用于异常处理\n   - 典型用法：\n```sql\nDECLARE CONTINUE HANDLER FOR not_found \n  SET @message = 'Record not found';\n```\n\n2. **信号抛出（选项E）**：\n   - 可以配合SIGNAL语句使用\n   - 示例：\n```sql\nIF some_condition THEN\n  SIGNAL not_found;\nEND IF;\n```\n\n**错误选项分析**：\n- `A`：LEAVE语句使用标签而非条件\n- `B`：IF语句判断表达式而非条件\n- `C`：WHILE循环检查布尔表达式\n\n**MySQL条件处理机制**：\n```\n1. SQLSTATE '02000' = NOT FOUND（游标/查询无数据）\n2. 条件声明作用域：BEGIN...END块内\n3. 可同时处理系统条件和自定义条件\n```",
        "suggestion": "### 开发建议\n\n1. **完整错误处理示例**：\n```sql\nCREATE PROCEDURE get_employee(IN emp_id INT)\nBEGIN\n  DECLARE not_found CONDITION FOR SQLSTATE '02000';\n  DECLARE EXIT HANDLER FOR not_found\n    SELECT 'Employee not found' AS message;\n  \n  SELECT * FROM employees WHERE id = emp_id;\nEND;\n```\n\n2. **条件复用技巧**：\n```sql\n-- 共享处理器\nDECLARE EXIT HANDLER FOR 1051 OR not_found\n  ROLLBACK;\n```\n\n3. **调试方法**：\n```sql\n-- 获取错误信息\nGET DIAGNOSTICS CONDITION 1\n  @sqlstate = RETURNED_SQLSTATE,\n  @errmsg = MESSAGE_TEXT;\n```\n\n4. **生产环境建议**：\n   - 为常见错误代码创建标准条件\n   - 记录自定义条件的触发日志\n   - 避免过度使用SIGNAL抛出业务异常"
    },
    {
        "question": "### 试题 65:\n\nExamine these my.cnf settings:\n\n```ini\n[mysqld]\nslow_query_log = ON\nslow_query_log_file=/data/slow.log\nlong_query_time=2\n```\n\nExamine this entry from /data/slow.log\n\n```\n# User@Host: admin[admin] @ [127.0.0.1] Id: 91420\n# Query_time: 0.001668 Lock_time: 0.000075 Rows_sent: 1 Rows_examined: 3\nSET timestamp=1452078485;\nSELECT count(*) FROM Subscriber sb LEFT JOIN Common cm ON sb.abr_id=cm.id\nWHERE sb.id=127183 AND sb.deletion_time='1970-01-01';\n```\n\nWhich option is also set in my.cnf?",
        "selections": {
            "A": "log_queries_not_using_indexes",
            "B": "log_slow_admin_statements=1",
            "C": "log_queries_not_using_indexes=ON",
            "D": "log_throttle_queries_not_using_indexes=100"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **慢查询日志分析**：\n   - 查询时间(0.001668秒)远低于阈值(2秒)\n   - 但仍被记录到慢查询日志\n   - 说明启用了`log_queries_not_using_indexes`\n\n2. **配置语法验证**：\n   - MySQL布尔参数应使用`=ON/OFF`或`=1/0`\n   - 选项C是唯一正确语法\n   - 选项A缺少赋值语法\n\n3. **其他选项排除**：\n   - `B`：管理语句不相关（非DDL/系统操作）\n   - `D`：限制无索引查询记录频率，无法解释当前现象\n\n**关键记忆点**：\n- `log_queries_not_using_indexes=ON` 会记录所有无索引查询\n- 即使查询很快也会被记录\n- 参数必须显式赋值为ON或1",
        "suggestion": ""
    },
    {
        "question": "### 试题 66:\n\nExamine this statement which executes successfully:\n\n```sql\nCREATE TABLE `work` (\n `job_no` INT NOT NULL,\n `data` JSON NOT NULL,\n `name` VARCHAR(30) GENERATED ALWAYS AS (JSON_EXTRACT(`data`,'$.first_name')) VIRTUAL,\n PRIMARY KEY (`job_no`)\n) ENGINE = INNODB;\n```\n\nThe table is populated with a range of values including jobs for Robert, John, and Katie. Now, examine this statement and output:\n\n```sql\nSELECT job_no, name\nFROM work\nWHERE name = 'Robert'\nEmpty set (0.0007 sec)\n```\n\nWhy is an empty result set returned?",
        "selections": {
            "A": "The select requires json_unquote in the where clause.",
            "B": "The virtual values in the name column must be accessed using functions.",
            "C": "The JSON datatype cannot be used in virtual columns.",
            "D": "The json_extract() function requires a length value that matches the field length in the schema.",
            "E": "Table statistics must be updated to generate values for the name column."
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **JSON提取值特性**：\n   - `JSON_EXTRACT()`返回带引号的JSON字符串（如`\"Robert\"`）\n   - 直接与`'Robert'`比较会失败\n   - 需要`JSON_UNQUOTE()`去除引号\n\n2. **关键记忆点**：\n   - JSON字符串比较必须处理引号差异\n   - `->>`运算符等价于`JSON_UNQUOTE(JSON_EXTRACT())`\n   - 虚拟列定义时可预先处理引号\n\n**错误选项分析**：\n- `B`：虚拟列可直接查询（无需特殊函数）\n- `C`：JSON完全支持虚拟列\n- `D`：JSON函数无需长度参数\n- `E`：统计信息不影响数据内容",
        "suggestion": "### 核心知识点记忆\n1. `JSON_EXTRACT()`返回带双引号的字符串值\n2. 直接比较JSON提取值需用`JSON_UNQUOTE()`或`->>`运算符\n3. 虚拟列定义时即可处理引号问题\n4. 查询条件中的字符串比较需注意引号匹配"
    },
    {
        "question": "### 试题 67:\n\nYou must reclaim memory used by a prepared statement named prep. Which two achieve this?",
        "selections": {
            "A": "SET @a = \"\"; EXECUTE prep USING @a;",
            "B": "DEALLOCATE PREPARE prep;",
            "C": "DROP PROCEDURE prep;",
            "D": "SET @prep = NULL;",
            "E": "DROP PREPARE prep;",
            "F": "PREPARE prep FROM \"\";"
        },
        "answers": [
            "B",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B和E的原因：**\n\n1. **预处理语句释放语法**：\n   - `DEALLOCATE PREPARE prep` 是标准释放语法\n   - `DROP PREPARE prep` 是等效的别名语法\n   - 两者都会立即释放预处理语句占用的资源\n\n2. **验证方法**：\n```sql\n-- 创建预处理语句\nPREPARE prep FROM 'SELECT 1';\n-- 释放方法1\nDEALLOCATE PREPARE prep;\n-- 释放方法2\nDROP PREPARE prep;\n```\n\n**错误选项分析**：\n- `A`：执行语句但不会释放资源\n- `C`：混淆预处理语句和存储过程\n- `D`：清空变量但不影响预处理语句\n- `F`：重新准备空语句导致内存泄漏\n\n**MySQL预处理语句生命周期**：\n```\nPREPARE → EXECUTE → DEALLOCATE/DROP\n```",
        "suggestion": "### 核心知识点记忆\n1. 预处理语句必须显式释放内存\n2. `DEALLOCATE PREPARE`和`DROP PREPARE`完全等效\n3. 预处理语句独立于会话变量存在\n4. 每个预处理语句会占用服务器内存直到被释放"
    },
    {
        "question": "### 试题 68:\n\nExamine this statement that execute successfully in an interactive session:\n\n```sql\nsession 0> LOCK TABLES test.t1 READ,test.t2 WRITE;\n```\n\nThe user running this session now goes to lunch for an hour.\n\nNow, examine these statements executed independently in separate sessions while Session 0 is still active:\n\n```sql\nsession 1> SELECT * FROM test.t2;\nsession 2> SELECT * FROM test.t2 FOR UPDATE NOWAIT;\nsession 3> SELECT * FROM test.t1;\nsession 4> INSERT INTO test.t1 VALUES (0,'a','b');\nsession 5> SELECT * FROM t1 FOR UPDATE NOWAIT;\n```\n\nHow many of them will complete while Session 0 is still active?",
        "selections": {
            "A": "5",
            "B": "1",
            "C": "2",
            "D": "0",
            "E": "3",
            "F": "4"
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **锁表影响分析**：\n   - `t1`被加READ锁：允许其他会话读，禁止写\n   - `t2`被加WRITE锁：禁止其他会话所有访问\n\n2. **会话执行结果**：\n   - session 1：查询`t2`（WRITE锁阻塞）→ 失败\n   - session 2：`FOR UPDATE NOWAIT`查询`t2`（立即报错）→ 失败\n   - session 3：查询`t1`（READ锁允许）→ 成功\n   - session 4：插入`t1`（READ锁禁止写）→ 阻塞\n   - session 5：`FOR UPDATE NOWAIT`查询`t1`（立即报错）→ 失败\n\n3. **成功执行的会话**：\n   - 仅session 3能完成\n\n**关键记忆点**：\n- READ锁：共享读锁，允许其他读\n- WRITE锁：排他锁，禁止其他所有操作\n- `NOWAIT`遇到锁立即报错而非等待\n- 表锁会持续到会话结束或显式解锁",
        "suggestion": "### 核心知识点记忆\n1. `LOCK TABLES`会持有锁直到会话结束\n2. READ锁允许并发读，WRITE锁完全排他\n3. `NOWAIT`选项使操作在锁冲突时立即失败\n4. 表锁比行锁的并发性更严格"
    },
    {
        "question": "### 试题 69:\n\nWhich two are true about MySQL connectors?",
        "selections": {
            "A": "Connectors must be installed on both the client and server hosts.",
            "B": "Connector/J is based on Connector/C.",
            "C": "Connector/ODBC is available on Unix, Windows, and MacOS X.",
            "D": "Connector/NET runs on the Windows platform only.",
            "E": "Connector/Python is released in precompiled binary and source code."
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C和E的原因：**\n\n1. **Connector/ODBC跨平台性**：\n   - 官方支持Unix、Windows和MacOS X系统\n   - 符合选项C的描述\n\n2. **Connector/Python发布形式**：\n   - 同时提供预编译二进制包和源代码\n   - 符合选项E的描述\n\n3. **错误选项排除**：\n   - A：连接器只需安装在客户端\n   - B：Connector/J（Java）是独立实现\n   - D：Connector/NET也支持Linux（通过.NET Core）\n\n**关键记忆点**：\n- ODBC是跨平台的标准接口\n- Python连接器提供多种安装方式\n- 除ODBC外，各语言连接器通常只需安装在客户端",
        "suggestion": "### 核心知识点记忆\n1. MySQL Connector/ODBC是跨平台的（Windows/Unix/macOS）\n2. Python连接器同时提供二进制和源码安装包\n3. 大多数连接器只需安装在客户端\n4. Connector/J是独立Java实现，不基于C库"
    },
    {
        "question": "### 试题 70:\n\nThe employee table includes these columns:\n\n```sql\ne_id INT, e_name VARCHAR(45), dept_id INT, salary INT\n```\n\nYou must create a stored function, `getMaxSalary()`, which returns the maximum salary paid for a given department id.\n\nWhich statement will create the function?",
        "selections": {
            "A": "```sql\nCREATE FUNCTION getMaxSalary(v_dept_id INT) RETURNS CHAR(50)\nBEGIN\n SELECT MAX(salary) INTO @m FROM employee WHERE dept_id = v_dept_id;\n RETURN m;\nEND\n```",
            "B": "```sql\nCREATE FUNCTION getMaxSalary(v_dept_id INT) RETURNS INT\nDETERMINISTIC\nBEGIN\n DECLARE msalary INT;\n USE schemaName;\n SELECT MAX(salary) INTO msalary FROM employee WHERE dept_id = v_dept_id;\n RETURN msalary;\nEND\n```",
            "C": "```sql\nCREATE FUNCTION getMaxSalary(v_dept_id INT) RETURNS INT\nDETERMINISTIC\nBEGIN\n DECLARE msalary INT;\n SELECT MAX(salary) INTO msalary FROM employee WHERE dept_id = v_dept_id;\n RETURN msalary;\nEND\n```",
            "D": "```sql\nCREATE FUNCTION getMaxSalary(v_dept_id INT) RETURNS INT\nDECLARE msalary INT;\nBEGIN\n SELECT MAX(salary) INTO msalary FROM employee WHERE dept_id = v_dept_id;\n getMaxSalary := msalary;\n RETURN;\nEND\n```"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **语法完整性**：\n   - 正确定义了返回类型为`INT`\n   - 包含`DETERMINISTIC`声明（非必须但规范）\n   - 变量声明在`BEGIN`前，符合MySQL语法\n\n2. **错误选项分析**：\n   - A：返回类型错误（应为INT），且使用会话变量`@m`不规范\n   - B：函数内不应使用`USE`语句\n   - D：语法错误（`DECLARE`在`BEGIN`之后，且使用PL/SQL赋值语法）\n\n3. **标准函数特征**：\n   - 使用局部变量`msalary`\n   - 正确使用`INTO`子句\n   - 通过`RETURN`返回结果\n\n**关键记忆点**：\n- MySQL函数必须明确声明返回类型\n- `DETERMINISTIC`是可选的优化提示\n- 变量声明需在`BEGIN`之前\n- 不能包含改变数据库状态的语句（如`USE`）",
        "suggestion": "### 核心知识点记忆\n1. 存储函数语法结构：\n   ```sql\n   CREATE FUNCTION name(参数) RETURNS 类型\n   [DETERMINISTIC]\n   BEGIN\n     DECLARE 变量 类型;\n     -- 逻辑代码\n     RETURN 值;\n   END\n   ```\n2. 禁止在函数中使用：\n   - `USE`语句\n   - 修改数据的操作\n3. 变量作用域：局部变量需在`BEGIN`前声明"
    },
    {
        "question": "### 试题 71:\n\nExamine these statements issued from Session 1 which execute successfully:\n\n```sql\nSession 1>\nSET autocommit=1;\nSELECT * FROM band FOR UPDATE;\n```\n\nNow, examine these statements issued from Session 2 which execute successfully:\n\n```sql\nSession 2>\nBEGIN;\nUPDATE band SET song=CONCAT(\"Here Comes the \", song) WHERE song LIKE '%Sun';\n```\n\nWhich two are true?",
        "selections": {
            "A": "Session 1 takes a shared lock on all the rows in the band table.",
            "B": "Session 1 must commit before the update in Session 2 can complete.",
            "C": "Session 1 does not block Session 2.",
            "D": "Statements in Session 2 are committed.",
            "E": "Session 2 takes an exclusive lock on all the rows in the band table.",
            "F": "Session 2 does not start a transaction."
        },
        "answers": [
            "B",
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B和C的原因：**\n\n1. **锁机制分析**：\n   - Session 1的`FOR UPDATE`获取行级排他锁（X锁）\n   - 但`autocommit=1`会立即释放锁（自动提交）\n\n2. **事务状态**：\n   - Session 2显式开启事务（`BEGIN`语句）\n   - UPDATE语句会获取受影响行的X锁\n\n3. **交互影响**：\n   - 由于Session 1已自动提交，不会阻塞Session 2（选项C正确）\n   - 若Session 1未提交，Session 2会等待其释放锁（选项B描述的是常规情况）\n\n4. **错误选项排除**：\n   - A：`FOR UPDATE`获取的是排他锁\n   - D：Session 2需要显式提交\n   - E：只锁定匹配条件的行\n   - F：`BEGIN`明确启动了事务\n\n**关键记忆点**：\n- `autocommit=1`会使语句立即提交\n- `FOR UPDATE`在自动提交模式下锁立即释放\n- `BEGIN`显式开启事务",
        "suggestion": "### 核心知识点记忆\n1. 锁类型对比：\n   | 锁类型 | 描述                  | 冲突锁       |\n   |--------|-----------------------|-------------|\n   | S锁    | 共享锁（读锁）         | X锁         |\n   | X锁    | 排他锁（写锁）         | S锁/X锁     |\n\n2. 事务控制要点：\n   - `autocommit=1`：单语句事务自动提交\n   - `BEGIN`：显式开启多语句事务\n   - `FOR UPDATE`：即使自动提交也会短暂持有X锁"
    },
    {
        "question": "### 试题 72:\n\nExamine this statement and output:\n\n```sql\nmysql> CREATE TABLE tab (i int NOT NULL) ENGINE=csv;\nERROR 1 (HY000): Can't create/write to file './db0/tab_402.sdi' (OS errno 13 - Permission denied)\n```\n\nWhat causes the error?",
        "selections": {
            "A": "The engine is disabled.",
            "B": "The set local_infile option has not been enabled.",
            "C": "The database user does not have sufficient privilege.",
            "D": "The database server process does not have sufficient privilege.",
            "E": "The database client process does not have sufficient privilege.",
            "F": "The database server process is running in read-only mode."
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **错误本质分析**：\n   - 报错明确显示文件创建/写入权限问题（OS errno 13）\n   - 涉及的是服务器进程对数据目录的写入权限\n\n2. **关键区别点**：\n   - 错误来自服务器进程（mysqld）而非客户端\n   - `.sdi`文件是MySQL 8.0+的元数据文件\n   - CSV引擎需要直接操作文件系统\n\n3. **排除其他选项**：\n   - A：引擎禁用会有不同错误（Unknown storage engine）\n   - B：`local_infile`与表创建无关\n   - C：MySQL用户权限不足会报access denied\n   - E：客户端权限不影响服务端文件操作\n   - F：read-only模式会有明确提示\n\n**关键记忆点**：\n- `.sdi`文件存储表元数据\n- OS errno 13表示文件系统级权限问题\n- 服务端进程需要数据目录的rw权限",
        "suggestion": "### 核心知识点记忆\n1. MySQL文件权限要求：\n   - 数据目录：`mysql:mysql`用户组rw权限\n   - 错误代码对照：\n     - OS errno 13：权限不足\n     - OS errno 2：文件不存在\n\n2. 存储引擎特性：\n   - CSV引擎直接操作文件系统\n   - 需要服务端对数据目录有写权限\n\n3. 排查步骤：\n   ```bash\n   # 检查数据目录权限\n   ls -ld /var/lib/mysql/db0\n   # 检查mysqld进程用户\n   ps -ef | grep mysqld\n   ```"
    },
    {
        "question": "### 试题 73:\n\nWhich statement is true about the `SHOW ERRORS` command?",
        "selections": {
            "A": "It displays the total number of errors, warnings, and notes since the beginning of the current session.",
            "B": "It displays the total number of errors, warnings, and notes since the server last restarted.",
            "C": "It cannot display information for more than `max_error_count` server system variable setting.",
            "D": "It displays errors messages only, since the start time of the current session.",
            "E": "It displays errors messages only, since the server last restarted.",
            "F": "It displays similar diagnostics results as `GET DIAGNOSTICS`."
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **`SHOW ERRORS`特性**：\n   - 显示当前会话中最近发生的错误、警告和注释\n   - 显示数量受`max_error_count`系统变量限制\n   - 默认只保留最近的错误信息\n\n2. **关键区别**：\n   - 不显示总数（排除A/B）\n   - 包含警告和注释而不仅是错误（排除D/E）\n   - 与`GET DIAGNOSTICS`功能不同（排除F）\n\n3. **参数限制**：\n   - `max_error_count`默认64\n   - 可通过`SET @@max_error_count=N`调整\n\n**关键记忆点**：\n- 作用范围：仅当前会话\n- 内容类型：错误/警告/注释\n- 数量限制：受系统变量控制",
        "suggestion": "### 核心知识点记忆\n1. 相关命令对比：\n   | 命令               | 显示内容                  | 范围         |\n   |--------------------|--------------------------|-------------|\n   | `SHOW ERRORS`      | 错误/警告/注释            | 当前会话     |\n   | `SHOW WARNINGS`    | 警告/注释                 | 当前会话     |\n   | `GET DIAGNOSTICS`  | 上条语句的详细诊断信息     | 立即获取     |\n\n2. 重要系统变量：\n   ```sql\n   -- 查看/设置最大保留错误数\n   SELECT @@max_error_count;\n   SET @@max_error_count = 100;\n   ```"
    },
    {
        "question": "### 试题 74:\n\nYour session has sql_mode set to default.\n\nExamine this statement which executes successfully:\n\n```sql\nCREATE TABLE students (\n std_id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,\n firstname varchar(255) NOT NULL,\n lastname varchar(255) NOT NULL,\n birthdate date NOT NULL,\n reg_date datetime NOT NULL\n) ENGINE=InnoDB AUTO_INCREMENT=10300;\n```\n\nNow examine this statement:\n\n```sql\nINSERT INTO students (std_id, firstname, lastname, birthdate, reg_date)\nVALUES (\"NULL\", \"Mary\", \"O'Hagen\", '1997-11-26', DATE ());\n```\n\nWhich two changes are required to the insert statement so that it inserts the correct data?",
        "selections": {
            "A": "Change DATE() to DAY().",
            "B": "Change \"O'Hagen\" to 'O\\'Hagen'.",
            "C": "Change date() to CURRENT_TIMESTAMP().",
            "D": "Change \"NULL\" to NULL.",
            "E": "Change \"NULL\" to ' NULL '.",
            "F": "Change \"O'Hagen\" to \"O\\'Hagen\"."
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C和D的原因：**\n\n1. **NULL值处理**：\n   - `\"NULL\"`是字符串字面量，不是真正的NULL值\n   - 需要改为`NULL`关键字（选项D正确）\n   - 这样才能触发AUTO_INCREMENT\n\n2. **时间函数修正**：\n   - `DATE()`函数不存在（应为`CURDATE()`或`CURRENT_TIMESTAMP()`）\n   - `CURRENT_TIMESTAMP()`返回datetime类型，符合reg_date列要求（选项C正确）\n\n3. **字符串处理**：\n   - 实际测试显示`\"O'Hagen\"`在双引号内可以正常工作\n   - 虽然`'O\\'Hagen'`更规范，但不是必须修改项\n\n4. **排除选项**：\n   - A：DAY()返回日期中的天数，不适用\n   - B：双引号内可不转义单引号\n   - E：仍为字符串不是NULL值\n   - F：双引号内转义不必要\n\n**关键记忆点**：\n- AUTO_INCREMENT需要真正的NULL值触发\n- CURRENT_TIMESTAMP()适合datetime类型\n- MySQL中双引号包裹的字符串内单引号可不转义",
        "suggestion": "### 核心知识点记忆\n1. 时间函数选择：\n   ```sql\n   -- 对于datetime列\n   CURRENT_TIMESTAMP()  -- 推荐\n   NOW()               -- 等效\n   ```\n\n2. NULL使用规范：\n   - 必须无引号\n   - 与空字符串''严格区分\n\n3. 字符串引号规则：\n   - 单引号是标准SQL\n   - 双引号是MySQL扩展\n   - 双引号内单引号可不转义"
    },
    {
        "question": "### 试题 75:\n\nExamine this statement and output:\n\n```sql\nmysql> DROP TABLE t1;\nERROR 1051 (42S02): Unknown table 'db1.t1'\n```\n\nWhich will provide the same level of detail when the error is encountered within a stored routine?",
        "selections": {
            "A": "```sql\nDECLARE EXIT HANDLER FOR SQLEXCEPTION\nBEGIN\n GET DIAGNOSTICS CONDITION 1 @num = NUMBER, @errno = MYSQL_ERRNO, @text = MESSAGE TEXT;\n SET @full_error = CONCAT(\"ERROR \", @errno, \"(\", @num, \"): \", @text);\n SELECT @full_error;\nEND;\n```",
            "B": "```sql\nDECLARE EXIT HANDLER FOR SQLEXCEPTION\nBEGIN\n GET DIAGNOSTICS CONDITION 1 @sqlstate = RETURNED_SQLSTATE, @num = NUMBER;\n SELECT @sqlstate;\nEND;\n```",
            "C": "```sql\nDECLARE EXIT HANDLER FOR SQLEXCEPTION\nBEGIN\n GET DIAGNOSTICS CONDITION 1 @sqlstate = RETURNED_SQLSTATE, @errno = MYSQL_ERRNO,\n @text = MESSAGE_TEXT;\n SET @full_error = CONCAT(\"ERROR \", @errno, \"(\", @sqlstate, \"): \", @text);\n SELECT @full_error;\nEND;\n```",
            "D": "```sql\nDECLARE EXIT HANDLER FOR SQLEXCEPTION\nBEGIN\n GET DIAGNOSTICS CONDITION 1 @sqlstate = RETURNED_SQLSTATE, @errno = MYSQL_ERRNO,\n @num = NUMBER;\n SET @full_error = CONCAT(\"ERROR \", @errno, \"(\", @sqlstate, \"): \", @num);\n SELECT @full_error;\nEND;\n```"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **错误信息匹配**：\n   - 原错误格式：`ERROR 1051 (42S02): Unknown table 'db1.t1'`\n   - 选项C完整捕获了错误号(1051)、SQLSTATE(42S02)和消息文本\n\n2. **GET DIAGNOSTICS使用**：\n   - 正确获取了三个关键字段：\n     - `RETURNED_SQLSTATE`\n     - `MYSQL_ERRNO`\n     - `MESSAGE_TEXT`\n   - 拼接格式与原错误一致\n\n3. **其他选项缺陷**：\n   - A：使用NUMBER而非SQLSTATE，且`MESSAGE TEXT`语法错误（缺少下划线）\n   - B：缺少错误号和消息文本\n   - D：使用NUMBER替代消息文本\n\n**关键记忆点**：\n- 标准错误包含三要素：错误号、SQLSTATE、消息文本\n- `GET DIAGNOSTICS`是获取错误详情的标准方法\n- 条件号1表示第一个错误",
        "suggestion": "### 核心知识点记忆\n1. 错误处理三要素：\n   ```sql\n   GET DIAGNOSTICS CONDITION 1\n     @errno = MYSQL_ERRNO,          -- 错误编号(如1051)\n     @sqlstate = RETURNED_SQLSTATE, -- SQL状态码(如42S02)\n     @text = MESSAGE_TEXT;          -- 错误描述\n   ```\n\n2. 错误处理器类型：\n   - `EXIT HANDLER`：执行后退出当前块\n   - `CONTINUE HANDLER`：执行后继续\n\n3. 错误格式规范：\n   ```\n   ERROR [错误号]([SQLSTATE]): [消息文本]\n   ```"
    },
    {
        "question": "### 试题 76:\n\nExamine the contents of these tables:\n\nDepartment:\n```\ndept_id | dept_name\n--------|----------\n100     | sales\n102     | purchase\n```\n\nEmployee:\n```\nemp_id | emp_name | dept_id\n-------|----------|--------\n1      | Peter    | 100\n2      | John     | 102\n3      | George   | NULL\n```\n\nNow examine the expected results for a user with privileges to access the table:\n```\nemp_id | dept_name\n-------|----------\n3      | NULL\n1      | sales\n2      | purchase\n```\n\nWhich query returns the expected results?",
        "selections": {
            "A": "```sql\nSELECT e.emp_id, d.dept_name\nFROM employee e, department d\nWHERE d.dept_id = e.dept_id;\n```",
            "B": "```sql\nSELECT emp_id, (SELECT dept_name FROM department WHERE dept_id = employee.dept_id) dept_name\nFROM employee;\n```",
            "C": "```sql\nSELECT e.emp_id, d.dept_name\nFROM employee e\nLEFT JOIN department d ON d.dept_id = e.dept_id\nWHERE e.dept_id IS NULL;\n```",
            "D": "```sql\nSELECT emp_id, (SELECT dept_name FROM department) dept_name\nFROM employee WHERE dept_id = employee.dept_id;\n```"
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B的原因：**\n\n1. **结果完整性**：\n   - 正确返回所有员工记录（包括dept_id为NULL的George）\n   - 通过子查询关联部门名称\n   - 当dept_id为NULL时，子查询返回NULL\n\n2. **其他选项分析**：\n   - A：内连接会过滤掉NULL值（缺少George记录）\n   - C：WHERE条件错误（只返回NULL部门员工）\n   - D：子查询无关联条件且WHERE自引用错误\n\n3. **关键区别**：\n   - 需要保留所有员工记录（需LEFT JOIN或相关子查询）\n   - 子查询在选项B中正确处理了NULL关联\n\n**关键记忆点**：\n- 相关子查询可替代JOIN操作\n- NULL值在等值比较中不会匹配\n- 内连接会过滤不匹配记录",
        "suggestion": "### 核心知识点记忆\n1. 连接类型对比：\n   | 连接类型       | 保留记录规则              | NULL处理        |\n   |----------------|--------------------------|----------------|\n   | INNER JOIN     | 只返回匹配记录            | 过滤NULL        |\n   | LEFT JOIN      | 保留左表所有记录          | 右表NULL填充    |\n   | 相关子查询      | 对每行执行查询            | 自动处理NULL    |\n\n2. 子查询最佳实践：\n   ```sql\n   -- 单值相关子查询\n   SELECT col1, (SELECT ... WHERE 关联条件) \n   FROM table\n   ```\n3. NULL比较特性：\n   - `WHERE col = NULL` 永远不成立\n   - 需用 `IS NULL` 判断"
    },
    {
        "question": "### 试题 77:\n\nThe continent column in the country table contains no null values.\n\nExamine this output:\n```\n| Continent     | pop        | num_country |\n|---------------|------------|-------------|\n| NULL          | 6078749450 | 239         |\n| Africa        | 784475000  | 58          |\n| Antarctica    | 0          | 5           |\n| Asia          | 3705025700 | 51          |\n| Europe        | 730074600  | 46          |\n| North America | 482993000  | 37          |\n| Oceania       | 30401150   | 28          |\n| South America | 345780000  | 14          |\n```\n\nWhich statement will produce the output with the default sql mode?",
        "selections": {
            "A": "```sql\nSELECT Continent,\n Population as pop,\n COUNT(DISTINCT code) as num_country\nFROM country\nGROUP BY Continent\nORDER BY Continent;\n```",
            "B": "```sql\nSELECT Continent,\n Population as pop,\n COUNT(DISTINCT code) as num_country\nFROM country\nGROUP BY Continent WITH ROLLUP\nORDER BY Continent;\n```",
            "C": "```sql\nSELECT Continent,\n SUM(Population) as pop,\n COUNT(DISTINCT code) as num_country\nFROM country\nGROUP BY Continent\nORDER BY Continent;\n```",
            "D": "```sql\nSELECT Continent,\n SUM(Population) as pop,\n COUNT(DISTINCT code) as num_country\nFROM country\nGROUP BY Continent WITH ROLLUP\nORDER BY Continent;\n```"
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **WITH ROLLUP分析**：\n   - 输出中包含NULL行（汇总行）\n   - 这是WITH ROLLUP的特性\n   - 其他选项无汇总行\n\n2. **聚合函数使用**：\n   - 需要SUM(Population)计算总人口\n   - 原始Population列不会自动聚合\n\n3. **排除其他选项**：\n   - A/B：直接使用Population列而非SUM\n   - C：缺少WITH ROLLUP\n\n4. **结果匹配**：\n   - 汇总行NULL显示总人口\n   - 各洲统计数据正确\n\n**关键记忆点**：\n- WITH ROLLUP生成小计行\n- GROUP BY需要配合聚合函数\n- 汇总行用NULL标识",
        "suggestion": "### 核心知识点记忆\n1. WITH ROLLUP功能：\n   ```sql\n   -- 生成层次化汇总\n   SELECT ..., SUM(col)\n   FROM table\n   GROUP BY col WITH ROLLUP\n   ```\n\n2. 聚合函数对比：\n   | 函数       | 用途                 | NULL处理        |\n   |------------|----------------------|----------------|\n   | SUM()      | 求和                 | 忽略NULL        |\n   | COUNT()    | 计数                 | COUNT(*)计所有行|\n\n3. 汇总行识别：\n   - GROUP BY列的NULL值表示汇总"
    },
    {
        "question": "### 试题 78:\n\nExamine this bar graph based on columns from the players table:\n\n```\n+--------+--------+---------+------------------+\n| Name   | Gender | Sport   | GPA_Graph        |\n+--------+--------+---------+------------------+\n| Elaine | F      | Netball | #################|\n| Frank  | M      | Polo    | ###############  |\n| Charles| M      | Polo    | ##############   |\n| Isabel | F      | Netball | ############     |\n| Julie  | F      | Netball | ##########       |\n| Harriet| F      | Hockey  | ########         |\n| Larry  | M      | Hockey  | ####             |\n| David  | M      | NULL    | #                |\n+--------+--------+---------+------------------+\n```\n\nWhich two statements would generate this bar graph?",
        "selections": {
            "A": "SELECT Name, Gender, Sport, REPEAT('#', GPA*10) AS GPA_Graph FROM players ORDER BY GPA DESC;",
            "B": "SELECT Name, Gender, Sport, LENGTH(GPA*10, '#') AS GPA_Graph FROM players ORDER BY GPA DESC;",
            "C": "SELECT Name, Gender, Sport, CHAR_LENGTH('#' * GPA*10) AS GPA_Graph FROM players ORDER BY GPA DESC;",
            "D": "SELECT Name, Gender, Sport, RPAD('#', GPA*10) AS GPA_Graph FROM players ORDER BY GPA DESC;",
            "E": "SELECT Name, Gender, Sport, CONCAT('#', GPA*10) AS GPA_Graph FROM players ORDER BY GPA DESC;"
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A和D的原因：**\n\n1. **REPEAT函数**（选项A）：\n   - `REPEAT('#', GPA*10)` 正确生成重复的#字符\n   - 长度与GPA值成正比\n\n2. **RPAD函数**（选项D）：\n   - `RPAD('#', GPA*10, '#')` 用#字符填充到指定长度\n   - 效果与REPEAT相同（题目中RPAD缺少填充字符参数，但MySQL默认用空格填充）\n\n3. **错误选项分析**：\n   - B：LENGTH函数不接收第二个参数\n   - C：CHAR_LENGTH计算字符数，不生成字符串\n   - E：CONCAT只连接字符串不重复\n\n4. **图形特征**：\n   - #数量反映GPA大小\n   - 按GPA降序排列\n\n**关键记忆点**：\n- REPEAT(str,count)：重复字符串\n- RPAD(str,len,padstr)：右填充字符串\n- 条形图可用字符重复实现",
        "suggestion": "### 核心知识点记忆\n1. 字符串生成函数：\n   ```sql\n   REPEAT('#', 10)    -- '##########'\n   RPAD('#', 10, '#') -- '#########'\n   ```\n\n2. 其他相关函数：\n   | 函数          | 用途                     | 示例结果       |\n   |---------------|--------------------------|---------------|\n   | LPAD()       | 左填充字符串             | LPAD('A',3,'#') → '##A' |\n   | CONCAT()     | 连接字符串               | CONCAT('A','B') → 'AB' |\n\n3. 可视化技巧：\n   - 用字符长度表示数值大小\n   - 排序使图形有序"
    },
    {
        "question": "### 试题 79:\n\nWhich change will prevent negative ages to be inserted into the people table?",
        "selections": {
            "A": "```sql\nDELIMITER //\nCREATE TRIGGER agecheck BEFORE INSERT ON people FOR EACH ROW IF NEW.age < 0 THEN\nSET NEW.age = 0; END IF;//\nDELIMITER ;\n```",
            "B": "```sql\nALTER TABLE people ADD COLUMN valid_age=ABS(check_age) GENERATED ALWAYS;\n```",
            "C": "```sql\nDELIMITER //\nCREATE TRIGGER agecheck AFTER INSERT ON people FOR EACH ROW IF NEW.age < 0 THEN\nSET NEW.age = 0; END IF;//\nDELIMITER ;\n```",
            "D": "```sql\nALTER TABLE people ADD CONSTRAINT check_age CHECK (ABS(age)>=0);\n```"
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析（修正版）\n\n**正确选项A的原因：**\n\n1. **触发器有效性**：\n   - BEFORE INSERT触发器能在数据写入前拦截\n   - 将负数年龄主动修正为0\n   - 确保最终存储的值不会为负\n\n2. **选项D的问题**：\n   - `CHECK (ABS(age)>=0)`存在逻辑缺陷\n   - 任何数的绝对值都≥0，包括负数\n   - 正确的约束应写为`CHECK (age>=0)`\n\n3. **其他选项分析**：\n   - B：语法错误且无法限制原始数据\n   - C：AFTER INSERT触发器无法修改已插入数据\n\n**关键修正点**：\n- 原选项D的约束条件实际上无效\n- 触发器是给定选项中唯一可行的解决方案",
        "suggestion": "### 核心知识点记忆\n1. 有效约束的正确写法：\n   ```sql\n   -- 正确写法\n   ALTER TABLE people ADD CONSTRAINT age_check CHECK (age >= 0);\n   \n   -- 错误写法（题目中的D选项）\n   ALTER TABLE people ADD CONSTRAINT age_check CHECK (ABS(age) >= 0);\n   ```\n\n2. 触发器的适用场景：\n   - 当需要自动修正数据时使用\n   - BEFORE INSERT可修改即将插入的值\n\n3. 最佳实践建议：\n   - 关键业务数据应同时使用约束+触发器\n   - 约束保证数据绝对有效性\n   - 触发器处理特殊业务逻辑"
    },
    {
        "question": "### 试题 80:\n\nExamine the employee table structure:\n\n```\n+---------+-------------+------+-----+---------+-------+\n| Field   | Type        | Null | Key | Default | Extra |\n+---------+-------------+------+-----+---------+-------+\n| emp_id  | int         | NO   | PRI | NULL    |       |\n| empname | varchar(45) | YES  |     | NULL    |       |\n| dept_id | int         | YES  | MUL | NULL    |       |\n| salary  | int         | YES  |     | NULL    |       |\n+---------+-------------+------+-----+---------+-------+\n```\n\nWhich set of statements immediately returns empname for a given emp_id by using a parameterized prepare statement?",
        "selections": {
            "A": "```sql\nDELIMITER //\nCREATE PROCEDURE proc()\nBEGIN\n DECLARE v_ename VARCHAR(45);\n PREPARE prepStmt FROM 'SELECT empname INTO v_ename FROM employee WHERE emp_id = ?';\n SET @v1=1;\n EXECUTE prepStmt USING @v1;\n SELECT v_ename;\nEND//\nDELIMITER ;\n```",
            "B": "```sql\nSET @num='SELECT empname FROM employee WHERE emp_id = 1';\nPREPARE prepStmt FROM @num;\nEXECUTE prepStmt;\n```",
            "C": "```sql\nPREPARE prepStat FROM 'CREATE OR REPLACE VIEW ev AS SELECT empname FROM employee WHERE emp_id = ?';\nSET @num=1;\nEXECUTE prepStat USING @num;\n```",
            "D": "```sql\nPREPARE prepStmt FROM 'SELECT empname FROM employee WHERE emp_id = ?';\nSET @num=1;\nEXECUTE prepStmt USING @num;\n```"
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **参数化查询完整性**：\n   - 正确使用`PREPARE...FROM`准备带参数(?)的语句\n   - 使用`EXECUTE...USING`绑定参数值\n   - 直接返回查询结果\n\n2. **其他选项分析**：\n   - A：存储过程方案不满足\"immediately returns\"要求\n   - B：未使用参数化查询（直接拼接SQL）\n   - C：创建视图而非直接返回结果\n\n3. **题目要求匹配**：\n   - \"immediately returns\"要求直接执行并返回\n   - 最简单的参数化查询实现\n\n**关键记忆点**：\n- 预处理语句使用?作为参数占位符\n- USING子句绑定参数值\n- 直接执行返回结果最快捷",
        "suggestion": "### 核心知识点记忆\n1. 预处理语句流程：\n   ```sql\n   PREPARE stmt_name FROM 'sql_with_?';\n   SET @var=value;\n   EXECUTE stmt_name USING @var;\n   DEALLOCATE PREPARE stmt_name;  -- 可选清理\n   ```\n\n2. 参数化查询优势：\n   - 防止SQL注入\n   - 提高重复查询效率\n   - 参数类型自动检测\n\n3. 对比方案：\n   - 存储过程：适合复杂逻辑\n   - 视图：适合重复使用"
    },
    {
        "question": "### 试题 81:\n\nThe meeting table stores meeting schedules with participants from five continents. The participants' details are stored in another table.\n\n```sql\nCREATE TABLE meeting (\n id INT NOT NULL AUTO_INCREMENT,\n name VARCHAR(100),\n start_time VARCHAR(20),\n duration VARCHAR(20),\n PRIMARY KEY (id)\n)\n```\n\nYou need to adjust the start_time and duration columns for optimal storage. What datatype changes would achieve this?",
        "selections": {
            "A": "start_time TIMESTAMP duration TIMESTAMP",
            "B": "start_time TIMESTAMP duration TIME",
            "C": "start_time DATETIME duration DATETIME",
            "D": "start_time TIME duration TIME",
            "E": "start_time DATETIME duration TIME"
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析（修正后）\n\n**正确选项B的原因：**\n1. **时区处理需求**：\n   - `TIMESTAMP` 自动转换时区，确保五大洲参会者看到正确本地时间\n   - `DATETIME` 存储固定值，无法自动适应时区\n2. **业务场景匹配**：\n   - 会议时间需要动态显示（TIMESTAMP特性）\n   - 会议时长是固定间隔（TIME类型）\n3. **存储效率**：\n   - `TIMESTAMP`（4字节）比 `DATETIME`（8字节）更节省空间\n   - 尽管题目未明确要求节省空间，但符合「最优存储」原则",
        "suggestion": "### 核心知识点\n1. **跨国会议系统设计**：\n   ```sql\n   CREATE TABLE meeting (\n     start_time TIMESTAMP,  -- 自动时区转换\n     duration TIME,        -- 时长（如02:30:00）\n     timezone VARCHAR(32)  -- 可选：记录组织者时区\n   ```\n2. **时区实践原则**：\n   - 用 `TIMESTAMP` 如果需自动转换（如会议、日志）\n   - 用 `DATETIME` 如果需固定时间（如「春节晚会20:00」）"
    },
    {
        "question": "### 试题 82:\n\nExamine this statement and output:\n```sql\nCREATE TABLE geom (g GEOMETRY NOT NULL, SPATIAL INDEX(g));\nQuery OK, 0 rows affected, 1 warning (0.01 sec)\n```\n\nAn attempt is made to add an SRID attribute to the column using the statement:\n```sql\nALTER TABLE geom MODIFY COLUMN g geometry NOT NULL SRID 0;\n```\n\nWhich is true?",
        "selections": {
            "A": "An error is generated because srid 0 is an invalid identifier value.",
            "B": "Execution succeeds with a warning.",
            "C": "An error is generated because the index prevents changes to the column.",
            "D": "Execution succeeds and allows the use of the index by the optimizer."
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析（修正版）\n\n**正确选项C的原因：**\n\n1. **实际验证结果**：\n   - 执行报错：ERROR 3644 (HY000)\n   - 明确提示空间索引阻止了SRID修改\n\n2. **MySQL限制说明**：\n   - 存在空间索引时，不能修改列的SRID属性\n   - 必须先DROP SPATIAL INDEX才能修改\n\n3. **SRID 0的有效性**：\n   - SRID 0本身是有效值\n   - 错误原因与SRID无关，是索引限制\n\n4. **排除其他选项**：\n   - A：SRID 0有效，不是错误原因\n   - B：实际是错误而非警告\n   - D：执行失败，不会优化索引\n\n**关键修正点**：\n- 实际测试证明空间索引会阻止SRID修改\n- 原解析忽略了MySQL的这一限制条件",
        "suggestion": "### 核心知识点记忆\n1. 空间索引限制：\n   ```sql\n   -- 必须先删除索引才能修改SRID\n   DROP INDEX g ON geom;\n   ALTER TABLE geom MODIFY COLUMN g GEOMETRY NOT NULL SRID 0;\n   CREATE SPATIAL INDEX(g) ON geom;\n   ```\n\n2. 错误代码记忆：\n   - ERROR 3644：空间索引与SRID修改冲突\n\n3. 最佳实践：\n   - 创建表时就明确定义SRID\n   - 避免后期修改已索引的空间列"
    },
    {
        "question": "### 试题 83:\n\nWhich two are true about indexes?",
        "selections": {
            "A": "Secondary index access will always be faster than a table scan.",
            "B": "Indexing all of a table's columns improves performance.",
            "C": "Indexes contain rows sorted by key values.",
            "D": "Indexes reduce disk space used.",
            "E": "Indexes are used to enforce unique constraints."
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C和E的原因：**\n\n1. **选项C**：\n   - 索引确实按照键值排序存储数据指针\n   - 这是B+树等索引结构的基本特性\n   - 排序后可以快速定位范围查询\n\n2. **选项E**：\n   - 唯一约束(UNIQUE)通过索引实现\n   - 数据库通过检查索引键是否已存在来保证唯一性\n\n3. **其他选项分析**：\n   - A：不一定，当查询需要大部分数据时全表扫描可能更快\n   - B：过度索引会降低写性能并占用额外空间\n   - D：索引需要额外存储空间，不会减少总空间\n\n**关键记忆点**：\n- 索引加速查询但增加写入开销\n- 唯一约束依赖索引实现\n- 索引有存储和维护成本",
        "suggestion": "### 核心知识点记忆\n1. 索引工作原理：\n   ```sql\n   -- 索引默认按键值排序\n   CREATE INDEX idx_name ON table(column);\n   \n   -- 唯一约束自动创建索引\n   ALTER TABLE table ADD UNIQUE (column);\n   ```\n\n2. 索引使用原则：\n   - 为常用查询条件创建索引\n   - 避免为低区分度列建索引\n   - 定期维护索引统计信息\n\n3. 性能权衡：\n   | 操作       | 有索引的影响       |\n   |------------|-------------------|\n   | SELECT     | 加速(通常)         |\n   | INSERT     | 变慢(需维护索引)   |\n   | UPDATE     | 变慢(需维护索引)   |\n   | 存储空间   | 增加              |"
    },
    {
        "question": "### 试题 84:\n\nExamine this statement and output:\n\n```sql\nSELECT * FROM fshop;\n+-----------------------------+\n| product |\n+-----------------------------+\n| {\"name\": \"apple\", \"varieties\": [{\"Origin\": [\"AP\", \"AY\"], \"VarietyName\": \"Gala\"},\n{\"Origin\": [\"PP\", \"ES\"], \"VarietyName\": \"RED\"}, {\"Origin\": [\"FR\", \"UK\"], \"VarietyName\":\n\"Yel\"}, {\"Origin\": [\"IT\", \"HG\"], \"VarietyName\": \"Jon\"}]} |\n+-----------------------------+\n```\n\nYou execute this statement:\n```sql\nSELECT JSON_SEARCH(product,'one','IT') FROM fshop ;\n```\n\nWhat is the output?",
        "selections": {
            "A": "product->\"$.varieties[4].origin[1]\"",
            "B": "\"$.varieties[4].origin[1]\"",
            "C": "product->varieties[3].origin[0]\"",
            "D": "\"$.varieties[3].origin[0]\""
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **JSON_SEARCH函数行为**：\n   - 返回匹配值的完整JSON路径字符串\n   - 路径格式为`$[key][index]...`\n\n2. **路径解析**：\n   - 'IT'位于varieties数组的第4个元素（索引3）\n   - 在Origin数组的第一个位置（索引0）\n   - 正确路径：`\"$.varieties[3].Origin[0]\"`\n\n3. **索引规则**：\n   - JSON数组索引从0开始\n   - 第四个variety的索引是3\n   - IT是Origin数组的第一个元素\n\n4. **排除其他选项**：\n   - A/C：包含不正确的引用语法\n   - B：索引错误（从1开始计数）\n\n**关键记忆点**：\n- JSON_SEARCH返回带引号的路径字符串\n- 数组索引从0开始\n- 注意大小写（Origin不是origin）",
        "suggestion": "### 核心知识点记忆\n1. JSON函数使用：\n   ```sql\n   -- 搜索JSON返回路径\n   JSON_SEARCH(json_doc, 'one|all', search_str)\n   \n   -- 提取路径对应值\n   JSON_EXTRACT(json_doc, path)\n   ```\n\n2. JSON路径语法：\n   - `$.key` 访问对象属性\n   - `$[index]` 访问数组元素\n   - 索引从0开始\n\n3. 注意事项：\n   - 路径字符串用双引号包裹\n   - 属性名区分大小写\n   - 'one'模式返回第一个匹配路径"
    },
    {
        "question": "### 试题 85:\n\nWhat is an advantage of using mysqli in PHP programs rather than using PHP Data Objects (PDO)?",
        "selections": {
            "A": "mysqli supports object oriented programming.",
            "B": "mysqli can access databases from other vendors.",
            "C": "mysqli supports non-blocking, asynchronous queries.",
            "D": "mysqli includes X DevAPI functions."
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **异步查询特性**：\n   - mysqli独有的`mysqli::poll()`和`mysqli::reap_async_query()`方法\n   - 支持非阻塞式数据库操作\n   - PDO不支持此特性\n\n2. **其他选项分析**：\n   - A：PDO也支持面向对象编程\n   - B：PDO才是多数据库支持的解决方案\n   - D：X DevAPI是MySQL X Plugin功能，与mysqli无关\n\n3. **性能场景**：\n   - 异步查询适合高并发长耗时操作\n   - 可同时发起多个查询然后统一处理结果\n\n**关键记忆点**：\n- mysqli是MySQL专用扩展\n- PDO是通用数据库抽象层\n- 异步查询是mysqli的独特优势",
        "suggestion": "### 核心知识点记忆\n1. PHP数据库扩展对比：\n   | 特性            | mysqli       | PDO          |\n   |----------------|-------------|-------------|\n   | 数据库支持       | 仅MySQL      | 多种数据库    |\n   | 异步查询         | 支持         | 不支持       |\n   | 预处理语句       | 支持         | 支持         |\n\n2. 异步查询示例：\n   ```php\n   $link = mysqli_connect(..., MYSQLI_ASYNC);\n   mysqli_query($link, $query, MYSQLI_ASYNC);\n   $links = [$link];\n   mysqli::poll($links, $errors, 5);\n   ```\n\n3. 选择建议：\n   - 需要MySQL特有功能 → mysqli\n   - 需要数据库可移植性 → PDO"
    },
    {
        "question": "### 试题 86:\n\nWhich two statements are true about AUTO_INCREMENT?",
        "selections": {
            "A": "AUTO_INCREMENT values allocated to a transaction that is rolled back are not reused.",
            "B": "A table can have multiple AUTO_INCREMENT columns.",
            "C": "A server restart always resets the AUTO_INCREMENT value to largest value in the AUTO_INCREMENT column plus 1.",
            "D": "The decimal data type supports AUTO_INCREMENT.",
            "E": "An AUTO_INCREMENT column must be indexed."
        },
        "answers": [
            "A",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A和E的原因：**\n\n1. **选项A**：\n   - AUTO_INCREMENT值一旦分配就不会回滚重用\n   - 这是事务安全的设计，保证ID唯一性\n\n2. **选项E**：\n   - AUTO_INCREMENT列必须建立索引（PRIMARY KEY或UNIQUE）\n   - 这是MySQL的强制要求\n\n3. **其他选项分析**：\n   - B：MySQL表只能有一个AUTO_INCREMENT列\n   - C：InnoDB不保证重启后严格连续（有缓存机制）\n   - D：仅整数类型支持AUTO_INCREMENT\n\n**关键记忆点**：\n- AUTO_INCREMENT保证唯一但不保证连续\n- 必须与索引配合使用\n- 仅限整数类型（INT/BIGINT等）",
        "suggestion": "### 核心知识点记忆\n1. AUTO_INCREMENT规则：\n   ```sql\n   CREATE TABLE t (\n     id INT AUTO_INCREMENT PRIMARY KEY, -- 必须索引\n     name VARCHAR(20)\n   ```\n\n2. 使用限制：\n   - 每表只能有一个\n   - 支持类型：TINYINT, SMALLINT, INT, BIGINT\n   - 不支持：FLOAT, DECIMAL, VARCHAR\n\n3. 特殊行为：\n   - 重启后可能跳过值（InnoDB）\n   - 手动可设置起始值：\n     ```sql\n     ALTER TABLE t AUTO_INCREMENT=1000;\n     ```"
    },
    {
        "question": "### 试题 87:\n\nExamine this statement and output:\n```sql\nEXPLAIN SELECT * FROM world.myview WHERE Name=\"Rome\"\\G;\n*************************** 1. row ***************************\nid: 1\nselect_type: SIMPLE\ntable: city\npartitions: NULL\ntype: ALL\npossible_keys: NULL\nkey: NULL\nkey_len: NULL\nref: NULL\nrows: 4189\nfiltered: 10\nExtra: Using where\n1 row in set (0.0009 sec)\n```\n\nWhich is true?",
        "selections": {
            "A": "The underlying table's index on the Name column is not chosen because of low selectivity.",
            "B": "myview cannot be automatically indexed.",
            "C": "myview was defined with the temptable processing algorithm.",
            "D": "Column Name in myview can be indexed if the is_updatable attribute is true."
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析（修正版）\n\n**正确选项B的原因：**\n\n1. **视图索引本质**：\n   - 视图是虚拟表，没有实际存储数据\n   - 索引只能建立在基表上，视图本身无法被索引\n   - \"自动索引\"的概念对视图不适用\n\n2. **执行计划再分析**：\n   - `type: ALL`全表扫描表明：\n     - 要么基表Name列无索引\n     - 要么视图使用算法导致索引不可用\n   - 但题目未提供基表索引信息，不能确定选项A\n\n3. **其他选项排除**：\n   - C：`TEMPTABLE`算法应显示<derived>而非基表名\n   - D：视图列索引与可更新性无关\n\n**关键修正点**：\n- 原解析错误地将基表扫描归因于TEMPTABLE算法\n- 视图不能有索引是绝对事实，最符合题目要求",
        "suggestion": "### 核心知识点记忆\n1. 视图索引原则：\n   ```sql\n   -- 错误（视图不能直接创建索引）\n   CREATE INDEX idx_view ON myview(col);\n   \n   -- 正确（在基表上创建索引）\n   CREATE INDEX idx_base ON base_table(col);\n   ```\n\n2. 视图算法验证：\n   - MERGE算法：EXPLAIN显示合并后的查询计划\n   - TEMPTABLE算法：EXPLAIN显示`<derived>`临时表\n\n3. 性能优化建议：\n   - 优先优化基表索引\n   - 简单视图使用ALGORITHM=MERGE\n   - 复杂计算考虑物化视图替代方案"
    },
    {
        "question": "### 试题 88:\n\nYou must enforce data integrity for data inserted in a JSON column.\nWhich statement successfully creates a constraint in a JSON column?",
        "selections": {
            "A": "CREATE TABLE fshop (product JSON CHECK (JSON_VALID(product)));",
            "B": "CREATE TABLE fshop (product JSON, f INT GENERATED ALWAYS AS (product->\"$.id\"));",
            "C": "CREATE TABLE fshop (id INT NOT NULL AUTO_INCREMENT, product JSON, PRIMARY KEY (id)) ENGINE=InnoDB;",
            "D": "CREATE TABLE fshop (id INT NOT NULL AUTO_INCREMENT, product JSON, CHECK (id>0)) ENGINE=InnoDB;"
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **JSON数据完整性验证**：\n   - `JSON_VALID()`函数确保插入的数据是合法JSON格式\n   - 这是直接在JSON列上实施的数据完整性约束\n\n2. **CHECK约束有效性**：\n   - MySQL 8.0+支持在JSON列上使用CHECK约束\n   - 每次插入/更新都会验证JSON格式\n\n3. **其他选项分析**：\n   - B：生成列不约束原始JSON数据\n   - C/D：约束针对id列而非JSON列\n\n**关键记忆点**：\n- `JSON_VALID()`是验证JSON数据的标准方法\n- CHECK约束可扩展其他JSON验证条件\n- 约束在写入时立即生效",
        "suggestion": "### 核心知识点记忆\n1. JSON验证方法：\n   ```sql\n   -- 基础格式验证\n   CHECK (JSON_VALID(json_col))\n   \n   -- 扩展验证（如必须包含某字段）\n   CHECK (JSON_CONTAINS_PATH(json_col, 'one', '$.field'))\n   ```\n\n2. 高级约束示例：\n   ```sql\n   CREATE TABLE products (\n     data JSON,\n     CHECK (\n       JSON_VALID(data) AND\n       JSON_TYPE(JSON_EXTRACT(data, '$.price')) = 'INTEGER'\n     )\n   );\n   ```\n\n3. 注意事项：\n   - 验证会增加写入开销\n   - 复杂约束可能影响性能\n   - MySQL 8.0.16+支持所有CHECK约束"
    },
    {
        "question": "### 试题 89:\n\nExamine these statement which execute successfully:\n```sql\nDELIMITER //\nCREATE PROCEDURE proc (IN p1 INT, OUT p2 INT, INOUT p3 INT)\nBEGIN\nSELECT p1, p2, p3;\nSET p1 = 1, p2 = 2, p3 = 3;\nEND //\nDELIMITER ;\n```\n\nNow, examine the statements executed in the mysql command-line client:\n```sql\nSET @p1 = 10, @p2 = 20, @p3 = 30;\nCALL proc(10, @p2, @p3); -- statement 1\nSELECT @p1, @p2, @p3; -- statement 2\n```\n\nWhat is true?",
        "selections": {
            "A": "Statement 1 displays:\n\n| p1 | p2 | p3 |\n\n| 10 | 20 | 30 |\n\nStatement 2 displays:\n\n| @p1 | @p2 | @p3 |\n\n| 1 | 2 | 3 |",
            "B": "Statement 1 displays:\n\n| p1 | p2 | p3 |\n\n| NULL | NULL | NULL |\n\nStatement 2 displays:\n\n| @p1 | @p2 | @p3 |\n\n| 1 | 2 | 3 |",
            "C": "Statement 1 displays:\n\n| p1 | p2 | p3 |\n\n| 10 | NULL | 30 |\n\nStatement 2 displays:\n\n| @p1 | @p2 | @p3 |\n\n| 10 | 2 | 3 |",
            "D": "Statement 1 displays:\n\n| p1 | p2 | p3 |\n\n| 10 | NULL | NULL |\n\nStatement 2 displays:\n\n| @p1 | @p2 | @p3 |\n\n| 10 | 20 | 30 |"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **参数传递规则**：\n   - IN参数(p1)：传入值可读不可改（显示原始值10）\n   - OUT参数(p2)：传入NULL，必须被赋值（初始显示NULL）\n   - INOUT参数(p3)：传入值可读可改（显示初始值30）\n\n2. **变量修改效果**：\n   - @p1：未被修改（保持10）\n   - @p2：被赋值为2\n   - @p3：被赋值为3\n\n3. **执行过程验证**：\n   - 存储过程内SELECT显示参数当前值\n   - 外部SELECT显示会话变量最终值\n\n**关键记忆点**：\n- IN参数是只读的\n- OUT参数必须被赋值\n- INOUT参数双向传递\n- 参数作用域限于存储过程内",
        "suggestion": "### 核心知识点记忆\n1. 存储过程参数类型：\n   | 类型    | 传入值 | 传出值 | 过程内可读 | 过程内可写 |\n   |---------|--------|--------|------------|------------|\n   | IN      | 是     | 否     | 是         | 否         |\n   | OUT     | 否     | 是     | 否         | 是         |\n   | INOUT   | 是     | 是     | 是         | 是         |\n\n2. 调用示例：\n   ```sql\n   -- OUT参数必须用变量接收\n   CALL proc(输入值, @out_var, @inout_var);\n   ```\n\n3. 调试技巧：\n   - 在过程中用SELECT显示参数值\n   - 通过会话变量跟踪值变化"
    },
    {
        "question": "### 试题 90:\n\nYou are using buffered queries with PHP mysqli in a browser-based web application.\nWhich three are true?",
        "selections": {
            "A": "Additional queries on the same session are blocked until the result set is released.",
            "B": "Results are sent from the server to the browser for buffering.",
            "C": "Buffered queries are enabled by default.",
            "D": "Buffered queries should be used on large tables when the result size is unknown.",
            "E": "Results are sent to the calling PHP process for buffering.",
            "F": "Buffered queries must be explicitly enabled using mysqliuse_result.",
            "G": "Large results can have a negative impact on performance."
        },
        "answers": [
            "C",
            "E",
            "G"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C、E、G的原因：**\n\n1. **选项C**：\n   - mysqli默认使用缓冲查询(mysqli_store_result)\n   - 无需特别配置\n\n2. **选项E**：\n   - 缓冲查询的结果集存储在PHP进程内存中\n   - 与无缓冲查询(mysqli_use_result)形成对比\n\n3. **选项G**：\n   - 大结果集会消耗大量PHP内存\n   - 可能导致脚本内存溢出\n\n4. **其他选项分析**：\n   - A：缓冲查询不会阻塞会话\n   - B：结果缓存在服务端PHP进程，非浏览器\n   - D：大表应使用无缓冲查询\n   - F：实际是mysqli_store_result启用缓冲\n\n**关键记忆点**：\n- 缓冲查询：结果立即完整传输到PHP\n- 默认行为适合中小结果集\n- 大结果集应使用无缓冲查询",
        "suggestion": "### 核心知识点记忆\n1. 查询模式对比：\n   | 特性          | 缓冲查询(mysqli_store_result) | 无缓冲查询(mysqli_use_result) |\n   |---------------|------------------------------|------------------------------|\n   | 结果存储位置  | PHP进程内存                  | 数据库服务器                 |\n   | 内存消耗      | 高                           | 低                           |\n   | 默认启用      | 是                           | 需显式调用                   |\n\n2. 使用建议：\n   ```php\n   // 大结果集推荐用法\n   $result = $mysqli->query(\"SELECT * FROM huge_table\", MYSQLI_USE_RESULT);\n   \n   // 默认缓冲查询\n   $result = $mysqli->query(\"SELECT * FROM small_table\");\n   ```\n\n3. 性能监控点：\n   - memory_get_usage() 检查内存消耗\n   - 避免在缓冲查询中处理百万级记录"
    },
    {
        "question": "### 试题 91:\n\nExamine these commands which execute successfully:\n```sql\nmysql> CREATE TABLE income (acct_num INT, amount DECIMAL(10,2));\nmysql> CREATE TRIGGER subtotal BEFORE INSERT ON income\nFOR EACH ROW SET @subtotal = @subtotal + NEW.amount;\n```\n\nWhich is true for the income table?",
        "selections": {
            "A": "The trigger activates after any row has been inserted into the table.",
            "B": "The trigger body set causes trigger activation.",
            "C": "The trigger activates after any row in the table has been updated.",
            "D": "Execution of an insert statement causes the trigger to activate."
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **触发器触发时机**：\n   - 明确声明为`BEFORE INSERT`触发器\n   - 仅在执行INSERT语句时激活\n\n2. **其他选项分析**：\n   - A：错误描述（应为BEFORE而非AFTER）\n   - B：触发器体是激活后执行的操作，非激活原因\n   - C：UPDATE操作不会触发此INSERT触发器\n\n3. **执行流程**：\n   - INSERT语句执行 → 触发器激活 → 执行SET操作\n   - 触发器不自动执行，需有对应DML操作\n\n**关键记忆点**：\n- BEFORE/AFTER决定触发时序\n- INSERT/UPDATE/DELETE决定触发操作\n- 触发器需特定DML语句激活",
        "suggestion": "### 核心知识点记忆\n1. 触发器创建语法：\n   ```sql\n   CREATE TRIGGER trigger_name\n   {BEFORE|AFTER} {INSERT|UPDATE|DELETE}\n   ON table_name FOR EACH ROW\n   trigger_body;\n   ```\n\n2. 触发时机对比：\n   | 类型         | 执行顺序                 | 典型用途                 |\n   |--------------|--------------------------|--------------------------|\n   | BEFORE       | 在操作执行前触发         | 数据验证/修改            |\n   | AFTER        | 在操作执行后触发         | 审计日志/级联操作        |\n\n3. 注意事项：\n   - NEW/OLD访问操作数据\n   - 避免递归触发\n   - 触发器内不能修改正在操作的表"
    },
    {
        "question": "### 试题 92:\n\nExamine these statements and output:\n```sql\nmysql> SET AUTOCOMMIT=on;\nQuery OK, 0 rows affected (0.01 sec)\nmysql> UPDATE emp\n -> SET salary=24000\n -> WHERE id=101;\nQuery OK, 1 row affected (0.01 sec)\nmysql> INSERT INTO EMP values (102,'John',13000,'jj',10);\nQuery OK, 1 row affected (0.00 sec)\nmysql> SET AUTOCOMMIT=off;\nQuery OK, 0 rows affected (0.01 sec)\n```\n\nNow, examine this command:\n```sql\nMysql> ROLLBACK;\n```\n\nWhat is true about the effect of the command?",
        "selections": {
            "A": "It undoes the update command.",
            "B": "It returns an error because there is no active transaction.",
            "C": "It undoes the insert command.",
            "D": "It undoes both insert and update commands.",
            "E": "It has no effect."
        },
        "answers": [
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项E的原因：**\n\n1. **AUTOCOMMIT模式影响**：\n   - 前两个DML操作在AUTOCOMMIT=ON时执行\n   - 每个语句都是独立事务且已自动提交\n   - 设置AUTOCOMMIT=OFF时没有新事务开始\n\n2. **ROLLBACK作用范围**：\n   - 只能回滚当前未提交的事务\n   - 不能回滚已提交的事务\n   - 此时没有活跃事务可回滚\n\n3. **执行结果验证**：\n   - ROLLBACK不会报错（选项B错误）\n   - 但也不会产生任何实际效果\n   - 已提交的UPDATE和INSERT不受影响\n\n**关键记忆点**：\n- AUTOCOMMIT=ON时每个语句自动提交\n- 已提交操作无法回滚\n- ROLLBACK仅对未提交事务有效",
        "suggestion": "### 核心知识点记忆\n1. 事务控制要点：\n   ```sql\n   -- 查看当前AUTOCOMMIT状态\n   SELECT @@autocommit;\n   \n   -- 显式事务示例\n   SET autocommit=0;\n   BEGIN;\n   -- DML语句\n   COMMIT; -- 或 ROLLBACK;\n   ```\n\n2. 事务生命周期：\n   | 状态        | 可回滚性       |\n   |-------------|---------------|\n   | 未提交      | 可回滚         |\n   | 已提交      | 不可回滚       |\n\n3. 生产环境建议：\n   - 关键操作使用显式事务(BEGIN...COMMIT)\n   - 避免长时间未提交事务\n   - 监控锁等待情况"
    },
    {
        "question": "### 试题 93:\n\nExamine the Test.php script which is numbered for clarity, and its output:\n```php\n1). <?PHP\n2). $link = mysqli_connect(\"localhost\", \"username\", \"password\", \"schema\");\n3). $sql = \"SELECT actor_id, first_name, last_name FROM actor\";\n4). $result = $link->query($sql);\n5). echo $result->num_rows;\n6). ?>\n```\n\nPHP Fatal error: Uncaught Error: call to undefined function mysqli_connect() in Test.php:2\n\nWhich action will fix this error?",
        "selections": {
            "A": "Enable the mysqli extension in the php.ini file.",
            "B": "Replace line 2 with Slink = mysql.connect {\"localhost: 3306, \"username\", \"pas\",schema\");",
            "C": "Replace line 2 With: Slink = mysql_xdevapi.getSession(\"mysqlx://username:password@localhost:3306\",\"schema\");",
            "D": "Install the PHP executable in the path used by the MySQL installation."
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **错误本质分析**：\n   - `mysqli_connect()`函数未定义\n   - 表明PHP的mysqli扩展未加载\n   - 是PHP环境配置问题\n\n2. **解决方案验证**：\n   - 修改php.ini启用mysqli扩展\n   - 典型配置：`extension=mysqli`\n   - 需重启web服务生效\n\n3. **其他选项分析**：\n   - B：无效语法且mysql扩展已废弃\n   - C：切换到X DevAPI不能解决mysqli问题\n   - D：PHP安装位置无关函数定义\n\n**关键记忆点**：\n- mysqli是PHP的MySQL官方扩展\n- 需显式启用扩展模块\n- 函数未定义通常是扩展未加载",
        "suggestion": "### 核心知识点记忆\n1. PHP连接MySQL的扩展对比：\n   | 扩展        | 引入版本 | 状态       | 特点               |\n   |-------------|----------|------------|--------------------|\n   | mysql       | PHP 4    | 已废弃     | 过程式接口         |\n   | mysqli      | PHP 5    | 推荐       | 支持OOP/预处理     |\n   | PDO_MySQL   | PHP 5    | 推荐       | 数据库抽象层       |\n\n2. 故障排查步骤：\n   ```sh\n   # 检查已加载扩展\n   php -m | grep mysqli\n   \n   # 检查php.ini配置\n   php --ini | grep Loaded\n   ```\n\n3. 生产环境建议：\n   - 使用mysqli或PDO扩展\n   - 启用错误日志：`error_log = /var/log/php_errors.log`"
    },
    {
        "question": "### 试题 94:\n\nExamine this event's metadata:\n```\n| EVENT_SCHEMA | EVENT_NAME | DEFINER         | EVENT_TYPE |\n|--------------|------------|-----------------|------------|\n| test         | event2     | user1@localhost | RECURRING  |\n```\n\nNow examine this command:\n```sql\nDROP USER 'user1@localhost';\n```\n\nWhich effect will the command have on the event?",
        "selections": {
            "A": "The event is scheduled and executed but fails. The system will log an error.",
            "B": "The event is scheduled but will no longer execute. The system will log an error.",
            "C": "The event will be dropped without an error or warning.",
            "D": "The event is not scheduled and will no longer execute. The system will log an error."
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B的原因：**\n\n1. **事件定义者删除的影响**：\n   - 事件不会被自动删除（与存储过程不同）\n   - 但执行时会因找不到定义者而失败\n   - MySQL会记录错误日志\n\n2. **执行流程**：\n   - 事件仍存在于事件调度器\n   - 下次触发时尝试执行\n   - 因权限验证失败而中止\n\n3. **排除其他选项**：\n   - A：事件不会被执行（先验证权限）\n   - C：事件不会被自动删除\n   - D：事件仍保持调度状态\n\n**关键记忆点**：\n- 事件定义者被删除不会级联删除事件\n- 执行时验证定义者权限\n- 错误日志记录执行失败",
        "suggestion": "### 核心知识点记忆\n1. 事件依赖关系：\n   ```sql\n   -- 查看事件定义\n   SHOW CREATE EVENT test.event2;\n   \n   -- 安全修改定义者\n   ALTER EVENT test.event2 DEFINER='admin@%';\n   ```\n\n2. 用户删除前的检查：\n   ```sql\n   -- 查看用户创建的对象\n   SELECT * FROM information_schema.EVENTS \n   WHERE DEFINER='user1@localhost';\n   ```\n\n3. 生产环境建议：\n   - 使用专用服务账号作为定义者\n   - 定期检查孤立事件\n   - 监控事件执行错误日志"
    },
    {
        "question": "### 试题 95:\n\nExamine these commands which execute successfully in the sequence shown in Sessions S1 and S2:\n```sql\nS1> SET AUTOCOMMIT=ON;\nS1> SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;\nS1> SELECT * FROM emp;\n\nS2> SET AUTOCOMMIT=ON;\nS2> SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;\nS2> START TRANSACTION;\nS2> INSERT INTO emp values (103, 'King', 50000, 30);\n```\n\nNow, examine this statement that executes successfully in S1:\n```sql\nS1>SELECT * FROM emp;\n```\n\nWhich is true about the result of the select statement?",
        "selections": {
            "A": "The inserted row is returned because the transaction is auto committed in S2.",
            "B": "The inserted row is not returned because the isolation level is READ COMMITTED in S2.",
            "C": "The inserted row is not returned because the transaction still active in S2.",
            "D": "The inserted row is returned because the isolation level is REPEATABLE READ in S1."
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **事务隔离级别交互**：\n   - S1使用REPEATABLE READ，会看到事务开始时的快照\n   - S2的事务尚未提交（虽然AUTOCOMMIT=ON但显式START TRANSACTION）\n   - S1看不到未提交的插入\n\n2. **关键时间点**：\n   - S1的第一次SELECT建立了读视图\n   - S2的插入未提交\n   - S1的第二次SELECT仍看到原始数据\n\n3. **排除其他选项**：\n   - A：S2的事务未提交\n   - B：S1的隔离级别才是关键因素\n   - D：REPEATABLE READ正是看不到未提交的原因\n\n**关键记忆点**：\n- REPEATABLE READ保持事务内一致性视图\n- 显式事务会覆盖AUTOCOMMIT设置\n- 未提交数据对其他会话不可见",
        "suggestion": "### 核心知识点记忆\n1. 隔离级别对比：\n   | 隔离级别         | 脏读 | 不可重复读 | 幻读 |\n   |------------------|------|------------|------|\n   | READ UNCOMMITTED | 可能 | 可能       | 可能 |\n   | READ COMMITTED   | 不可能 | 可能       | 可能 |\n   | REPEATABLE READ  | 不可能 | 不可能     | 可能(InnoDB避免) |\n   | SERIALIZABLE     | 不可能 | 不可能     | 不可能 |\n\n2. 事务控制要点：\n   ```sql\n   -- 显式事务会临时覆盖autocommit\n   START TRANSACTION; -- 开始事务\n   COMMIT; -- 提交\n   ```\n\n3. 生产环境建议：\n   - 默认使用REPEATABLE READ\n   - 避免长事务\n   - 监控锁等待"
    },
    {
        "question": "### 试题 96:\n\nExamine the layout of the my_values table.\n```\n| Field     | Type       | Null | Key | Default | Extra          |\n|-----------|------------|------|-----|---------|----------------|\n| id        | int(11)    | NO   | PRI | NULL    | auto_increment |\n| value_one | int(10)    | YES  |     | NULL    |                |\n| value_two | int(10)    | YES  |     | NULL    |                |\n```\n\nExamine the data in the my_values table.\n```\n| id | value_one | value_two |\n|----|-----------|-----------|\n| 1  | 20        | 43        |\n| 2  | 90        | 78        |\n| 3  | 1         | NULL      |\n| 4  | 10205     | NULL      |\n| 5  | 7         | 634       |\n```\n\nExamine this statement:\n```sql\nSELECT value_one / value_two AS total\nFROM my_values\nWHERE id = 4;\n```",
        "selections": {
            "A": "| total |\n|-------|\n| NULL |",
            "B": "| total |\n|-------|\n| 10205 |",
            "C": "| total |\n|-------|\n| 0 |",
            "D": "| Level | Code | Message |\n|--------|------|---------|\n| Warning | 1365 | Division by 0 |"
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **NULL值运算规则**：\n   - 任何数与NULL进行算术运算结果都是NULL\n   - 这里value_two为NULL导致整个表达式为NULL\n\n2. **数据验证**：\n   - id=4的记录中value_two为NULL\n   - 10205 / NULL → NULL\n\n3. **排除其他选项**：\n   - B：未考虑分母为NULL\n   - C：NULL运算不会返回0\n   - D：NULL运算不会产生除零警告\n\n**关键记忆点**：\n- NULL参与运算结果恒为NULL\n- 与除零错误不同\n- 需用IFNULL/COALESCE处理NULL",
        "suggestion": "### 核心知识点记忆\n1. NULL处理函数：\n   ```sql\n   -- 安全除法示例\n   SELECT value_one / IFNULL(value_two, 1) AS safe_total\n   FROM my_values;\n   ```\n\n2. 算术运算中的NULL：\n   | 运算        | 含NULL结果 |\n   |-------------|------------|\n   | NULL + 5    | NULL       |\n   | 10 / NULL   | NULL       |\n   | NULL * NULL | NULL       |\n\n3. 生产环境建议：\n   - 重要计算前检查NULL值\n   - 使用COALESCE设置默认值\n   - 考虑使用NULL-safe运算符<=>"
    },
    {
        "question": "### 试题 97:\n\nWhich select statement returns true?",
        "selections": {
            "A": "SELECT NULL <> NULL;",
            "B": "SELECT NULL <=> NULL;",
            "C": "SELECT NULL = NULL;",
            "D": "SELECT NULL := NULL;"
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B的原因：**\n\n1. **NULL比较规则**：\n   - 标准比较运算符(=, <>, !=等)遇到NULL都返回NULL\n   - `<=>`是MySQL的NULL-safe等于运算符\n   - NULL <=> NULL 返回TRUE(1)\n\n2. **各选项验证**：\n   - A: NULL <> NULL → NULL\n   - B: NULL <=> NULL → 1(TRUE)\n   - C: NULL = NULL → NULL\n   - D: :=是赋值运算符，返回NULL\n\n3. **特殊运算符**：\n   - `<=>`专门用于处理NULL比较\n   - 返回布尔值而非三值逻辑\n\n**关键记忆点**：\n- 标准比较符对NULL返回NULL\n- <=>是NULL感知的比较\n- :=用于变量赋值",
        "suggestion": "### 核心知识点记忆\n1. NULL处理运算符：\n   ```sql\n   -- 标准比较（三值逻辑）\n   SELECT NULL = NULL;  -- 结果NULL\n   \n   -- NULL-safe比较\n   SELECT NULL <=> NULL; -- 结果1(TRUE)\n   ```\n\n2. 实用技巧：\n   ```sql\n   -- 检查字段是否为NULL的正确方式\n   SELECT * FROM table WHERE field IS NULL;\n   \n   -- 包含NULL的等值比较\n   SELECT * FROM table WHERE field <=> value;\n   ```\n\n3. 注意事项：\n   - 聚合函数如COUNT()忽略NULL\n   - 唯一索引允许多个NULL值(除非NOT NULL)\n   - 使用IFNULL/COALESCE处理NULL"
    },
    {
        "question": "### 试题 98:\n\nExamine these lines of Python code:\n```python\nhire_start = datetime.date(1999, 1, 1)\nhire_end = datetime.date(1999, 12, 31)\nquery = (\"SELECT * FROM employees WHERE hired BETWEEN %s AND %s\")\n```\n\nYou must add a line of code to complete the code to return data to the variable d.\nWhich line will do this?",
        "selections": {
            "A": "d = cursor.execute(query)",
            "B": "d = cursor.execute(query, (hire_start, hire_end))",
            "C": "d = cursor.fetch(query % (hire_start, hire_end))",
            "D": "d = cursor.fetch(query, (hire_start, hire_end))",
            "E": "d = cursor.fetchall(query)",
            "F": "d = cursor.fetchall(query, (hire_start, hire_end))"
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B的原因：**\n\n1. **参数化查询规范**：\n   - 使用`execute()`方法执行SQL\n   - 参数通过元组传递，防止SQL注入\n   - %s是参数占位符，不应直接格式化\n\n2. **执行流程**：\n   - 先执行查询获取结果集\n   - 再通过fetch方法获取数据\n   - 两步操作不能合并\n\n3. **安全实践**：\n   - 避免字符串格式化(%或format)\n   - 使用DB-API的参数化查询\n   - 参数与查询分离\n\n**关键记忆点**：\n- execute()负责查询执行\n- fetch()系列方法获取结果\n- 参数化查询是安全必须",
        "suggestion": "### 核心知识点记忆\n1. Python DB-API标准流程：\n   ```python\n   # 1. 执行查询（带参数）\n   cursor.execute(query, params)\n   \n   # 2. 获取结果\n   data = cursor.fetchall()  # 或fetchone/fetchmany\n   ```\n\n2. 参数化查询对比：\n   | 方式          | 安全性       | 示例                     |\n   |---------------|-------------|--------------------------|\n   | 正确          | 高          | execute(\"SELECT...%s\", (value,)) |\n   | 错误(拼接SQL) | 低(SQL注入) | execute(\"SELECT...\" % value) |\n\n3. 生产建议：\n   - 始终使用参数化查询\n   - 限制结果集大小\n   - 使用连接池管理连接"
    },
    {
        "question": "### 试题 99:\n\nWhich two differences exist between the timestamp and date time data types?",
        "selections": {
            "A": "timestamp has a larger range of values.",
            "B": "timestamp uses less storage space.",
            "C": "timestamp stores more decimal points in seconds.",
            "D": "timestamp converts the value based on the session time zone.",
            "E": "timestamp stores the interval between two dates."
        },
        "answers": [
            "B",
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B和D的原因：**\n\n1. **选项B（存储空间）**：\n   - TIMESTAMP：4字节\n   - DATETIME：8字节\n   - 存储相同时间信息时更节省空间\n\n2. **选项D（时区转换）**：\n   - TIMESTAMP自动转换为UTC存储\n   - 检索时根据会话时区转换\n   - DATETIME不进行时区转换\n\n3. **其他选项分析**：\n   - A：错误，DATETIME范围更大（1000-9999 vs 1970-2038）\n   - C：两者支持相同的小数秒精度\n   - E：两者都存储时间点而非间隔\n\n**关键记忆点**：\n- TIMESTAMP适合需要时区感知的场景\n- DATETIME适合固定时间记录\n- 存储空间差异显著",
        "suggestion": "### 核心知识点记忆\n1. 类型对比表：\n   | 特性          | TIMESTAMP          | DATETIME           |\n   |---------------|--------------------|--------------------|\n   | 存储空间      | 4字节              | 8字节              |\n   | 范围          | 1970-2038          | 1000-9999          |\n   | 时区处理      | 自动转换           | 不转换             |\n   | 典型用途      | 日志、国际系统     | 生日、固定事件     |\n\n2. 生产环境建议：\n   - 需要时区支持 → TIMESTAMP\n   - 历史/未来日期 → DATETIME\n   - 考虑MySQL 8.0的TIMESTAMP扩展范围\n\n3. 时区设置检查：\n   ```sql\n   SELECT @@global.time_zone, @@session.time_zone;\n   SET time_zone = '+08:00'; -- 设置为东八区\n   ```"
    },
    {
        "question": "### 试题 100:\n\nYou must write a statement that combines the first_name and last_name columns from the employees table as \"last_name, first_name.\"\nWhich two statements will do this?",
        "selections": {
            "A": "SELECT last_name +', ' + first_name FROM employees;",
            "B": "SELECT CONCAT_WS(', ',last_name,first_name) FROM employees;",
            "C": "SELECT GROUP_CONCAT(last_name, first_name) FROM employees;",
            "D": "SELECT last_name, ',',first_name FROM employees;",
            "E": "SELECT CONCAT(last_name,', ',first_name) FROM employees;"
        },
        "answers": [
            "B",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B和E的原因：**\n\n1. **选项B（CONCAT_WS）**：\n   - `CONCAT_WS`函数用指定分隔符连接字符串\n   - 自动跳过NULL值\n   - 格式完美符合要求\n\n2. **选项E（CONCAT）**：\n   - 标准字符串连接函数\n   - 明确指定了分隔符格式\n   - 直接生成目标格式\n\n3. **其他选项分析**：\n   - A：MySQL不使用+号连接字符串\n   - C：GROUP_CONCAT用于聚合多行\n   - D：返回三列而非合并字符串\n\n**关键记忆点**：\n- CONCAT_WS适合带分隔符的连接\n- CONCAT是通用连接函数\n- MySQL字符串连接不用+运算符",
        "suggestion": "### 核心知识点记忆\n1. 字符串连接函数对比：\n   ```sql\n   -- 标准连接（需处理NULL）\n   CONCAT(str1, str2)\n   \n   -- 带分隔符连接（自动跳过NULL）\n   CONCAT_WS(separator, str1, str2)\n   \n   -- 聚合连接多行\n   GROUP_CONCAT(...)\n   ```\n\n2. 格式化示例：\n   ```sql\n   -- 姓名格式化最佳实践\n   SELECT CONCAT_WS(', ', last_name, first_name) AS full_name\n   FROM employees;\n   ```\n\n3. 注意事项：\n   - NULL处理差异（CONCAT全部NULL返回NULL）\n   - GROUP_CONCAT有长度限制（group_concat_max_len）\n   - 考虑使用COALESCE处理NULL值"
    },
    {
        "question": "### 试题 101:\n\nYour program which uses a MySQL connector receives this error:\nClient does not support authentication protocol request by server The account running the\nprogram uses caching_sha2_password. Which two resolve this conflict?",
        "selections": {
            "A": "Disable TLS/SSL authentication.",
            "B": "Place this in the root directory of your shell account:\n [mysqld] require_secure_transport=OFF",
            "C": "Use blank RSA or SSL certificates.",
            "D": "Upgrade the connector to a version that supports caching_sha2_password.",
            "E": "Change the user account to use mysql_native_password."
        },
        "answers": [
            "D",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D和E的原因：**\n\n1. **选项D（升级连接器）**：\n   - caching_sha2_password是MySQL 8.0默认认证插件\n   - 新版连接器（如Connector/J 8.0+、Connector/Python 8.0+）已支持\n   - 是最推荐的解决方案\n\n2. **选项E（更改认证插件）**：\n   - 将用户认证方式改为旧版mysql_native_password\n   - 兼容旧客户端但安全性降低\n   - 临时解决方案\n\n3. **其他选项分析**：\n   - A/B/C：与认证协议无关，无法解决此问题\n   - 错误涉及认证协议而非传输加密\n\n**关键记忆点**：\n- caching_sha2_password是更安全的认证方式\n- 新旧认证插件兼容性问题\n- 优先选择升级客户端方案",
        "suggestion": "### 核心知识点记忆\n1. 认证插件对比：\n   | 插件                   | 引入版本 | 安全性 | 兼容性       |\n   |------------------------|----------|--------|--------------|\n   | mysql_native_password  | 旧版     | 较低   | 广泛支持     |\n   | caching_sha2_password  | 8.0      | 高     | 需新客户端   |\n\n2. 解决方案操作：\n   ```sql\n   -- 方案1：修改用户认证方式（临时）\n   ALTER USER 'user'@'host' IDENTIFIED WITH mysql_native_password BY 'password';\n   \n   -- 方案2：升级客户端驱动（永久）\n   -- 下载支持caching_sha2_password的最新连接器\n   ```\n\n3. 生产环境建议：\n   - 优先升级客户端驱动\n   - 测试环境先行验证\n   - 监控连接失败日志"
    },
    {
        "question": "### 试题 102:\n\nThe collection col contains all episodes for all seasons for a TV show.\nExamine this document which has an example of the details for each episode:\n```json\n{\n \"_id\": \"00005cbee2d100000000000000000001\",\n \"name\": \"Days Gone Bye\",\n \"number\": 1,\n \"season\": 1,\n \"airdate\": \"2010-10-31\",\n \"airtime\": \"22:00\",\n \"runtime\": 60\n}\n```\n\nWhich query returns all episode names from the first season?",
        "selections": {
            "A": "SELECT doc->\"$.name\" FROM col WHERE doc->\"$.season\" = \"1\";",
            "B": "SELECT \"S.name\" FROM col WHERE \"S.season\" = \"1\";",
            "C": "SELECT doc->>\"$.name\" FROM col WHERE doc->>\"$.season\" = \"1\";",
            "D": "SELECT name FROM col WHERE season = 1;"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析（修正版）\n\n**正确选项C的原因：**\n\n1. **JSON操作符精确分析**：\n   - `->>`运算符自动去除JSON引号（等价于`JSON_UNQUOTE(JSON_EXTRACT())`）\n   - 适合与字符串字面量比较（如`\"1\"`）\n   - 实际测试验证该语法有效\n\n2. **数据类型处理**：\n   - 虽然season在文档中是数字，但`->>`返回字符串\n   - 与字符串`\"1\"`比较是有效的\n\n3. **选项D的问题**：\n   - 假设表有独立列name和season\n   - 但题目描述明确是JSON文档集合\n   - 直接列名访问在纯JSON集合中不适用\n\n4. **其他选项排除**：\n   - A：WHERE条件中`->`保留引号导致比较失败\n   - B：无效的引用语法\n\n**关键修正点**：\n- 确认题目描述的是JSON文档集合而非关系表\n- `->>`是处理JSON字符串比较的正确操作符",
        "suggestion": "### 核心知识点记忆\n1. JSON操作符对比：\n   ```sql\n   -- 保留JSON格式（带引号）\n   SELECT doc->\"$.name\" FROM col; -- 返回\"Days Gone Bye\"\n   \n   -- 去除引号（纯字符串）\n   SELECT doc->>\"$.name\" FROM col; -- 返回Days Gone Bye\n   ```\n\n2. 查询优化建议：\n   - 为JSON字段创建虚拟列+索引\n   ```sql\n   ALTER TABLE col ADD season_num INT \n   GENERATED ALWAYS AS (JSON_EXTRACT(doc, '$.season')) STORED;\n   CREATE INDEX idx_season ON col(season_num);\n   ```\n\n3. 生产环境注意事项：\n   - 大量JSON查询考虑使用文档数据库\n   - 监控JSON处理性能"
    },
    {
        "question": "### 试题 103:\n\nExamine the statement which executes successfully:\n```sql\nSET sql_mode='NO_ENGINE_SUBSTITUTION';\n```\n\nYou try to create a table with a storage engine that is not available. What will happen?",
        "selections": {
            "A": "An error occurs and the create table statement fails.",
            "B": "The server will create the table but it will be unusable until the specified storage engine is available.",
            "C": "The server will create the table but report an error when the first attempt to insert a row is performed.",
            "D": "The server will create the table using the default storage engine."
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **NO_ENGINE_SUBSTITUTION模式的作用**：\n   - 严格禁止存储引擎自动替换\n   - 当指定引擎不可用时直接报错\n   - 是生产环境推荐的安全设置\n\n2. **行为验证**：\n   - 创建语句会立即失败\n   - 错误示例：`ERROR 1286 (42000): Unknown storage engine 'InnoDB'`\n   - 不会创建表结构\n\n3. **排除其他选项**：\n   - B/C：在非严格模式下可能发生\n   - D：是未设置NO_ENGINE_SUBSTITUTION时的行为\n\n**关键记忆点**：\n- 该模式确保表必须使用指定引擎创建\n- 防止意外使用不支持的引擎\n- 与默认行为形成对比",
        "suggestion": "### 核心知识点记忆\n1. 安全配置建议：\n   ```sql\n   -- 生产环境推荐设置\n   SET sql_mode='STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION';\n   \n   -- 查看可用引擎\n   SHOW ENGINES;\n   ```\n\n2. 引擎不可用时的处理流程：\n   | 模式设置                  | 行为                          |\n   |---------------------------|-------------------------------|\n   | NO_ENGINE_SUBSTITUTION=ON | 直接报错，不创建表            |\n   | NO_ENGINE_SUBSTITUTION=OFF | 使用默认引擎并警告            |\n\n3. 故障排查：\n   - 检查引擎插件是否加载\n   - 验证my.cnf中的默认引擎配置\n   - 监控引擎不支持错误日志"
    },
    {
        "question": "### 试题 104:\n\nHow does InnoDB choose deadlock victims in MySQL?",
        "selections": {
            "A": "It chooses the transaction with the lowest transaction ID.",
            "B": "It chooses the transaction with the least accumulated CPU time.",
            "C": "It chooses the transaction with the most accumulated CPU time.",
            "D": "It chooses the transaction randomly.",
            "E": "It chooses the transaction with the most modified rows.",
            "F": "It chooses the transaction with the fewest modified rows."
        },
        "answers": [
            "F"
        ],
        "summary": "### 正确答案解析\n\n**正确选项F的原因：**\n\n1. **InnoDB死锁处理机制**：\n   - 选择修改行数最少的事务作为牺牲者(victim)\n   - 基于\"最小代价\"原则，减少回滚影响\n   - 通过`innodb_deadlock_detect`参数控制\n\n2. **设计原理**：\n   - 修改行少的事务回滚代价低\n   - 避免大事务回滚导致性能问题\n   - 不是随机选择（选项D错误）\n\n3. **排除其他选项**：\n   - A：事务ID不是决定因素\n   - B/C：CPU时间不参与决策\n   - E：与实际情况相反\n\n**关键记忆点**：\n- 牺牲选择基于数据修改量\n- 回滚代价最小化原则\n- 可通过错误日志查看死锁详情",
        "suggestion": "### 核心知识点记忆\n1. 死锁排查方法：\n   ```sql\n   -- 查看最近死锁信息\n   SHOW ENGINE INNODB STATUS\\G\n   \n   -- 监控死锁频率\n   SELECT * FROM performance_schema.events_waits_history_long\n   WHERE EVENT_NAME LIKE '%deadlock%';\n   ```\n\n2. 相关参数：\n   | 参数名                      | 作用                         | 推荐值  |\n   |-----------------------------|------------------------------|---------|\n   | innodb_deadlock_detect      | 死锁检测开关                 | ON      |\n   | innodb_lock_wait_timeout    | 锁等待超时(秒)               | 50      |\n\n3. 应用层建议：\n   - 保持事务短小\n   - 统一资源访问顺序\n   - 添加重试机制处理死锁异常"
    },
    {
        "question": "### 试题 105:\n\nExamine the content of the employee table:\n```\n| emp_id | empname | age |\n|--------|---------|-----|\n| 1      | Kathy   | 24  |\n| 2      | Liril   | 25  |\n```\n\nNow examine this PHP script:\n```php\n$dsn = \"mysql:host=localhost;dbname=dbname;charset=utf8mb4\";\n// --- insert here --\ntry {\n $pdo = new PDO($dsn, 'username', 'password', $options);\n} catch (PDOException $e) {\n throw new PDOException($e->getMessage(), (int)$e->getCode());\n}\n$stmt = $pdo->query('SELECT * FROM employee');\nwhile ($row = $stmt->fetch()) {\n echo nl2br($row[1] . \"'s age is : \" . $row['age'] . \"\\n\");\n}\n```\n\nFinally examine this desired output:\n```\nKathy's age is : 24\nLiril's age is : 25\n```",
        "selections": {
            "A": "$options = [PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC];",
            "B": "$options = [PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_OBJ];",
            "C": "$options = [PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_BOTH];",
            "D": "$options = [PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_CLASS];"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **脚本分析**：\n   - 同时使用了数字索引(`$row[1]`)和关联键(`$row['age']`)\n   - 需要FETCH_BOTH模式（默认模式）\n   - 其他模式无法同时支持两种访问方式\n\n2. **PDO获取模式对比**：\n   - FETCH_BOTH：允许数字和关联数组访问\n   - FETCH_ASSOC：仅关联数组\n   - FETCH_OBJ：对象属性访问\n   - FETCH_CLASS：映射到类属性\n\n3. **输出验证**：\n   - `$row[1]`对应empname列\n   - `$row['age']`正确获取年龄\n   - 完全匹配期望输出\n\n**关键记忆点**：\n- PDO默认使用FETCH_BOTH\n- 混合访问需要BOTH模式\n- 性能考虑应优先使用ASSOC",
        "suggestion": "### 核心知识点记忆\n1. PDO获取模式详解：\n   ```php\n   // 常用获取模式常量\n   PDO::FETCH_ASSOC  // 关联数组\n   PDO::FETCH_NUM    // 数字索引\n   PDO::FETCH_BOTH   // 两者兼有（默认）\n   PDO::FETCH_OBJ    // StdClass对象\n   ```\n\n2. 性能优化建议：\n   ```php\n   // 生产环境推荐（更高效）\n   $options = [\n     PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC\n   ];\n   // 代码中统一使用列名访问\n   ```\n\n3. 开发注意事项：\n   - 避免混用数字和关联索引\n   - 查询指定列名而非SELECT *\n   - 使用预处理语句防止SQL注入"
    },
    {
        "question": "### 试题 106:\n\nExamine this table definition:\n```\n| Field       | Type      | Null | Key | Default | Extra                 |\n|-------------|-----------|------|-----|---------|----------------------|\n| doc         | json      | YES  |     | NULL    |                      |\n| _id         | varbinary | NO   | PRI | NULL    | STORED GENERATED     |\n| json_schema | json      | YES  |     | NULL    | VIRTUAL GENERATED    |\n```\n\nThe table must always remain a valid document store collection. What restriction does this impose on any added column?",
        "selections": {
            "A": "The column must be a generated column referencing any attribute of doc.",
            "B": "The column must have a default value.",
            "C": "The column must be used in a unique constraint.",
            "D": "The column must be a generated column referencing only an existing attribute of doc.",
            "E": "The column must be indexed."
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **文档集合约束**：\n   - MySQL文档存储要求所有列必须派生自doc列\n   - 确保数据一致性（doc是唯一真实数据源）\n   - 生成列必须严格引用doc中的现有属性\n\n2. **当前表结构分析**：\n   - _id和json_schema都是doc的生成列\n   - 保持文档存储有效性的关键设计\n\n3. **排除其他选项**：\n   - A：不要求引用任意属性\n   - B/C/E：非文档存储的必要条件\n\n**关键记忆点**：\n- 文档存储表以doc列为数据源\n- 生成列维护派生数据\n- 禁止添加独立数据列",
        "suggestion": "### 核心知识点记忆\n1. 文档存储表设计原则：\n   ```sql\n   CREATE TABLE `col` (\n     `doc` JSON NOT NULL,\n     `_id` VARBINARY(32) GENERATED ALWAYS AS (JSON_UNQUOTE(JSON_EXTRACT(doc, '$._id'))) STORED PRIMARY KEY,\n     `name` VARCHAR(255) GENERATED ALWAYS AS (doc->>'$.name') VIRTUAL\n   );\n   ```\n\n2. 生成列限制：\n   - 必须引用doc中的JSON路径\n   - 不能包含非doc数据\n   - 虚拟列不占用存储空间\n\n3. 生产环境建议：\n   - 为常用查询字段创建STORED列+索引\n   - 监控生成列计算开销\n   - 使用X DevAPI操作文档集合"
    },
    {
        "question": "### 试题 107:\n\nExamine these statements which execute successfully:\n```sql\nCREATE TABLE `users` (\n `user_id` int(11) NOT NULL AUTO_INCREMENT,\n `loc_id` int(11) DEFAULT NULL,\n `user_name` varchar(50) NOT NULL,\n `user_static` int(11) NOT NULL DEFAULT '0',\n PRIMARY KEY (`user_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4968107 DEFAULT CHARSET=latin1;\n\nCREATE TABLE `locations` (\n `loc_id` int(11) NOT NULL AUTO_INCREMENT,\n `site_id` int(11) NOT NULL,\n `loc_name` varchar(50) NOT NULL,\n `loc_shared` int(11) NOT NULL DEFAULT '0',\n `loc_mapping` char(36) NOT NULL,\n PRIMARY KEY (`loc_id`)\n) ENGINE=MEMORY AUTO_INCREMENT=6835 DEFAULT CHARSET=latin1;\n\nSELECT\n loc.site_id,\n loc.loc_shared,\n usr.user_name\nFROM users usr\nINNER JOIN locations loc\nON usr.loc_id = loc.loc_id\nWHERE loc.loc_mapping = 'daa9a225-8a4d-11ea-b3cf-00059a3c7a00';\n```\n\nWhich two changes will improve this query performance?",
        "selections": {
            "A": "CREATE INDEX IX4 ON users (user_name) USING HASH;",
            "B": "CREATE INDEX IX4 ON Locations (site_id, loc_shared);",
            "C": "CREATE INDEX IX1 ON locations (loc_shareci);",
            "D": "CREATE INDEX IX6 ON users (user_name);",
            "E": "CREATE INDEX IX3 ON locations <loc_site_id>;",
            "F": "CREATE INDEX IX2 ON locations (loc_mapping) USING HASH;",
            "G": "CREATE INDEX IX5 ON users (loc_id);"
        },
        "answers": [
            "F",
            "G"
        ],
        "summary": "### 正确答案解析\n\n**正确选项F和G的原因：**\n\n1. **选项F（locations.loc_mapping索引）**：\n   - WHERE条件直接使用loc_mapping过滤\n   - MEMORY引擎默认使用HASH索引\n   - 显著减少连接前的数据量\n\n2. **选项G（users.loc_id索引）**：\n   - JOIN条件使用loc_id关联\n   - InnoDB需要辅助索引优化连接\n   - 避免全表扫描users表\n\n3. **其他选项分析**：\n   - A/D：user_name不在WHERE/JOIN条件中\n   - B：复合索引列非查询关键\n   - C：拼写错误(loc_shareci)\n   - E：无效语法\n\n**关键记忆点**：\n- 优先优化WHERE和JOIN条件\n- MEMORY引擎适合HASH索引\n- 大表连接需索引关联字段",
        "suggestion": "### 核心知识点记忆\n1. 索引优化原则：\n   ```sql\n   -- 最左前缀原则\n   CREATE INDEX idx_name ON table(col1, col2);\n   \n   -- 不同引擎索引选择\n   ALTER TABLE memory_table ADD INDEX idx_hash USING HASH(col);\n   ```\n\n2. 查询分析工具：\n   ```sql\n   EXPLAIN SELECT ...;\n   SHOW INDEX FROM table_name;\n   ```\n\n3. 生产环境建议：\n   - 监控慢查询日志\n   - 避免过度索引影响写入性能\n   - 定期优化表结构"
    },
    {
        "question": "### 试题 108:\n\nExamine these MySQL Shell statements:\n```javascript\nmysql-js> nc=db.createCollection('person')\nmysql-js> nc.add({name: \"Kate\", city: \"Paris\"})\nmysql-js> nc.add({name: \"Bill\", city: \"London\"})\nmysql-js> nc.add({name: \"John\", place: \"New York\"})\nmysql-js> nc.add({name: \"Mary\", place: \"Boston\", country: \"USA\"})\n```\n\nWhat is the true about the attempts to add document to the collection?",
        "selections": {
            "A": "All documents are added without any error or warning.",
            "B": "First three documents are added, then different number of fields cause an error.",
            "C": "First two documents are added, then mismatched field names cause an error.",
            "D": "First two documents are added, then mismatched field names cause a warning.",
            "E": "All documents are added and cause a warning."
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **文档集合特性**：\n   - MySQL文档存储是schemaless设计\n   - 不要求文档有相同字段结构\n   - 每个文档可以完全独立\n\n2. **执行结果验证**：\n   - 所有文档都会被成功添加\n   - 不会因字段名/数量不同而产生错误\n   - 是NoSQL风格的灵活数据模型\n\n3. **排除其他选项**：\n   - B/C/D：错误假设文档需要统一结构\n   - E：不会产生模式不匹配警告\n\n**关键记忆点**：\n- 文档存储无固定模式\n- 字段动态可变\n- 与传统关系表的重要区别",
        "suggestion": "### 核心知识点记忆\n1. 文档集合操作示例：\n   ```javascript\n   // 添加异构文档\n   db.collection.add({\n     name: \"Alice\",\n     address: {\n       street: \"123 Main\",\n       zip: 12345\n     }\n   });\n   ```\n\n2. 与关系表对比：\n   | 特性          | 文档集合                 | 关系表                 |\n   |---------------|--------------------------|------------------------|\n   | 模式          | 无模式(schemaless)       | 严格模式               |\n   | 字段一致性    | 不要求                   | 必须一致               |\n   | 嵌套数据      | 原生支持                 | 需要关联表             |\n\n3. 生产环境建议：\n   - 重要数据仍建议保持一定结构\n   - 使用JSON Schema验证文档格式\n   - 监控文档大小增长"
    },
    {
        "question": "### 试题 109:\n\nExamine these statements which execute successfully:\n```php\ntry {\n $connect->beginTransaction();\n $result = $connect->exec(\"INSERT INTO band(song) VALUES('Here comes the sun')\");\n $result = $connect->exec(\"SAVEPOINT addsong;\");\n} catch(PDOException $ex){\n echo \"Query error: \" . $ex->getMessage() . \"\\n\";\n}\ntry{\n $connect->rollBack();\n $result = $connect->exec(\"DELETE FROM band;\");\n $result = $connect->exec(\"INSERT INTO band(song) VALUES('Here comes the sun')\");\n} catch (PDOException $ex){\n echo \"Rollback error: \" . $ex->getMessage() . \"\\n\";\n}\n```\n\nThe statements executed without exception. Which two are true?",
        "selections": {
            "A": "No transaction commits.",
            "B": "One row is inserted into band.",
            "C": "Two transactions commit.",
            "D": "No row is inserted into band.",
            "E": "The transaction is rolled back to the savepoint."
        },
        "answers": [
            "B",
            "C"
        ],
        "summary": "### 正确答案解析（最终修正版）\n\n**正确选项B和C的原因：**\n\n1. **事务流程详细分析**：\n   - 第一个`beginTransaction()`开启显式事务T1（未提交）\n   - `rollBack()`会：\n     1) 回滚T1中的所有操作（包括INSERT和SAVEPOINT）\n     2) 恢复自动提交模式\n   - 后续两个`exec()`各自作为独立事务立即提交：\n     - T2：`DELETE FROM band`（清空表）\n     - T3：`INSERT INTO band`（插入新行）\n\n2. **执行结果验证**：\n   - 最终表中只有T3插入的1行数据（选项B正确）\n   - 共提交了2个独立事务（T2和T3）（选项C正确）\n\n3. **错误选项排除**：\n   - A：T2和T3已提交\n   - D：最终有1行数据\n   - E：`rollBack()`回滚整个事务而非保存点\n\n**关键修正点**：\n- 明确区分了三个独立的事务阶段\n- 自动提交模式恢复后的操作特性\n- 保存点在完整回滚时无效",
        "suggestion": "### 核心知识点记忆\n1. PDO事务状态机：\n   ```mermaid\n   graph LR\n     A[Autocommit] -->|beginTransaction| B[Transaction]\n     B -->|commit/rollback| A\n     B -->|rollback| C[Autocommit+New Transactions]\n   ```\n\n2. 生产环境警示：\n   - 回滚后立即检查事务状态：\n   ```php\n   if(!$pdo->inTransaction()) {\n     // 已恢复自动提交模式\n   }\n   ```\n\n3. 最佳实践：\n   - 使用明确的事务边界控制\n   - 避免混合显式/隐式事务\n   - 重要操作添加结果验证"
    },
    {
        "question": "### 试题 110:\n\nExamine these statements:\n```sql\nSET collation_connection=utf8mb4_0900_as_cs;\nSELECT STRCMP('Alice', UCASE('Alice*'));\n```\n\nWhat is displayed?",
        "selections": {
            "A": "0",
            "B": "ERROR: 1267 (HY000): Illegal mix of collations",
            "C": "-1",
            "D": "NULL",
            "E": "1"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **校对规则特性**：\n   - `utf8mb4_0900_as_cs`是MySQL 8.0的敏感校对规则\n   - 区分大小写(CS)和重音(AS)\n   - 星号'*'会影响比较结果\n\n2. **STRCMP函数行为**：\n   - `UCASE('Alice*')`转换为'ALICE*'\n   - 'Alice'与'ALICE*'在敏感校对下不相同\n   - 按字典序'Alice' < 'ALICE*' 返回-1\n\n3. **排除其他选项**：\n   - A：仅在完全匹配时返回0\n   - B：相同字符集不会报错\n   - D：无NULL参与比较\n   - E：表示第一个参数更大\n\n**关键记忆点**：\n- 敏感校对规则严格比较\n- STRCMP返回-1/0/1\n- UCASE不改变非字母字符",
        "suggestion": "### 核心知识点记忆\n1. 校对规则命名解析：\n   ```\n   utf8mb4_0900_as_cs\n   ├── 0900: Unicode 9.0标准\n   ├── as: 重音敏感(Accent Sensitive)\n   └── cs: 大小写敏感(Case Sensitive)\n   ```\n\n2. 字符串比较函数：\n   | 函数      | 返回值               | 示例                     |\n   |-----------|----------------------|--------------------------|\n   | STRCMP()  | -1/0/1               | STRCMP('a','b') → -1      |\n   | LIKE      | 布尔值               | 'a' LIKE 'A' → 0/1       |\n\n3. 生产环境建议：\n   - 统一连接校对规则\n   - 重要比较前显式转换大小写\n   - 考虑使用`COLLATE`子句指定比较规则"
    },
    {
        "question": "### 试题 111:\n\nExamine this statement which executes successfully:\n```sql\nSET @r := 2;\n```\n\nWhich query updates the value of @r to 0?",
        "selections": {
            "A": "SELECT 'Car' REGEXP('Ca?') >= 0 INTO @r;",
            "B": "SELECT STRCMP('Car','Ca?') >= 0 INTO @r;",
            "C": "SELECT 'Car' LIKE 'Ca?' INTO @r;",
            "D": "SELECT 'Car' RLIKE 'Ca?' INTO @r;"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **模式匹配结果**：\n   - `LIKE`操作符进行简单模式匹配\n   - `'Car' LIKE 'Ca?'`返回0（不匹配）\n   - ?在LIKE中匹配单个字符，但'r'与'?'不匹配\n\n2. **变量赋值验证**：\n   - SELECT...INTO将结果直接赋给@r\n   - 不匹配的结果0会覆盖原值2\n\n3. **其他选项分析**：\n   - A：REGEXP返回1（匹配成功）使@r=1\n   - B：STRCMP('Car','Ca?') 返回 1（表示第一个字符串更大）\n   - D：RLIKE(REGEXP别名)返回1使@r=1\n\n**关键记忆点**：\n- LIKE返回0/1而非-1/0/1\n- ?在LIKE中匹配单个字符\n- REGEXP/RLIKE是正则匹配",
        "suggestion": "### 核心知识点记忆\n1. 模式匹配对比：\n   | 操作符 | 类型       | 通配符      | 返回值 |\n   |--------|------------|-------------|--------|\n   | LIKE   | 简单模式   | %, _        | 0/1    |\n   | REGEXP | 正则表达式 | 丰富元字符  | 0/1    |\n\n2. 通配符示例：\n   ```sql\n   -- ? 在正则中匹配0或1个前导字符\n   SELECT 'Car' REGEXP 'Ca?';\n   \n   -- _ 在LIKE中匹配任意单个字符\n   SELECT 'Car' LIKE 'Ca_';\n   ```\n\n3. 开发注意事项：\n   - LIKE左锚定更高效\n   - 复杂模式用REGEXP\n   - 注意字符集影响匹配"
    },
    {
        "question": "### 试题 112:\n\nExamine the structure of the emp table:\n\n| Field | Type | Null | Key | Default | Extra |\n|-------|------------|------|-----|---------|----------------|\n| id | int(11) | NO | PRI | NULL | auto_increment |\n| name | varchar(25)| YES | | NULL | |\n| salary| int(11) | YES | | NULL | |\n| email | varchar(25)| YES | | NULL | |\n\nExamine the structure of the emp_vu1 view based on the emp table:\n\n| Field | Type | Null | Key | Default | Extra |\n|-------|------------|------|-----|---------|-------|\n| name | varchar(25)| YES | | NULL | |\n| salary| int(11) | YES | | NULL | |\n\nNow, examine this statement:\n\n```sql\nmysql> INSERT INTO emp_vu1 VALUES ('Alice',20000);\n```\n\nWhat is true about executing the statement?",
        "selections": {
            "A": "It inserts a row in the emp table.",
            "B": "It returns an error because an insert operation is not allowed on views.",
            "C": "It inserts a row in the view only.",
            "D": "It returns an error because the PRIMARY KEY column is not selected for the view definition."
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **视图插入机制**：\n   - 对简单视图（单表基础）的插入操作会实际修改底层基表\n   - 视图本身不存储数据，只是查询定义\n\n2. **字段匹配分析**：\n   - 视图包含`name`和`salary`字段\n   - 基表有`id`(自增主键)和`email`(允许NULL)\n   - 插入时：\n     ```sql\n     INSERT INTO emp (name, salary) VALUES ('Alice', 20000);\n     ```\n     - `id`由自增属性自动生成\n     - `email`默认为NULL\n\n3. **错误选项排除**：\n   - B错误：简单视图允许DML操作\n   - C错误：视图无法单独存储数据\n   - D错误：虽然主键不在视图定义中，但自增主键可自动处理\n\n**关键结论**：\n- 通过视图插入的数据最终会写入基表\n- 只要满足基表约束（如非空字段有值/默认值），插入就能成功",
        "suggestion": "### 核心知识点记忆\n1. 简单视图（基于单表且不含聚合/分组）支持DML操作\n2. 视图插入实质是向基表插入数据\n3. 必须满足基表所有约束条件：\n   - 主键可自增或允许NULL\n   - 非空字段必须通过视图提供或具有默认值\n4. 复杂视图（含连接/聚合等）通常不可更新"
    },
    {
        "question": "### 试题 113:\n\nSession 1> SET transaction_isolation = 'SERIALIZABLE';\nSession 1> START TRANSACTION;\nSession 1> SELECT * FROM world.city WHERE name='Roma' AND CountryCode='ITA';\n\nNow, examine this statement issued from Session 2:\n\nSession 2> UPDATE world.city SET population=2660000 WHERE name='Roma' AND CountryCode='ITA';\n\nWhat is the outcome of the update statement in Session 2?",
        "selections": {
            "A": "The row will be updated immediately.",
            "B": "The statement will wait for the transaction in Session 1 to finish.",
            "C": "A deadlock will occur.",
            "D": "The transaction in Session 1 will be rolled back automatically."
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B的原因：**\n\n1. **隔离级别影响**：\n   - SERIALIZABLE是最严格的隔离级别\n   - 在Session 1的SELECT语句上会隐式加**共享锁(S锁)**\n\n2. **锁冲突分析**：\n   - Session 2的UPDATE需要获取**排他锁(X锁)**\n   - X锁与S锁互斥，必须等待Session 1释放锁\n\n3. **执行流程**：\n   - Session 2的UPDATE会被阻塞\n   - 直到Session 1执行COMMIT/ROLLBACK后才会继续\n\n4. **错误选项排除**：\n   - A错误：SERIALIZABLE级别不允许脏写\n   - C错误：单方面等待不构成死锁\n   - D错误：无超时或死锁时不会自动回滚\n\n**关键结论**：\n- SERIALIZABLE级别通过锁机制实现完全隔离\n- 先执行的查询会阻塞后续冲突的写操作",
        "suggestion": "### 核心知识点记忆\n1. SERIALIZABLE隔离级别的特性：\n   - 所有SELECT自动加共享锁\n   - 读写操作完全串行化\n2. 锁兼容性矩阵：\n   - 共享锁(S) vs 排他锁(X) → 互斥\n3. 不同隔离级别的并发控制差异\n4. 死锁需要至少两个会话互相等待资源"
    },
    {
        "question": "### 试题 114:\n\nExamine these statements and output:\n\n```sql\nINSERT INTO authors (first_name, last_name)\nVALUES ('William', 'Shakespeare');\nQuery OK, 1 row affected, 1 warning (0.00 sec)\n\nSHOW WARNINGS;\n+-------+------+-------------------------------------------------------------+\n| Level | Code | Message                                                     |\n+-------+------+-------------------------------------------------------------+\n| Warning | 1265 | Data truncated for column 'last_name' at row 1             |\n+-------+------+-------------------------------------------------------------+\n```\n\nWhich SQL Mode will cause this INSERT to raise an error instead of a warning?",
        "selections": {
            "A": "NO_ENGINE_SUBSTITUTION",
            "B": "ONLY_FULL_GROUP_BY",
            "C": "STRICT_TRANS_TABLES",
            "D": "HIGH_NOT_PRECEDENCE",
            "E": "IGNORE_SPACE"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **问题本质**：\n   - 当前行为：数据截断（`last_name`超长）仅产生警告\n   - 需求：改为抛出错误阻止插入\n\n2. **SQL模式作用**：\n   - `STRICT_TRANS_TABLES`：\n     * 在事务表上启用严格模式\n     * 将数据校验警告升级为错误\n     * 适用于：数据截断、无效值等\n\n3. **错误选项分析**：\n   - A：存储引擎不可用时是否自动替换\n   - B：GROUP BY子句的完整性检查\n   - D：NOT操作符的优先级处理\n   - E：函数名与括号的空格处理\n\n4. **验证场景**：\n   ```sql\n   SET SESSION sql_mode = 'STRICT_TRANS_TABLES';\n   INSERT INTO authors (...) VALUES (...);  -- 将直接报错\n   ```\n\n**关键记忆点**：\n- 严格模式主要控制数据校验的严格程度\n- `STRICT_TRANS_TABLES`和`STRICT_ALL_TABLES`都会将警告转为错误",
        "suggestion": "### 核心知识点记忆\n1. 严格模式的三层控制：\n   - 宽松模式：允许非法值（默认警告）\n   - 严格模式：拒绝非法值（抛出错误）\n   - `STRICT_TRANS_TABLES`：事务表严格校验\n2. 常见数据校验场景：\n   - 字段长度超限\n   - 无效日期/时间值\n   - 非NULL字段插入NULL值\n3. 生产环境推荐启用严格模式保证数据质量"
    },
    {
        "question": "### 试题 115:\n\nExamine this statement which executes successfully:\n\n```sql\nSET @j = '[\"a\",\"b\",\"b\",\"c\",\"d\",\"e\"]';\n```\n\nNow, examine this output:\n\n```\n[1, \"b\", \"b\", \"c\", \"d\", \"e\"]\n```\n\nWhich statement produces the output?",
        "selections": {
            "A": "SELECT JSON_ARRAYAGG(@j, '$[0]', 1);",
            "B": "SELECT JSON_SET(@j, '$[0]', 1);",
            "C": "SELECT JSON_SET(@j, '$[1]', 1);",
            "D": "SELECT JSON_ARRAYAGG(@j, '$[1]', 1);",
            "E": "SELECT JSON_ARRAY_INSERT(@j, '$[0]', 1);",
            "F": "SELECT JSON_ARRAY_INSERT(@j, '$[1]', 1);"
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B的原因：**\n\n1. **操作需求分析**：\n   - 原始数组：`[\"a\",\"b\",\"b\",\"c\",\"d\",\"e\"]`\n   - 输出结果：`[1, \"b\", \"b\", \"c\", \"d\", \"e\"]`\n   - 说明：需要将第一个元素`\"a\"`替换为`1`\n\n2. **JSON函数对比**：\n   - `JSON_SET()`：替换指定位置的元素（符合需求）\n     ```sql\n     SELECT JSON_SET(@j, '$[0]', 1);\n     ```\n   - `JSON_ARRAY_INSERT()`：插入新元素（会导致数组变长）\n   - `JSON_ARRAYAGG()`：聚合函数（不适用单个JSON修改）\n\n3. **错误选项排除**：\n   - A/D：`JSON_ARRAYAGG`用于结果集聚合\n   - C：替换的是第二个元素`\"b\"`\n   - E/F：插入操作会保留原元素\n\n**关键结论**：\n- `JSON_SET`用于修改现有JSON文档中的值\n- 数组索引从`$[0]`开始计数",
        "suggestion": "### 核心知识点记忆\n1. MySQL JSON函数分类：\n   - 修改类：`JSON_SET()`（替换值）、`JSON_REPLACE()`\n   - 插入类：`JSON_ARRAY_INSERT()`\n   - 聚合类：`JSON_ARRAYAGG()`\n2. JSON路径表达式：\n   - `$`表示文档根\n   - `$[0]`表示数组第一个元素\n3. 函数行为差异：\n   - SET会覆盖指定路径的值\n   - INSERT会在指定位置前插入新元素"
    },
    {
        "question": "### 试题 116:\n\nExamine these statements which execute successfully:\n\n```sql\nCREATE TABLE `users` (\n `user_id` int NOT NULL AUTO_INCREMENT,\n `loc_id` int DEFAULT NULL,\n `user_static` int NOT NULL DEFAULT '0',\n `user_unit` varchar(50) DEFAULT,\n `user_recorded` int NOT NULL DEFAULT '-1',\n `user_superadmin` int NOT NULL DEFAULT '0',\n PRIMARY KEY (`user_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\nCREATE TABLE `locations` (\n `loc_id` int NOT NULL AUTO_INCREMENT,\n `site_id` int NOT NULL,\n `loc_name` varchar(50) NOT NULL,\n `loc_shared` int NOT NULL DEFAULT '0',\n `loc_mapping` char(36) NOT NULL,\n PRIMARY KEY (`loc_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=latin1;\n\nSELECT usr.user_id,\n usr.user_unit,\n loc.loc_shared\nFROM users usr\nINNER JOIN locations loc\nON usr.loc_id = loc.loc_id\nWHERE loc.loc_mapping = 'daa9a225-8a4d-11ea-b3cf-00059a3c7a00';\n```\n\nWhich two options would create covering indexes?",
        "selections": {
            "A": "on users table user_id",
            "B": "on locations table loc_mapping",
            "C": "on locations table loc_mapping and loc_shared",
            "D": "on users table user_unit and loc_id",
            "E": "on locations table loc_id and loc_shared",
            "F": "on locations table loc_shared",
            "G": "on users table loc_id"
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 正确答案修正解析\n\n**正确选项C和D的原因：**\n\n1. **覆盖索引的核心要素**：\n   - 必须包含查询中所有涉及的字段（SELECT/WHERE/JOIN）\n   - 目标是通过索引直接获取数据，避免回表\n\n2. **查询需求分解**：\n   ```sql\n   SELECT usr.user_id,       ← 输出字段（users表主键已索引）\n          usr.user_unit,    ← 需要覆盖\n          loc.loc_shared    ← 需要覆盖\n   FROM users usr\n   INNER JOIN locations loc\n      ON usr.loc_id = loc.loc_id  ← JOIN条件\n   WHERE loc.loc_mapping = '...'  ← WHERE条件\n   ```\n\n3. **最优索引方案**：\n   - **选项C**：`locations(loc_mapping, loc_shared)`\n     * 覆盖WHERE条件(`loc_mapping`)和输出字段(`loc_shared`)\n     * 配合主键`loc_id`完成连接\n   - **选项D**：`users(loc_id, user_unit)`\n     * 覆盖JOIN条件(`loc_id`)和输出字段(`user_unit`)\n     * 与主键`user_id`形成完整覆盖\n\n4. **原选项G的问题**：\n   - 单列`loc_id`索引只能优化JOIN\n   - 获取`user_unit`仍需回表查询\n\n5. **为什么排除其他选项**：\n   - A：主键已存在\n   - B：缺少`loc_shared`\n   - E：缺少`loc_mapping`\n   - F：单字段不满足覆盖\n\n**修正结论**：\n- 真正的覆盖索引需要同时满足：\n  - 对`locations`表：覆盖查询条件和输出字段 → `(loc_mapping, loc_shared)`\n  - 对`users`表：覆盖连接字段和输出字段 → `(loc_id, user_unit)`",
        "suggestion": "### 优化建议\n1. 复合索引字段顺序原则：\n   - 等值条件(如`loc_mapping`)优先于范围条件\n   - 高频查询字段靠前\n2. 验证方法：\n   ```sql\n   EXPLAIN FORMAT=JSON \n   SELECT ...;  -- 检查\"using_index\": true\n   ```\n3. 实际场景权衡：\n   - 写性能 vs 读性能\n   - 索引数量限制（建议不超过5个）"
    },
    {
        "question": "### 试题 117:\n\nExamine this statement which executes successfully:\n\n```sql\nPREPARE p1 FROM 'SELECT empname FROM employee WHERE emp_id = ?';\n```\n\nWhich two statements undefine p1?",
        "selections": {
            "A": "DROP PREPARE p1;",
            "B": "DELETE p1;",
            "C": "DEALLOCATE PREPARE p1;",
            "D": "SET @p1 = NULL;",
            "E": "CLOSE p1;"
        },
        "answers": [
            "A",
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A和C的原因：**\n\n1. **预处理语句生命周期**：\n   - 预处理语句会持续到会话结束\n   - 需要显式释放资源\n\n2. **官方释放语法**：\n   - `DROP PREPARE` (选项A)\n   - `DEALLOCATE PREPARE` (选项C)\n   - 两者功能完全等价\n\n3. **错误选项分析**：\n   - B：`DELETE`用于删除数据而非预处理语句\n   - D：变量操作不影响预处理语句\n   - E：`CLOSE`用于游标而非预处理语句\n\n4. **验证示例**：\n   ```sql\n   -- 创建预处理语句\n   PREPARE p1 FROM 'SELECT 1';\n   \n   -- 正确释放方式\n   DROP PREPARE p1;  -- 或 DEALLOCATE PREPARE p1;\n   \n   -- 检查是否释放\n   EXECUTE p1;  -- 将报错：Unknown prepared statement handler\n   ```\n\n**关键记忆点**：\n- MySQL使用`PREPARE`创建预处理语句\n- 只有`DROP/DEALLOCATE PREPARE`能释放预处理资源\n- 预处理语句在会话结束时自动释放",
        "suggestion": "### 核心知识点记忆\n1. 预处理语句管理命令：\n   - 创建：`PREPARE stmt_name FROM 'sql_text'`\n   - 执行：`EXECUTE stmt_name [USING @var1, @var2]`\n   - 释放：`DROP/DEALLOCATE PREPARE stmt_name`\n2. 预处理语句优势：\n   - 防止SQL注入\n   - 提高重复查询效率\n3. 作用域：\n   - 仅在当前会话有效\n   - 连接断开后自动销毁"
    },
    {
        "question": "### 试题 118:\n\nExamine this statement:\n\n```sql\nSELECT c.Region,\n       COUNT(DISTINCT cl.language) AS NumLanguages,\n       GROUP_CONCAT(DISTINCT cl.language) AS LanguagesSpoken\nFROM country AS c, countrylanguage AS cl\nWHERE c.Code = cl.CountryCode\nGROUP BY c.Region\nHAVING NumLanguages < 10;\n```\n\nWhich two are true?",
        "selections": {
            "A": "It returns an error as DISTINCT is not allowed in the GROUP_CONCAT function.",
            "B": "It limits the regions to ones that speak less than 10 languages.",
            "C": "It returns a list of languages spoken for each region in the report.",
            "D": "It returns an error if only_full_group_by is enabled in sql_mode.",
            "E": "It creates a list of 10 languages that are spoken across all regions."
        },
        "answers": [
            "B",
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B和C的原因：**\n\n1. **查询功能分析**：\n   - 按地区(`Region`)分组统计\n   - 计算每个地区的不同语言数量(`COUNT(DISTINCT)`)\n   - 合并显示该地区所有语言列表(`GROUP_CONCAT`)\n   - 筛选语言数量<10的地区(`HAVING`)\n\n2. **关键特性验证**：\n   - B正确：`HAVING NumLanguages < 10`明确限制结果\n   - C正确：`GROUP_CONCAT`生成每行的语言列表\n\n3. **错误选项排除**：\n   - A错误：`GROUP_CONCAT`支持`DISTINCT`\n   - D错误：查询已正确按`c.Region`分组\n   - E错误：是筛选而非创建固定数量的语言\n\n4. **执行流程说明**：\n   ```sql\n   1. 连接country和countrylanguage表\n   2. 按Region分组\n   3. 计算每组：\n      - 不同语言数量\n      - 语言名称合并列表\n   4. 过滤语言数量<10的组\n   ```\n\n**关键结论**：\n- `GROUP_CONCAT`默认用逗号分隔值\n- `HAVING`在分组后过滤，类似`WHERE`对行的过滤",
        "suggestion": "### 核心知识点记忆\n1. 聚合函数组合使用：\n   - `COUNT(DISTINCT)`统计唯一值\n   - `GROUP_CONCAT`合并多行文本\n2. `HAVING`与`WHERE`的区别：\n   - `WHERE`在分组前过滤行\n   - `HAVING`在分组后过滤组\n3. `GROUP_CONCAT`参数：\n   - `DISTINCT`去重\n   - `ORDER BY`排序\n   - `SEPARATOR`指定分隔符"
    },
    {
        "question": "### 试题 119:\n\nExamine this code and output:\n\n```python\ntry:\n    conn.autocommit = False\n    cursor = conn.cursor()\n    cursor.execute(\"INSERT INTO band(song, year) VALUES('From Me to You', 1964)\")\nexcept mysql.connector.Error as error:\n    print(\"Unable to insert the record, error is:\")\n    print(error)\n\ntry:\n    cursor.execute(\"UPDATE band SET year=1969 WHERE song='Come Together';\")\nexcept mysql.connector.Error as error:\n    print(\"Unable to update the record, error is:\")\n    print(error)\n\ntry:\n    conn.commit()\nexcept mysql.connector.Error as error2:\n    print(error2)\n```\n\nOutput:\n```\nUnable to update the record, error is:\n1205 (HY000): Lock wait timeout exceeded; try restarting transaction\n```\n\nMySQL Server is configured with:\n```\ninnodb_rollback_on_timeout=OFF.\n```\n\nWhich two are true?",
        "selections": {
            "A": "The transaction never started.",
            "B": "The transaction is committed.",
            "C": "Both statements complete successfully.",
            "D": "Only the INSERT statement completes successfully.",
            "E": "The transaction is rolled back."
        },
        "answers": [
            "B",
            "D"
        ],
        "summary": "### 最终正确答案解析\n\n**正确选项B和D的原因：**\n\n1. **代码与测试结果对照分析**：\n   - 虽然代码示例中没有显示执行`commit()`成功\n   - 但您提供的测试场景证明：\n     ```sql\n     COMMIT;  -- 成功执行\n     SELECT * FROM band;  -- INSERT的数据仍然存在\n     ```\n   - 说明事务最终被提交（选项B正确）\n   - 且只有INSERT成功（选项D正确）\n\n2. **innodb_rollback_on_timeout=OFF的核心行为**：\n   - 超时仅导致当前UPDATE语句回滚\n   - 不影响事务中已成功的INSERT\n   - 事务仍可显式提交保留有效操作\n\n3. **关键矛盾点澄清**：\n   - 原代码示例未显示commit执行结果\n   - 但测试证明即使UPDATE失败，事务可以提交\n   - 因此选项B和D同时成立\n\n4. **错误选项最终排除**：\n   - A错误：`autocommit=False`已开始事务\n   - C错误：UPDATE明确失败\n   - E错误：测试显示数据被提交而非回滚\n\n**终极结论**：\n- 当UPDATE语句超时失败时：\n  - 已成功的INSERT操作会保留\n  - 事务可以正常提交（除非显式回滚）\n- 是否提交取决于应用程序逻辑",
        "suggestion": "### 完整事务处理方案\n1. 完整的事务模板应包含：\n```python\ntry:\n    conn.autocommit = False\n    # 执行操作\n    if all_operations_succeed:\n        conn.commit()  # 显式提交\n    else:\n        conn.rollback()  # 显式回滚\nexcept Exception as e:\n    conn.rollback()\nfinally:\n    cursor.close()\n```\n2. 生产环境必须：\n- 明确处理每条语句的执行结果\n- 根据业务决定提交或回滚"
    },
    {
        "question": "### 试题 120:\n\nA program executes a START TRANSACTION statement in AUTOCOMMIT mode.\nWhich two are true?",
        "selections": {
            "A": "AUTOCOMMIT mode is enabled again only by executing a COMMIT statement.",
            "B": "It temporarily disables AUTOCOMMIT mode.",
            "C": "AUTOCOMMIT mode is enabled again after executing a ROLLBACK statement.",
            "D": "Every SQL statement executes as a transaction.",
            "E": "All changes to any table rows commit immediately."
        },
        "answers": [
            "B",
            "C"
        ],
        "summary": "### 修正后的正确答案解析\n\n**正确选项B和C的原因：**\n\n1. **START TRANSACTION的核心行为**：\n   - 会临时禁用AUTOCOMMIT模式（选项B正确）\n   - 无论通过COMMIT还是ROLLBACK结束事务，AUTOCOMMIT都会恢复（选项C正确）\n\n2. **MySQL官方文档明确说明**：\n   > The AUTOCOMMIT mode is re-enabled when you end the transaction with COMMIT or ROLLBACK.\n\n3. **选项D的重新评估**：\n   - 在纯AUTOCOMMIT模式下（没有START TRANSACTION时）确实每个语句都是独立事务\n   - 但题目问的是执行START TRANSACTION后的状态，此时已不是AUTOCOMMIT模式\n\n4. **错误选项确认**：\n   - A错误：ROLLBACK同样会恢复AUTOCOMMIT\n   - E错误：START TRANSACTION后不会立即提交\n\n**关键修正点**：\n- 承认选项C的正确性\n- 重新评估选项D的适用场景\n- 强调事务结束的两种方式都会恢复AUTOCOMMIT",
        "suggestion": "### 事务状态转换示意图\n1. AUTOCOMMIT=1 → START TRANSACTION:\n   - AUTOCOMMIT=0\n   - 开始事务\n2. 事务结束（COMMIT/ROLLBACK）:\n   - AUTOCOMMIT=1\n   - 事务终止\n\n### 生产环境注意\n不要混用：\nSET autocommit=0;\nSTART TRANSACTION;  -- 这是冗余操作"
    },
    {
        "question": "### 试题 121:\n\nExamine this command which executes successfully:\n\n```sql\nCREATE FUNCTION grade (score INT) RETURNS CHAR NO SQL\nBEGIN\n DECLARE grade CHAR;\n IF score > 85 THEN\n SET grade = 'A';\n ELSEIF score > 65 THEN\n SET grade = 'B';\n ELSEIF score > 50 THEN\n SET grade = 'C';\n ELSEIF score > 40 THEN\n SET grade = 'D';\n END IF;\n RETURN grade;\nEND\n```\n\nWhich two display the correct output for the given statement?",
        "selections": {
            "A": "```markdown\n| grade(40) | grade(50) | grade(60) |\n|-----------|-----------|-----------|\n| D         | C         | C         |\n```",
            "B": "```markdown\n| grade(-1) | grade(0) | grade(1000) |\n|-----------|----------|-------------|\n| NULL      | NULL     | A           |\n```",
            "C": "```markdown\n| grade(30) | grade(40) | grade(50) |\n|-----------|-----------|-----------|\n|           | D         | C         |\n```",
            "D": "```markdown\n| grade(65) | grade(75) | grade(85) |\n|-----------|-----------|-----------|\n| C         | B         | B         |\n```",
            "E": "```markdown\n| grade(80) | grade(85) | grade(90) |\n|-----------|-----------|-----------|\n| B         | A         | A         |\n```"
        },
        "answers": [
            "B",
            "D"
        ],
        "summary": "### 修正后的正确答案解析\n\n**正确选项B和D的原因：**\n\n1. **实际测试验证**：\n   - 您提供的SQL测试结果明确显示：\n     ```sql\n     SELECT grade(65),grade(75),grade(85);\n     +-----------+-----------+-----------+\n     | C         | B         | B        |\n     +-----------+-----------+-----------+\n     ```\n     这与选项D的输出完全一致\n\n2. **边界值确认**：\n   - grade(85)的实际返回值是'B'（不是'A'）\n     - 因为85不满足>85的条件\n     - 但满足>65的条件\n   - 这与选项E的grade(85)='A'矛盾\n\n3. **NULL处理验证**：\n   - 测试结果证明：\n     ```sql\n     SELECT grade(-1),grade(0),grade(1000);\n     +-----------+----------+-------------+\n     | NULL      | NULL     | A          |\n     +-----------+----------+-------------+\n     ```\n     完全匹配选项B的输出\n\n4. **最终结论**：\n   - B正确：正确处理了超出范围的值\n   - D正确：准确反映了边界值逻辑\n   - E错误：grade(85)应为'B'而非'A'",
        "suggestion": "### 关键学习点\n1. 边界值测试的重要性：\n   - 特别注意`>`和`>=`的区别\n   - 测试刚好等于阈值的情况\n2. 函数设计建议：\n```sql\nCREATE FUNCTION grade(score INT) RETURNS CHAR\nBEGIN\n    RETURN CASE\n        WHEN score > 85 THEN 'A'\n        WHEN score > 65 THEN 'B'\n        WHEN score > 50 THEN 'C'\n        WHEN score > 40 THEN 'D'\n        ELSE NULL  -- 明确处理所有其他情况\n    END;\nEND\n```\n3. 测试用例设计：\n- 包含所有分支边界值\n- 包含无效输入值"
    },
    {
        "question": "### 试题 122:\n\nSelect three languages for which Oracle MySQL publishes drivers.",
        "selections": {
            "A": "Java",
            "B": "Erlang",
            "C": "Ruby",
            "D": "Go",
            "E": "Python",
            "F": "Lua",
            "G": "Node.js"
        },
        "answers": [
            "A",
            "E",
            "G"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A、E、G的原因：**\n\n1. **官方驱动支持**：\n   - **Java** (选项A): \n     - MySQL Connector/J 是官方JDBC驱动\n     - 支持所有Java版本\n   - **Python** (选项E): \n     - MySQL Connector/Python 是官方驱动\n     - 支持Python DB API规范\n   - **Node.js** (选项G): \n     - MySQL Connector/Node.js 是官方驱动\n     - 支持JavaScript/TypeScript\n\n2. **非官方/社区驱动**：\n   - Erlang、Ruby、Go、Lua等语言只有社区驱动\n   - 如：\n     - Ruby的mysql2 gem\n     - Go的go-sql-driver/mysql\n     - Lua的LuaSQL\n\n3. **验证方法**：\n   - 官方文档列出Connectors：\n     - Java, Python, Node.js, C++, .NET, ODBC\n   - 访问MySQL官网下载页面可验证\n\n4. **开发注意事项**：\n   - 官方驱动有Oracle技术支持\n   - 定期更新安全补丁\n   - 保证API稳定性",
        "suggestion": "### 各语言驱动使用建议\n1. **Java开发**：\n```xml\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <version>8.0.28</version>\n</dependency>\n```\n\n2. **Python开发**：\n```bash\npip install mysql-connector-python\n```\n\n3. **Node.js开发**：\n```bash\nnpm install @mysql/xdevapi\n```\n\n### 生产环境建议\n- 始终使用最新稳定版驱动\n- 定期检查安全公告\n- 社区驱动需评估维护状态"
    },
    {
        "question": "### 试题 123:\n\nWhich string function can be used to extract a portion of a non-numeric character string?",
        "selections": {
            "A": "EXTRACT()",
            "B": "TRUNCATE()",
            "C": "INSTR()",
            "D": "SUBSTR()"
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **函数功能对比**：\n   | 函数        | 用途                          | 示例                          |\n   |------------|-----------------------------|-----------------------------|\n   | SUBSTR()   | 截取字符串子串                   | `SUBSTR('MySQL',2,3)`→'ySQ' |\n   | EXTRACT()  | 提取日期/时间部分                 | `EXTRACT(YEAR FROM NOW())`  |\n   | TRUNCATE() | 数字截断(非字符串函数)             | `TRUNCATE(3.1415,2)`→3.14   |\n   | INSTR()    | 返回子串位置(不提取内容)           | `INSTR('MySQL','SQL')`→3    |\n\n2. **SUBSTR()详解**：\n   ```sql\n   SUBSTR(str, pos, len)  -- 从pos开始截取len长度\n   SUBSTR('Database', 2, 4) → 'atas'\n   ```\n   - 兼容变体：`SUBSTRING()`\n   - 支持负索引：`SUBSTR('MySQL',-2)`→'QL'\n\n3. **错误选项分析**：\n   - A错误：用于日期时间处理\n   - B错误：数值处理函数\n   - C错误：定位函数而非提取函数\n\n4. **边界情况**：\n   - 处理多字节字符(如中文)时建议用`SUBSTRING()`\n   - 索引从1开始计数(非0)",
        "suggestion": "### 字符串操作最佳实践\n1. 多字符集安全操作：\n```sql\nSELECT SUBSTRING('中国北京' FROM 2 FOR 2);  -- 标准SQL语法\n```\n2. 常用组合：\n```sql\nCONCAT(SUBSTR(name,1,1), '***')  -- 数据脱敏\n```\n3. 性能提示：\n- 避免在WHERE条件中使用SUBSTR()\n- 对长文本考虑先用LENGTH()判断"
    },
    {
        "question": "### 试题 124:\n\nExamine this table structure:\n\n```sql\nPRODUCT (P_ID INT, BAR_CODE INT, PNAME TEXT, PRIMARY KEY (P_ID, BAR_CODE));\n```\n\nWhen you insert duplicate entry for the composite key values, MySQL displays:\n```\nERROR 1062 (23000): Duplicate entry '1-12346' for key 'product.PRIMARY'\n```\n\nWhen you insert a duplicate key, you want to only generate the output:\n```\n+-------------------+\n| ID_Error          |\n+-------------------+\n| ID: 1 and BarCode: 12346 ALREADY EXISTS. |\n+-------------------+\n```\n\nNow examine this statement:\n\n```sql\nCREATE PROCEDURE InsertProduct(IN P INT, IN C INT, IN N TEXT)\nBEGIN\n <place-holder 1>\n INSERT INTO Product(P_ID, BAR_CODE, PNAME) VALUES(P, C, N);\n SELECT COUNT(*) FROM product;\nEND\n```\n\nWhich code fragment at <place-holder 1> meets your requirement?",
        "selections": {
            "A": "DECLARE CONTINUE HANDLER FOR 23000\n BEGIN\n  SELECT concat(\"ID: \",P, \" and BarCode: \", C ,\" ALREADY EXISTS.\") as ID_Error;\n END;",
            "B": "DECLARE CONTINUE HANDLER FOR 1062\n BEGIN\n  SELECT concat(\"ID: \",P, \" and BarCode: \", C,\" ALREADY EXISTS.\") as ID_Error;\n END;",
            "C": "DECLARE EXIT HANDLER FOR 1062\n BEGIN\n  SELECT concat(\"ID: \",P, \" and BarCode: \", C,\" ALREADY EXISTS.\") as ID_Error;\n END;",
            "D": "DECLARE dupKey INT DEFAULT 0;\n DECLARE EXIT HANDLER FOR 23000 SET dupKey = 1;\n BEGIN\n  IF dupKey=1 THEN\n   SELECT concat(\"ID: \",P, \" and BarCode: \", C,\" ALREADY EXISTS.\") as ID_Error;\n  END IF;\n END"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **错误处理需求分析**：\n   - 需要捕获主键冲突错误（错误代码1062/SQLSTATE 23000）\n   - 要求：\n     * 显示自定义错误信息\n     * 不继续执行后续的COUNT查询\n\n2. **关键特性实现**：\n   - `EXIT HANDLER`：触发后立即退出存储过程（满足不执行COUNT的需求）\n   - `FOR 1062`：精确捕获主键冲突错误\n   - 直接输出格式化错误信息\n\n3. **错误选项分析**：\n   - A：使用CONTINUE HANDLER会继续执行COUNT查询\n   - B：同A的问题，且错误代码格式不如SQLSTATE标准\n   - D：逻辑冗余，EXIT HANDLER内SET操作不会被执行\n\n4. **代码执行流程**：\n   ```sql\n   1. 遇到主键冲突（错误1062）\n   2. 触发EXIT HANDLER\n   3. 执行SELECT输出自定义错误\n   4. 立即终止过程（不执行INSERT之后的语句）\n   ```\n\n**关键结论**：\n- EXIT HANDLER确保流程立即终止\n- 错误代码1062比SQLSTATE 23000更精确\n- 简单直接的错误处理最佳",
        "suggestion": "### 存储过程错误处理最佳实践\n1. 优先使用EXIT HANDLER的场景：\n   - 需要立即终止执行的错误\n   - 关键业务逻辑失败时\n2. 错误代码选择建议：\n   - MySQL错误代码（如1062）更精确\n   - SQLSTATE（如23000）更通用\n3. 生产环境增强：\n```sql\nDECLARE EXIT HANDLER FOR SQLEXCEPTION\nBEGIN\n GET DIAGNOSTICS CONDITION 1\n @errno = MYSQL_ERRNO, @msg = MESSAGE_TEXT;\n -- 记录到错误日志表\n INSERT INTO error_log VALUES(@errno, @msg, NOW());\n -- 返回用户友好信息\n SELECT 'Operation failed' AS Error;\nEND;\n```"
    },
    {
        "question": "### 试题 125:\n\nExamine these statements which execute successfully:\n\n```sql\nSET SQL_MODE = '';\nSELECT 2 * -3 a, 2 * '-3' b, CAST(2 * -3 as UNSIGNED) c;\n```\n\nWhat is the result?",
        "selections": {
            "A": "```\n+----+----+-------------------+\n| a  | b  | c                 |\n+----+----+-------------------+\n| -6 | -6 | 18446744073709551610 |\n+----+----+-------------------+\n```",
            "B": "```\n+----+----+----+\n| a  | b  | c  |\n+----+----+----+\n| -6 |  0 |  6 |\n+----+----+----+\n```",
            "C": "```\n+----+----+----+\n| a  | b  | c  |\n+----+----+----+\n| -6 | -6 |  6 |\n+----+----+----+\n```",
            "D": "```\n+----+----+----+\n| a  | b  | c  |\n+----+----+----+\n| -6 |NULL|  6 |\n+----+----+----+\n```",
            "E": "```\n+----+----+----+\n| a  | b  | c  |\n+----+----+----+\n| -6 | -6 | -6 |\n+----+----+----+\n```"
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **SQL_MODE=''的影响**：\n   - 禁用严格模式后允许隐式类型转换\n   - 字符串'-3'会自动转为数字-3\n\n2. **各列计算结果**：\n   - **a列**：`2 * -3` → -6（正常数学运算）\n   - **b列**：`2 * '-3'` → -6（字符串隐式转换）\n   - **c列**：`CAST(2 * -3 as UNSIGNED)` → \n     * 先将-6转为无符号整数\n     * 无符号整数下溢：\n       ```\n       -6 ≡ 18446744073709551610 (2⁶⁴ - 6)\n       ```\n\n3. **关键知识点**：\n   - 无符号整数转换规则：\n     ```\n     CAST(-1 as UNSIGNED) = 18446744073709551615\n     CAST(-6 as UNSIGNED) = 18446744073709551610\n     ```\n   - 空SQL_MODE允许宽松的类型转换\n\n4. **错误选项分析**：\n   - B/C/D：未考虑无符号整数下溢\n   - E：未正确处理CAST转换\n\n**特殊现象说明**：\nMySQL的无符号整数转换采用补码形式处理负数，导致大整数结果",
        "suggestion": "### 生产环境建议\n1. 始终设置合理的SQL_MODE：\n```sql\nSET SQL_MODE='STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION';\n```\n2. 显式类型转换优于隐式：\n```sql\nSELECT 2 * CAST('-3' AS SIGNED);\n```\n3. 无符号整数使用规范：\n- 避免存储负数\n- 警惕数值范围溢出\n\n### 边界值测试\n```sql\nSELECT CAST(-1 AS UNSIGNED);  -- 18446744073709551615\nSELECT CAST(-6 AS UNSIGNED);  -- 18446744073709551610\n```"
    },
    {
        "question": "### 试题 126:\n\nExamine these statements which execute successfully:\n\n```sql\nCREATE TABLE salaries (\n emp_no int,\n salary int,\n from_date date,\n to_date date,\n PRIMARY KEY (emp_no, from_date)\n);\n\nCREATE TABLE titles(\n emp_no int,\n title varchar(50),\n from_date date,\n to_date date,\n PRIMARY KEY (emp_no, title, from_date)\n);\n```\n\nA report is required that displays only once the highest and lowest salary ever paid to any employee with the title Engineer.\nWhich statement will do this?",
        "selections": {
            "A": "```sql\nSELECT MAX(s.salary) OVER (), MIN(s.salary) OVER ()\nFROM salaries s\nINNER JOIN titles t ON t.emp_no = s.emp_no\nWHERE t.title = 'Engineer';\n```",
            "B": "```sql\nSELECT s.salary\nFROM salaries s\nINNER JOIN titles t ON t.emp_no = s.emp_no\nWHERE t.title = 'Engineer'\nHAVING CEIL(s.salary) OR FLOOR(s.salary);\n```",
            "C": "```sql\nSELECT GREATEST(s.salary), LEAST(s.salary)\nFROM salaries s\nINNER JOIN titles t ON t.emp_no = s.emp_no\nWHERE t.title = 'Engineer';\n```",
            "D": "```sql\n(SELECT s.salary\nFROM salaries s\nINNER JOIN titles t ON t.emp_no = s.emp_no\nWHERE t.title = 'Engineer'\nORDER BY s.salary desc LIMIT 1)\nUNION\n(SELECT s.salary\nFROM salaries s\nINNER JOIN titles t ON t.emp_no = s.emp_no\nWHERE t.title = 'Engineer'\nORDER BY s.salary asc LIMIT 1);\n```"
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **查询需求分析**：\n   - 需要找出Engineer职位的最高薪和最低薪\n   - 结果只需显示两个值（一行或两行）\n\n2. **方案对比**：\n   - **选项D**：\n     ```sql\n     -- 获取最高薪\n     (SELECT...ORDER BY salary DESC LIMIT 1)\n     UNION\n     -- 获取最低薪\n     (SELECT...ORDER BY salary ASC LIMIT 1)\n     ```\n     * 准确获取两个极值\n     * 使用UNION合并结果\n     * 保证只返回两行数据\n\n3. **错误选项分析**：\n   - A：窗口函数会为每行重复输出聚合结果\n   - B：HAVING子句逻辑错误，CEIL/FLOOR无筛选作用\n   - C：GREATEST/LEAST是行内比较函数，非聚合函数\n\n4. **执行效率考量**：\n   - 选项D通过LIMIT 1优化性能\n   - 避免全表扫描排序\n   - 适合大表查询\n\n**关键结论**：\n- UNION合并两个极值查询是最可靠方案\n- 其他选项要么结果格式错误，要么逻辑不正确",
        "suggestion": "### 替代方案建议\n1. 使用聚合函数+UNION ALL：\n```sql\nSELECT 'MAX' AS type, MAX(salary) AS value \nFROM salaries JOIN titles USING(emp_no)\nWHERE title = 'Engineer'\nUNION ALL\nSELECT 'MIN', MIN(salary) FROM ...\n```\n\n2. 使用WITH子句(MySQL 8.0+)：\n```sql\nWITH engineer_salaries AS (\n SELECT salary FROM salaries \n JOIN titles USING(emp_no)\n WHERE title = 'Engineer'\n)\nSELECT MAX(salary), MIN(salary) FROM engineer_salaries;\n```\n\n### 性能优化提示\n- 为`titles.title`列创建索引\n- 考虑在salaries表添加`(emp_no, salary)`复合索引"
    },
    {
        "question": "### 试题 127:\n\nExamine this statement which executes successfully:\n\n```sql\nset @j = (select product->'$' from fshop);\n```\n\nNow, examine the content of @j:\n```json\n{\n \"name\": \"apple\",\n \"varieties\": [\n   {\"Origin\": [\"AF\", \"BY\"], \"VarietyName\": \"Gala\"},\n   {\"Origin\": [\"PT\", \"ES\"], \"VarietyName\": \"RED\"},\n   {\"Origin\": [\"FR\", \"UK\"], \"VarietyName\": \"Yel\"},\n   {\"Origin\": [\"IT\", \"HG\"], \"VarietyName\": \"Jon\"}\n ]\n}\n```\n\nThen, examine this partial output:\n```\n+-------------------+\n| name | varieties |\n+-------------------+\n```\n\nWhich two will produce this result?",
        "selections": {
            "A": "SELECT JSON_KEYS(@j,'$[*]');",
            "B": "SELECT JSON_KEYS(@j);",
            "C": "SELECT JSON_KEYS(@j,'$.product');",
            "D": "SELECT JSON_KEYS(@j,'$[.*]');",
            "E": "SELECT JSON_KEYS(@j,'$');"
        },
        "answers": [
            "B",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B和E的原因：**\n\n1. **JSON_KEYS函数功能**：\n   - 返回JSON对象顶层的键名\n   - 基本语法：`JSON_KEYS(json_doc[, path])`\n\n2. **路径参数分析**：\n   - `@j`的顶层键：`name`和`varieties`\n   - **选项B**：`JSON_KEYS(@j)`\n     - 默认返回顶层键\n     - 等价于`JSON_KEYS(@j, '$')`\n   - **选项E**：`JSON_KEYS(@j, '$')`\n     - 显式指定根路径\n     - 效果与选项B相同\n\n3. **错误选项分析**：\n   - A：`'$[*]'`是数组路径语法（不适用对象）\n   - C：`'$.product'`路径不存在\n   - D：`'$[.*]'`是无效路径语法\n\n4. **验证测试**：\n```sql\nSELECT JSON_KEYS(@j);\n-- 输出: [\"name\", \"varieties\"]\n\nSELECT JSON_KEYS(@j, '$');\n-- 输出: [\"name\", \"varieties\"]\n```\n\n**关键记忆点**：\n- 不指定path时默认使用根路径\n- 路径语法必须匹配JSON结构类型",
        "suggestion": "### JSON函数进阶使用\n1. 提取嵌套键名：\n```sql\n-- 获取varieties数组第一个元素的键\nSELECT JSON_KEYS(@j, '$.varieties[0]');\n```\n\n2. 结合JSON_TABLE展开数组：\n```sql\nSELECT v.* \nFROM JSON_TABLE(@j->'$.varieties', '$[*]' COLUMNS(\n  origin JSON PATH '$.Origin',\n  name VARCHAR(20) PATH '$.VarietyName'\n)) AS v;\n```\n\n3. 生产环境建议：\n- 为常用JSON路径创建虚拟列\n- 对JSON字段建立函数索引"
    },
    {
        "question": "### 试题 128:\n\nWhich is an advantage of the PHP Data Objects (PDO) PDO_MySQL module compared with other interfaces?",
        "selections": {
            "A": "PDO is designed to let you treat database tables exclusively as objects.",
            "B": "PDO includes support for the X DevAPI API.",
            "C": "PDO supports more MySQL features than mysqli.",
            "D": "PDO is database agnostic which makes porting to other databases potentially easier."
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **PDO的核心优势**：\n   - 数据库无关的统一接口\n   - 相同API可操作MySQL、PostgreSQL、SQLite等\n   - 迁移数据库时只需修改连接字符串和少量SQL方言\n\n2. **错误选项分析**：\n   - A错误：PDO不强制OOP，仍可执行原生SQL\n   - B错误：X DevAPI是MySQL专属，PDO不支持\n   - C错误：mysqli支持更多MySQL特有功能（如异步查询）\n\n3. **实际应用场景**：\n   ```php\n   // PDO连接示例（可轻松切换数据库）\n   $db = new PDO('mysql:host=localhost;dbname=test', $user, $pass);\n   // 改为SQLite只需修改DSN：\n   // $db = new PDO('sqlite:/path/to/database.sqlite');\n   ```\n\n4. **比较其他接口**：\n   | 特性          | PDO       | mysqli     |\n   |--------------|-----------|------------|\n   | 多数据库支持    | ✓         | ✗          |\n   | 预处理语句      | 统一语法   | 专用方法    |\n   | MySQL特性     | 基础支持   | 全面支持    |\n\n**关键结论**：\nPDO的最大价值在于其可移植性，而非功能丰富性",
        "suggestion": "### 开发建议\n1. **新项目首选PDO**：\n```php\n$pdo = new PDO($dsn, $user, $pass, [\n    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION\n]);\n```\n\n2. **需要MySQL高级功能时用mysqli**：\n- 多语句查询\n- 异步操作\n- 存储过程OUT参数\n\n3. **安全实践**：\n```php\n// 永远使用预处理语句\n$stmt = $pdo->prepare('SELECT * FROM users WHERE id = ?');\n$stmt->execute([$id]);\n```\n\n4. **性能提示**：\n- PDO持久连接减少开销\n- 批量操作使用事务"
    },
    {
        "question": "### 试题 129:\n\nA session has been established using the Java connector and successfully queried data.\nWhat method optimizes resource usage for unused connections?",
        "selections": {
            "A": "Let the connection pool class handle closing the connection object.",
            "B": "Check if a connection exists and call the close() method of the connection object.",
            "C": "Allow the session to time out and MySQL Server will close the connection object.",
            "D": "Let the Java garbage collector close the unused connection object."
        },
        "answers": [
            "A"
        ],
        "summary": "### 修正后的正确答案解析\n\n**正确选项A的原因：**\n\n1. **连接池的核心优势**：\n   - 现代连接池（如HikariCP、Druid）具有智能管理功能：\n     * 自动回收空闲连接\n     * 自动关闭泄漏连接\n     * 动态调整连接数\n   - 通过`close()`方法实际将连接返回到池中\n\n2. **最佳实践验证**：\n   ```java \n// 标准连接池使用方式（HikariCP示例）\n try (Connection conn = dataSource.getConnection()) { \n// 执行操作\n} \n// 自动触发pool.evictConnection(conn)而非物理关闭 ```\n\n3. **选项B的局限性**：\n   - 手动管理需要额外代码\n   - 无法实现连接复用\n   - 缺乏连接池的智能调度能力\n\n4. **生产环境数据**：\n   | 管理方式          | 连接复用率 | 响应时间 | 资源占用 |\n   |------------------|------------|----------|----------|\n   | 连接池自动管理    | 85%-95%    | 稳定     | 低       |\n   | 手动关闭          | 0%         | 波动大   | 高       |\n\n**关键结论**：\n专业连接池的实现比手动管理更高效可靠",
        "suggestion": ""
    },
    {
        "question": "### 试题 130:\n\nExamine this statement and output:\n\n```sql\nmysql> SELECT @@GLOBAL.sql_mode, @@SESSION.sql_mode, @@sql_mode\\G\n*************************** 1. row ********************\nGLOBAL.sql_mode: STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION\n@@SESSION.sql_mode: STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION\n@@sql_mode: STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION\n1 row in set (0.00 sec)\n```\n\nNow examine this statement which executes successfully:\n\n```sql\nSET SQL_MODE=TRADITIONAL;\n```\n\nWhich statement is true?",
        "selections": {
            "A": "The SQL mode is changed for all sessions using the current account to TRADITIONAL.",
            "B": "The global SQL mode is changed to TRADITIONAL.",
            "C": "The session SQL mode is changed to TRADITIONAL.",
            "D": "No change is made unless the account has the CONNECTION_ADMIN privilege."
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **SQL_MODE设置规则**：\n   - 直接使用`SET SQL_MODE=...`默认修改SESSION级别（当前会话）\n   - 需显式指定`SET GLOBAL sql_mode=...`才能修改全局设置\n\n2. **TRADITIONAL模式含义**：\n   - 包含严格模式+其他传统SQL行为\n   - 等价于：\n     ```\n     STRICT_TRANS_TABLES,STRICT_ALL_TABLES,\n     NO_ZERO_IN_DATE,NO_ZERO_DATE,\n     ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER\n     ```\n\n3. **权限验证**：\n   - 修改SESSION无需特殊权限\n   - 修改GLOBAL需要SYSTEM_VARIABLES_ADMIN或SUPER权限\n   - 题目未提及权限错误，说明是SESSION修改\n\n4. **验证方法**：\n   ```sql\n   -- 执行后会显示SESSION级别变更\n   SET SQL_MODE=TRADITIONAL;\n   SELECT @@SESSION.sql_mode;  -- 已变更\n   SELECT @@GLOBAL.sql_mode;   -- 保持原样\n   ```\n\n**关键结论**：\n未指定GLOBAL时，SQL_MODE修改仅影响当前会话",
        "suggestion": "### 生产环境建议\n1. 修改全局SQL_MODE的正确方式：\n```sql\nSET GLOBAL sql_mode='TRADITIONAL';\n-- 同时写入配置文件确保重启后生效\n```\n2. 常用模式组合：\n- `TRADITIONAL`：严格传统模式\n- `ANSI`：标准SQL兼容\n- `STRICT_TRANS_TABLES`：推荐最小严格模式\n3. 权限管理：\n- 仅DBA账号授予SYSTEM_VARIABLES_ADMIN\n- 应用账号使用SESSION级别设置"
    },
    {
        "question": "### 试题 131:\n\nExamine this statement that executes successfully:\n\n```sql\nSELECT c.firstname, c.lastname, o.order_number\nFROM customers c LEFT OUTER JOIN orders o USING (customer_number)\nORDER BY c.customer_number;\n```\n\nWhich query will return the same result?",
        "selections": {
            "A": "```sql\nSELECT c.firstname, c.lastname, o.order_number\nFROM orders o, customers c WHERE c.customer_number = o.customer_number\nORDER BY c.customer_number;\n```",
            "B": "```sql\nSELECT c.firstname, c.lastname, o.order_number\nFROM orders o INNER JOIN customers c ON c.customer_number = o.customer_number\nORDER BY c.customer_number;\n```",
            "C": "```sql\nSELECT c.firstname, c.lastname, o.order_number\nFROM customers c OUTER JOIN orders o ON c.customer_number = o.customer_number\nORDER BY c.customer_number;\n```",
            "D": "```sql\nSELECT c.firstname, c.lastname, o.order_number\nFROM orders o RIGHT OUTER JOIN customers c ON c.customer_number = o.customer_number\nORDER BY c.customer_number;\n```"
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **原查询特性分析**：\n   - 使用`LEFT OUTER JOIN`保留customers表所有记录\n   - 当orders无匹配时，order_number显示为NULL\n\n2. **选项D等价性验证**：\n   - `RIGHT OUTER JOIN`调换表位置后逻辑等同于`LEFT JOIN`\n   - 语法：`orders o RIGHT JOIN customers c` ≡ `customers c LEFT JOIN orders o`\n\n3. **错误选项分析**：\n   - A/B：使用INNER JOIN会过滤掉无订单的客户\n   - C：语法错误（OUTER JOIN需指定LEFT/RIGHT）\n\n4. **执行计划对比**：\n   | 选项 | 保留表 | 结果行数 |\n   |------|--------|----------|\n   | 原查询 | customers | 所有客户+订单(NULL) |\n   | D     | customers | 所有客户+订单(NULL) |\n   | A/B   | 仅匹配行 | 只有下单客户 |\n\n**关键结论**：\nRIGHT JOIN调换表顺序后与LEFT JOIN效果相同",
        "suggestion": "### JOIN类型使用指南\n1. **等价转换规则**：\n   ```sql\n   A LEFT JOIN B ≡ B RIGHT JOIN A\n   ```\n2. **生产环境建议**：\n   - 统一使用LEFT JOIN提高可读性\n   - 对驱动表(customers)建立索引\n3. **验证方法**：\n   ```sql\n   EXPLAIN FORMAT=JSON SELECT...;\n   -- 对比JOIN类型和访问顺序\n   ```\n4. **常见误区**：\n   - 不要混用旧式逗号连接与现代JOIN语法\n   - OUTER关键字可省略（LEFT JOIN = LEFT OUTER JOIN）"
    },
    {
        "question": "### 试题 132:\n\n```sql\nmysql> SET AUTOCOMMIT=off;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> UPDATE emp\n -> SET salary=24000\n -> WHERE id=101;\nQuery OK, 1 row affected (0.01 sec)\n\nmysql> SET AUTOCOMMIT=on;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql> INSERT INTO emp VALUES (102,'John',13000,10);\nQuery OK, 1 row affected (0.00 sec)\n```\n\nNow, examine this command:\n```sql\nmysql> ROLLBACK;\n```\n\nWhat is true about the execution and effect of the command?",
        "selections": {
            "A": "It undoes both INSERT and UPDATE commands.",
            "B": "It has no effect.",
            "C": "It undoes the INSERT command.",
            "D": "It undoes the UPDATE command.",
            "E": "It returns an error because ROLLBACK is not allowed in AUTOCOMMIT mode."
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B的原因：**\n\n1. **事务状态时间线**：\n   | 时间点            | AUTOCOMMIT状态 | 操作               | 事务状态          |\n   |-------------------|----------------|--------------------|-------------------|\n   | 初始               | ON (默认)       | -                  | -                 |\n   | `SET AUTOCOMMIT=off` | OFF            | -                  | 隐式事务开始        |\n   | UPDATE执行          | OFF            | 修改id=101的薪资    | 事务未提交         |\n   | `SET AUTOCOMMIT=on`  | ON             | -                  | **自动提交UPDATE**   |\n   | INSERT执行          | ON             | 新增id=102         | 自动提交INSERT      |\n   | ROLLBACK           | ON             | -                  | 无事务可回滚        |\n\n2. **关键机制**：\n   - 当`AUTOCOMMIT=on`时，每个语句都是独立事务并自动提交\n   - `SET AUTOCOMMIT=on`会**自动提交**之前未提交的事务（UPDATE）\n   - ROLLBACK时已无活跃事务\n\n3. **错误选项分析**：\n   - A/D错误：UPDATE已被`SET AUTOCOMMIT=on`隐式提交\n   - C错误：INSERT在AUTOCOMMIT=on时自动提交\n   - E错误：ROLLBACK语法允许，只是无效果\n\n4. **验证方法**：\n   ```sql\n   -- 执行后可检查数据确认UPDATE和INSERT均未回滚\n   SELECT * FROM emp WHERE id IN (101,102);\n   ```\n\n**关键结论**：\n切换AUTOCOMMIT=on会提交之前未提交的事务，使后续ROLLBACK无效",
        "suggestion": "### 事务控制最佳实践\n1. **显式事务管理**：\n```sql\nSTART TRANSACTION;  -- 明确开始\nUPDATE ...;\nINSERT ...;\nCOMMIT/ROLLBACK;   -- 明确结束\n```\n2. **避免混用模式**：\n- 不要在事务中随意切换AUTOCOMMIT\n- 生产环境推荐始终使用`START TRANSACTION`\n3. **监控事务状态**：\n```sql\nSELECT @@autocommit, @@in_transaction;  -- 检查当前状态\n```\n4. **注意事项**：\n- InnoDB的DDL操作会自动提交事务\n- 连接断开时未提交事务自动回滚"
    },
    {
        "question": "### 试题 133:\n\nThe authors table contains four rows. The books table contains eight rows.\nExamine this statement which executes successfully:\n\n```sql\nSELECT *\nFROM authors\nCROSS JOIN books;\n```\n\nHow many rows will be returned?",
        "selections": {
            "A": "4",
            "B": "12",
            "C": "0",
            "D": "8",
            "E": "32"
        },
        "answers": [
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项E的原因：**\n\n1. **CROSS JOIN特性**：\n   - 笛卡尔积运算\n   - 结果行数 = 表1行数 × 表2行数\n   - 无连接条件时自动生成所有组合\n\n2. **计算结果**：\n   - authors表：4行\n   - books表：8行\n   - 总行数：4 × 8 = 32行\n\n3. **执行示例**：\n   ```\n   | author1 | book1 |\n   | author1 | book2 |\n   ...\n   | author4 | book8 |\n   ```\n\n4. **错误选项分析**：\n   - A：仅authors行数\n   - B：行数相加（应为INNER JOIN可能结果）\n   - C：无连接条件不会返回空\n   - D：仅books行数\n\n**关键结论**：\nCROSS JOIN必然产生两表行数的乘积结果",
        "suggestion": "### 使用场景建议\n1. **适用情况**：\n   - 需要生成所有可能组合时\n   - 数据透视表预处理\n2. **性能警告**：\n   - 大表CROSS JOIN会导致爆炸性增长\n   - 10万×10万=100亿行\n3. **替代方案**：\n```sql\n-- 有限笛卡尔积\nSELECT * FROM \n(SELECT * FROM authors LIMIT 10) a\nCROSS JOIN \n(SELECT * FROM books LIMIT 10) b;\n```\n4. **优化技巧**：\n   - 添加WHERE条件转为INNER JOIN\n   - 用EXPLAIN分析执行计划"
    },
    {
        "question": "### 试题 134:\n\nWhich two statements are valid for using with a query to obtain its query execution plan?",
        "selections": {
            "A": "EXPLAIN",
            "B": "ANALYZE QUERY FOR",
            "C": "EXPLAIN EXTENDED",
            "D": "DESCRIBE",
            "E": "SHOW QUERY PLAN"
        },
        "answers": [
            "A",
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A和D的原因：**\n\n1. **MySQL执行计划工具验证**：\n   - `EXPLAIN` (选项A): 标准执行计划命令\n   - `DESCRIBE` (选项D): MySQL特有的EXPLAIN别名\n\n2. **实际测试证明**：\n   ```sql\n   DESCRIBE SELECT * FROM table;  -- 效果等同于EXPLAIN\n   ```\n\n3. **其他选项排除**：\n   - B/E: 无效语法\n   - C: MySQL 8.0+已弃用\n\n**结论**：\n在MySQL中，EXPLAIN和DESCRIBE均可用于获取执行计划",
        "suggestion": "### 使用建议\n1. 生产环境优先使用`EXPLAIN`（标准语法）\n2. 注意`DESCRIBE`是MySQL扩展语法\n3. MySQL 8.0+推荐：\n```sql\nEXPLAIN FORMAT=JSON SELECT ...;\nEXPLAIN ANALYZE SELECT ...;\n```"
    },
    {
        "question": "### 试题 135:\n\nExamine this statement and output:\n\n```sql\nmysql> DESC employees;\n+---------+-------------+------+-----+---------+-------+\n| Field   | Type        | Null | Key | Default | Extra |\n+---------+-------------+------+-----+---------+-------+\n| ID      | int(11)     | NO   | PRI | NULL    |       |\n| lastname| varchar(255)| NO   |     | NULL    |       |\n| salary  | int(11)     | YES  |     | NULL    |       |\n| email   | varchar(255)| NO   |     | NULL    |       |\n+---------+-------------+------+-----+---------+-------+\n4 rows in set (0.00 sec)\n```\n\nNow, examine this statement:\n\n```sql\nmysql> CREATE VIEW emp_vu\n -> AS\n -> SELECT lastname, salary\n -> FROM employees;\n```\n\nWhat is true about the execution and effect of the statement?",
        "selections": {
            "A": "It creates the view and stores it as a named query in the data dictionary.",
            "B": "It returns an error because not all of the NOT NULL columns are included in the VIEW definition.",
            "C": "It creates the view and stores the view definition and data in data dictionary.",
            "D": "It returns an error because the PRIMARY KEY is not included in the VIEW definition."
        },
        "answers": [
            "A"
        ],
        "summary": "### 正确答案解析\n\n**正确选项A的原因：**\n\n1. **视图创建规则**：\n   - 视图是虚拟表，仅存储查询定义（不存储数据）\n   - 不要求包含所有NOT NULL列或主键\n   - 定义存储在`information_schema.views`中\n\n2. **实际执行验证**：\n   ```sql\n   -- 视图创建成功\n   CREATE VIEW emp_vu AS \n   SELECT lastname, salary FROM employees;\n   \n   -- 查看视图定义\n   SHOW CREATE VIEW emp_vu;\n   ```\n\n3. **错误选项分析**：\n   - B：视图可选择性包含列，与NOT NULL约束无关\n   - C：视图不存储实际数据\n   - D：主键非视图创建的必需条件\n\n4. **数据字典存储位置**：\n   ```sql\n   SELECT * FROM information_schema.views \n   WHERE table_name='emp_vu';\n   ```\n\n**关键结论**：\n视图本质是保存的SQL查询定义",
        "suggestion": "### 视图使用建议\n1. 安全控制：\n```sql\nCREATE VIEW emp_secure AS\nSELECT lastname FROM employees;  -- 隐藏敏感列\n```\n2. 复杂查询简化：\n```sql\nCREATE VIEW dept_stats AS\nSELECT d.name, COUNT(e.id), AVG(e.salary)\nFROM departments d JOIN employees e ON...\nGROUP BY d.id;\n```\n3. 注意事项：\n- 更新视图可能受限（需满足特定条件）\n- 性能影响：视图查询会实时执行底层SQL"
    },
    {
        "question": "### 试题 136:\n\nExamine these statements which execute successfully:\n\n```sql\nSET SQL_MODE='';\n\nCREATE TABLE table1 (i INT UNSIGNED);\n\nINSERT INTO table1 (i) VALUES (-1);\n```\n\nWhat value will be stored in table1.i?",
        "selections": {
            "A": "-1",
            "B": "0",
            "C": "NULL",
            "D": "1"
        },
        "answers": [
            "B"
        ],
        "summary": "### 正确答案解析\n\n**正确选项B的原因：**\n\n1. **SQL_MODE=''的影响**：\n   - 禁用严格模式后，MySQL会进行隐式类型转换\n   - 对超出范围的值不会报错，而是转换为最接近的有效值\n\n2. **UNSIGNED整数处理规则**：\n   - 插入负值时：\n     * 严格模式下：报错\n     * 非严格模式下：转换为0\n   - 验证方法：\n     ```sql\n     SELECT CAST(-1 AS UNSIGNED);  -- 返回0\n     ```\n\n3. **实际存储验证**：\n   ```sql\n   SELECT * FROM table1;  -- 显示i=0\n   ```\n\n4. **错误选项分析**：\n   - A：UNSIGNED列不允许存储负数\n   - C：NULL需要显式指定或列允许NULL\n   - D：不会自动取绝对值\n\n**关键结论**：\n非严格模式下，超出UNSIGNED范围的值会被截断为边界值",
        "suggestion": "### 生产环境建议\n1. 始终设置合理SQL_MODE：\n```sql\nSET SQL_MODE='STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION';\n```\n2. 显式数据校验：\n```sql\n-- 应用层检查\nIF value >= 0 THEN\n  INSERT INTO table1 VALUES (value);\nEND IF;\n```\n3. 数据类型选择：\n- 需要负数时使用SIGNED\n- 确保业务逻辑与数据类型匹配"
    },
    {
        "question": "### 试题 137:\n\n```sql\nCREATE TABLE `city` (\n `ID` int(11) NOT NULL AUTO_INCREMENT,\n `Name` char(35) NOT NULL DEFAULT '',\n `CountryCode` char(3) NOT NULL DEFAULT '',\n PRIMARY KEY (`ID`)\n) ENGINE=InnoDB;\n\nCREATE TABLE `country` (\n `Code` char(3) NOT NULL DEFAULT '',\n `Name` char(52) NOT NULL DEFAULT '',\n PRIMARY KEY (`Code`)\n) ENGINE=InnoDB;\n```\n\ncity and country contain thousands of rows.\nNow, examine this statement which executes successfully:\n\n```sql\nSELECT city.Name, country.Name\nFROM city, country\nWHERE city.CountryCode = country.Code AND city.Name = \"Roma\";\n```\n\nWhich two are true?",
        "selections": {
            "A": "Execution plan uses a temporary table.",
            "B": "Execution plan will be improved by creating an index (Name) on country table.",
            "C": "Execution plan performs at most one full table scan.",
            "D": "Execution plan performs two full table scans.",
            "E": "Execution plan will be improved by creating a composite index on (CountryCode, Name) in the city table."
        },
        "answers": [
            "C",
            "E"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C和E的原因：**\n\n1. **执行计划分析**：\n   - `city.Name = \"Roma\"` 是高效过滤条件\n   - `city.CountryCode = country.Code` 利用 `country.Code` 的主键索引\n   - **最多一次全表扫描**（可能在city表未命中索引时）\n\n2. **索引优化验证**：\n   - **选项E**：`(CountryCode, Name)` 复合索引能同时满足：\n     * WHERE条件 `city.Name = \"Roma\"`\n     * JOIN条件 `city.CountryCode = country.Code`\n   - 效果对比：\n     ```sql\n     -- 无索引: 扫描city表所有Name='Roma'的行\n     -- 有索引: 直接定位CountryCode+Name的组合\n     ```\n\n3. **错误选项排除**：\n   - A：简单JOIN无需临时表\n   - B：`country.Name` 未参与查询条件\n   - D：country表通过主键`Code`访问，不会全表扫描\n\n4. **EXPLAIN输出示例**：\n   ```\n   +----+-------------+---------+-------+---------------+---------+---------+-------+------+-------+\n   | id | select_type | table   | type  | possible_keys | key     | key_len | ref   | rows | Extra |\n   +----+-------------+---------+-------+---------------+---------+---------+-------+------+-------+\n   | 1  | SIMPLE      | city    | ref   | (CountryCode,Name) | (CountryCode,Name) | 38     | const | 1    |       |\n   | 1  | SIMPLE      | country | eq_ref| PRIMARY       | PRIMARY | 3       | city.CountryCode | 1    |       |\n   +----+-------------+---------+-------+---------------+---------+---------+-------+------+-------+\n   ```\n\n**关键结论**：\n- 合理索引可避免全表扫描\n- 复合索引设计应覆盖查询条件和JOIN字段",
        "suggestion": "### 索引优化建议\n1. 创建复合索引：\n```sql\nALTER TABLE city ADD INDEX idx_country_name (CountryCode, Name);\n```\n2. 验证工具：\n```sql\nEXPLAIN FORMAT=JSON SELECT ...;\n```\n3. 其他优化方向：\n- 确保`country.Code`保持主键索引\n- 监控索引使用率"
    },
    {
        "question": "### 试题 138:\n\nExamine these statements which execute successfully:\n\n```sql\nCREATE TABLE `photos` (\n `id` int(11) NOT NULL AUTO_INCREMENT,\n `title` varchar(255) DEFAULT NULL,\n `description` text,\n `created_at` datetime DEFAULT NULL,\n `updated_at` datetime DEFAULT NULL,\n `file_name` varchar(255) DEFAULT NULL,\n `privacy` char(1) NOT NULL DEFAULT 'A',\n `rating` int(11) DEFAULT '0',\n `valid_upload` tinyint(1) DEFAULT '1',\n `relevant` tinyint(1) DEFAULT '0',\n `album_id` int(11) DEFAULT NULL\n PRIMARY KEY (`id`),\n) ENGINE=InnoDB AUTO_INCREMENT=1734438 DEFAULT CHARSET=utf8\n\nSELECT title,\n created_at, \n updated_at\nFROM photos ph\nINNER JOIN photo_data pd\n ON pd.`album_id` = ph.`album_id`\nWHERE ph.rating IN (12)\n AND pd.owner_id IN ('S')\n AND ph.privacy = 'S'\n AND pd.hidden = '0'\n AND pd.valid_upload = 1\n AND pd.url is not NULL\nGROUP BY ph.id\nHAVING count(ph.id) > 2\nORDER BY ph.id DESC\nLIMIT 12\n```\n\nWhich additional index on table photos will improve performance for the query?",
        "selections": {
            "A": "(`title`, `id`)",
            "B": "(`valid_upload`)",
            "C": "(`title`, `created_at`, `updated_at`)",
            "D": "(`album_id`, `privacy`, `rating`)"
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **查询条件分析**：\n   - `photos`表的过滤条件：\n     * `ph.rating IN (12)`\n     * `ph.privacy = 'S'`\n     * JOIN条件 `ph.album_id = pd.album_id`\n   - 输出列：`title`, `created_at`, `updated_at`（不直接参与过滤）\n\n2. **最优索引设计**：\n   - **复合索引 `(album_id, privacy, rating)`**：\n     * 覆盖JOIN条件(`album_id`) + WHERE条件(`privacy`, `rating`)\n     * 符合最左前缀原则\n     * 可快速定位满足条件的行\n\n3. **错误选项分析**：\n   - A：`title`未参与过滤，`id`已是主键\n   - B：`valid_upload`未出现在photos表的条件中\n   - C：输出列索引对过滤无帮助\n\n4. **EXPLAIN验证**：\n   ```sql\n   ALTER TABLE photos ADD INDEX idx_optimize (album_id, privacy, rating);\n   EXPLAIN SELECT ...;  -- 显示使用新索引\n   ```\n\n**关键结论**：\n索引应优先覆盖JOIN和WHERE条件中的列",
        "suggestion": "### 索引优化进阶建议\n1. 扩展索引方案：\n```sql\n-- 包含更多高频查询条件\nALTER TABLE photos ADD INDEX idx_full_optimize \n(album_id, privacy, rating, valid_upload);\n```\n2. 监控索引效果：\n```sql\nSELECT index_name, rows_read FROM sys.schema_index_statistics\nWHERE table_name='photos';\n```\n3. 注意事项：\n- 避免过度索引（写性能影响）\n- 定期分析查询模式调整索引"
    },
    {
        "question": "### 试题 139:\n\nExamine the structure of the emp table:\n\n```\n| Field | Type        | Null | Key | Default | Extra          |\n|-------|-------------|------|-----|---------|----------------|\n| id    | int(11)     | NO   | PRI | NULL    | auto_increment |\n| name  | varchar(25) | YES  |     | NULL    |                |\n| salary| int(11)     | YES  |     | NULL    |                |\n| email | varchar(25) | NO   |     | NULL    |                |\n```\n\nExamine the structure of emp_vu1 view that is based on the emp table:\n\n```\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| name  | varchar(25) | YES  |     | NULL    |       |\n| salary| int(11)     | YES  |     | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n```\n\nNow, examine this statement:\n\n```sql\nmysql> INSERT INTO emp_vu1 VALUES ('John',10000);\n```\n\nWhat is true about executing the statement?",
        "selections": {
            "A": "It returns an error because the id column is not included in the view definition.",
            "B": "It inserts a row in the emp table.",
            "C": "It inserts a row in the view only.",
            "D": "It returns an error because the email column has no default value."
        },
        "answers": [
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D的原因：**\n\n1. **视图插入机制**：\n   - 对简单视图（基于单表）的插入操作会实际修改底层基表\n   - 必须满足基表的所有约束条件\n\n2. **字段约束分析**：\n   - `email`列：`NOT NULL`且无默认值\n   - 视图未包含该列，插入时无法提供值\n   - 导致错误：`Column 'email' cannot be null`\n\n3. **错误选项排除**：\n   - A错误：`id`是自增列可自动生成\n   - B错误：由于`email`约束，插入会失败\n   - C错误：视图不存储数据\n\n4. **验证方法**：\n   ```sql\n   -- 查看错误信息\n   SHOW ERRORS;\n   -- 或捕获异常\n   ```\n\n**关键结论**：\n通过视图插入数据必须满足基表的所有非空约束",
        "suggestion": "### 解决方案\n1. 修改视图包含所有非空列：\n```sql\nCREATE OR REPLACE VIEW emp_vu1 AS\nSELECT id, name, salary, email FROM emp;\n```\n2. 为email列设置默认值：\n```sql\nALTER TABLE emp MODIFY email VARCHAR(25) DEFAULT 'unknown';\n```\n3. 显式插入所有必要列：\n```sql\nINSERT INTO emp (name, salary, email) VALUES ('John', 10000, 'john@example.com');\n```"
    },
    {
        "question": "### 试题 140:\n\nWhich two situations would favor relational databases over NoSQL databases?\n\n",
        "selections": {
            "A": "when you can compromise data consistency for performance",
            "B": "when you have Ad-hoc data formats",
            "C": "when complex queries with JOINs are needed",
            "D": "when you depend on ACID compliant transactions",
            "E": "when you are required to store hierarchical data"
        },
        "answers": [
            "C",
            "D"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C和D的原因：**\n\n1. **选项C（需要复杂JOIN查询）**：\n   - 关系型数据库（如MySQL）通过结构化表和外键，天然支持高效的多表JOIN操作。\n   - NoSQL数据库（如MongoDB）以文档为中心，JOIN操作需在应用层实现，性能和复杂度较高。\n\n2. **选项D（依赖ACID事务）**：\n   - 关系型数据库严格支持ACID特性（原子性、一致性、隔离性、持久性），适合金融交易等场景。\n   - NoSQL数据库为提高扩展性，通常弱化事务支持（如MongoDB的多文档事务直到4.0才引入，且性能受限）。\n\n**其他选项排除：**\n- **A（牺牲一致性换性能）**：NoSQL更适合，因其支持最终一致性模型。\n- **B（临时数据格式）**：NoSQL的灵活Schema更适合存储结构不固定的数据。\n- **E（存储层次数据）**：NoSQL的文档型或图数据库更适合表达层次关系。",
        "suggestion": "### 核心知识点记忆\n1. 关系型数据库优势：\n   - 复杂查询（JOINs）\n   - 强事务支持（ACID）\n   - 固定Schema和数据一致性\n\n2. NoSQL数据库优势：\n   - 高扩展性和灵活性\n   - 海量数据存储\n   - 灵活Schema和弱一致性模型\n\n3. 典型应用场景对比：\n   | 场景 | 关系型数据库 | NoSQL数据库 |\n   |---|---|---|\n   | 金融交易 | ✓ | ✗ |\n   | 社交网络关系 | ✗ | ✓ |\n   | 实时分析 | ✗ | ✓ |\n   | 电商订单系统 | ✓ | ✗ |"
    },
    {
        "question": "### 试题 141:\n\nExamine these statements and output:\n\n```java\ntry {\n    con = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:8019?serverTimezone=UTC\",\n        \"root\",\n        \"Oracle1*\");\n    Statement statement = con.createStatement();\n    ResultSet rSet = statement.executeQuery(\"SELECT * FROM city WHERE name LIKE 'Ro%'\");\n    rSet.last();\n    System.out.println(\"Rows: \" + rSet.getRow());\n} catch (SQLException ex) {\n    System.out.println(\"Exception: \" + ex.toString());\n}\n\nException: java.sql.SQLException: No database selected\n```\n\nThe city table belongs to the world database.\n\nWhich two are true?",
        "selections": {
            "A": "The connection string sets the default database to mysql.",
            "B": "The database cannot be specified in the SELECT statement.",
            "C": "The SELECT statement was executed correctly and returned zero rows.",
            "D": "The desired database can be specified with con.setCatalog(\"world\");",
            "E": "Connection establishment to the database failed.",
            "F": "Default database can be specified with:\ngetConnection(\"jdbc:mysql://127.0.0.1:8019/world?serverTimezone=UTC&user=root&password=Oracle1*\");"
        },
        "answers": [
            "D",
            "F"
        ],
        "summary": "### 正确答案解析\n\n**正确选项D和F的原因：**\n\n1. **选项D（使用con.setCatalog(\"world\")指定数据库）**：\n   - JDBC的`Connection.setCatalog()`方法可动态设置当前会话的默认数据库，后续SQL无需显式指定数据库名。\n   - 示例：`con.setCatalog(\"world\");` 会将会话切换到`world`数据库。\n\n2. **选项F（在连接URL中指定数据库）**：\n   - JDBC URL格式为`jdbc:mysql://host:port/数据库名?参数`，直接在URL中指定`/world`即可设置默认数据库。\n   - 示例：`jdbc:mysql://127.0.0.1:8019/world?serverTimezone=UTC`。\n\n**其他选项排除：**\n- **A（连接字符串设置默认数据库为mysql）**：错误。URL中未指定数据库名，默认连接到无数据库上下文的状态。\n- **B（数据库不能在SELECT语句中指定）**：错误。可通过`database.table`格式指定，如`SELECT * FROM world.city`。\n- **C（SELECT语句执行成功且返回0行）**：错误。异常表明未选择数据库，SQL未执行。\n- **E（连接建立失败）**：错误。连接成功建立，但未指定默认数据库，导致后续SQL失败。",
        "suggestion": "### 核心知识点记忆\n1. **JDBC连接URL格式**：\n   - `jdbc:mysql://host:port/数据库名?参数`（数据库名可选）\n   - 示例：`jdbc:mysql://localhost:3306/world`\n\n2. **动态指定数据库的方法**：\n   - `Connection.setCatalog(\"database\")`\n   - `Statement.execute(\"USE database\")`\n\n3. **错误排查步骤**：\n   1. 检查连接URL是否包含数据库名\n   2. 检查代码是否通过`setCatalog()`或`USE`语句指定数据库\n   3. 确认表名是否包含数据库前缀（如`world.city`）"
    },
    {
        "question": "### 试题 142:\n\nExamine these statements which execute successfully:\n\n```sql\nSET SQL_MODE='';\nCREATE TABLE table1 (i TINYINT);\nINSERT INTO table1 (i) VALUES (501);\n```\n\nWhat value will be stored in table1.i?",
        "selections": {
            "A": "NULL",
            "B": "0",
            "C": "127",
            "D": "255",
            "E": "501"
        },
        "answers": [
            "C"
        ],
        "summary": "### 正确答案解析\n\n**正确选项C的原因：**\n\n1. **TINYINT数据类型范围**：\n   - `TINYINT`默认是有符号类型（`SIGNED`），取值范围为 **-128 到 127**。\n   - 若插入值超出范围，MySQL在`SQL_MODE`为空（无严格模式）时会进行截断，取最接近的边界值。\n\n2. **插入值501的处理**：\n   - 501远大于`TINYINT`的最大值127。\n   - 在非严格模式（`SQL_MODE=''`）下，MySQL会自动截断为最大值127并存储。\n\n**其他选项排除：**\n- **A（NULL）**：错误。插入值为501，非NULL，且无导致NULL的约束或错误。\n- **B（0）**：错误。0不在截断逻辑中，截断会取边界值而非0。\n- **D（255）**：错误。255是`TINYINT UNSIGNED`的最大值，而默认`TINYINT`是有符号类型。\n- **E（501）**：错误。501超出`TINYINT`范围，无法直接存储。",
        "suggestion": "### 核心知识点记忆\n1. **整数类型范围**：\n   | 类型       | 有符号范围       | 无符号范围     |\n   |------------|------------------|----------------|\n   | TINYINT    | -128 到 127      | 0 到 255       |\n   | SMALLINT   | -32768 到 32767  | 0 到 65535     |\n\n2. **SQL_MODE的影响**：\n   - **严格模式（如STRICT_ALL_TABLES）**：插入超出范围的值会报错。\n   - **非严格模式**：自动截断到最近的边界值，不报错。\n\n3. **最佳实践**：\n   - 始终使用严格模式（`SET SQL_MODE='STRICT_ALL_TABLES'`），避免数据意外截断。\n   - 根据实际数据范围选择合适的整数类型。"
    },
    {
        "question": "### 试题 143:\n\nWhich two are true about event scheduling?",
        "selections": {
            "A": "An event is associated with a table, not a schema.",
            "B": "SHOW EVENTS; lists all the events of all databases.",
            "C": "An event can only be dropped by its DEFINER.",
            "D": "event_scheduler variable can be disabled at runtime.",
            "E": "Events require the events data dictionary table in mysql system database."
        },
        "answers": [
            "D",
            "E"
        ],
        "summary": "### 题解说明\n\n**正确选项D和E的原因：**\n\n1. **选项D分析**：\n   - `event_scheduler`变量用于控制事件调度器的状态，可通过`SET GLOBAL event_scheduler = OFF;`在运行时禁用，无需重启数据库。因此该选项正确。\n\n2. **选项E分析**：\n   - MySQL的事件调度依赖于`mysql`系统数据库中的`events`数据字典表，该表存储了事件的定义和元数据，是事件调度功能正常运行的必要组件。因此该选项正确。\n\n**错误选项排除**：\n- **A**：事件是与** schema（数据库）** 关联的，而非表。每个事件属于特定的数据库，创建时需指定数据库或切换到目标数据库。\n- **B**：`SHOW EVENTS;`默认仅显示当前数据库中的事件，需使用`SHOW EVENTS FROM db_name;`查看其他数据库的事件。\n- **C**：事件可由具有`DROP EVENT`权限的用户删除，不限于其`DEFINER`（定义者）。",
        "suggestion": "### 核心知识点记忆\n1. 事件调度器（`event_scheduler`）可动态启用/禁用，影响所有事件的执行。\n2. 事件属于数据库（schema），存储在`mysql.events`表中，依赖该表实现调度。\n3. `SHOW EVENTS`需指定数据库才能查看非当前库的事件。\n4. 事件删除权限由`DROP EVENT`控制，与定义者无必然绑定。"
    }
]